[{"title":"LiteHub之跨域访问CORS","url":"/undefined/LiteHub_CORS/","content":"\n\n\n原理基本概念在浏览器安全模型中，同源策略是最重要的安全基石。一个“域”是由3个要素组成的：\n\n协议（如：http 或 https）\n主机（Host，如 www.example.com 或 127.0.0.1）\n端口（Port，如 80 或 8080）\n\n只要这三个完全一致，就是同源的。例如：\n\nhttp://example.com:80 和 http://example.com:8080 是不同源\nhttp://example.com 和 https://example.com 是不同源\n\n下面是官网解释跨域的图解：\n两种请求：浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n简单请求 按照 W3C 的 CORS 规范，只有完全满足「安全要求」的跨域请求，浏览器才会把它直接当成简单请求，直接发送给服务端，不需要先发 OPTIONS。 必须同时满足以下条件\n\n请求方法必须是（GET/HEAD/POST）三者之一\n请求头不能超出以下几个字段（Accept、Accept-Language、Content-Language、Content-Type）等\nContent-Type（如果存在的话），其值只能是application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n非简单请求（预检请求）非简单请求是指那些对服务器有特殊要求的请求，例如：\n\n使用PUT或DELETE方法\n设置Content-Type为application&#x2F;json即不满足简单请求的条件的都是预检请求（非简单请求）。\n\n对于这类请求，浏览器会在正式通信前额外发送一次HTTP查询请求（即预检请求），这个过程叫做预检（Preflight）。该请求会确认：\n\n当前网页域名是否在服务器的许可名单中\n允许使用的HTTP方法和头信息字段只有在获得服务器肯定答复后，浏览器才会发出正式的XMLHttpRequest请求，否则将报错。\n\n“预检请求”用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里面，关键字是 Origin，表示请求来自哪个源。除了 Origin 字段，“预检请求”的头信息包括两个特殊字段。• Access-Control-Request-Method：必须字段，列出浏览器的 CORS 请求会用到哪些 HTTP 方法；• Access-Control-Request-Headers：这个字段是一个逗号 , 分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上面示例是 X-Custom-Header。\n代码实现 CORS（Cross-Origin Resource Sharing，跨域资源共享）通过在响应头里加上一组特殊字段来告诉浏览器，这个资源允许被某些源访问。\n服务器端Cors的关键配置struct CorsConfig &#123;    std::vector&lt;std::string&gt; allowedOrigins;//允许哪些域名可以访问    std::vector&lt;std::string&gt; allowedMethods; //允许哪些方法可以跨域调用    std::vector&lt;std::string&gt; allowedHeaders; //允许前端请求里带哪些请求头    bool allowCredentials = false; //不允许携带Cookie/Authorization header/TLS client cert 这类凭证信息    int maxAge = 3600;             //浏览器缓存预检请求的最大时长, 1 小时内同样的跨域请求只会发送一次 OPTIONS，之后直接用缓存的结果        static CorsConfig defaultConfig()     &#123;        CorsConfig config;        config.allowedOrigins = &#123;&quot;*&quot;&#125;; //这里允许的是所有域名        config.allowedMethods = &#123;&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;&#125;; //在预检请求（OPTIONS）的响应里告诉浏览器：后端接受哪些方法        config.allowedHeaders = &#123;&quot;Content-Type&quot;, &quot;Authorization&quot;&#125;; //允许前端带Content-Type（比如 application/json）和Authorization（携带JWT Token等）        return config;    &#125;&#125;;\n服务端解析预检请求处理客户端发来的请求的流程如下：\n\n判断是否是预检请求，如果是，进入下一步；否则不做处理（正常的请求，继续后续的处理流程，响应）\n检查当前请求的源是否被允许，如果允许当前请求源则在响应头中添加该源字段，状态码为204 No content,响应体为空，进入下一步\n直接抛出特殊的响应对象（中断后续的处理流程）\n\n总结：如果是预检请求，设置Cors的相关字段，直接返回；否则就进入正常的处理流程。\n/** *  @brief 请求前钩子，所有请求进来时都会先执行 * 如果是跨域的 OPTIONS 预检请求，直接构造响应并抛出，跳过后续中间件/路由逻辑。 */void CorsMiddleware::before(HttpRequest&amp; request) &#123;    LOG_DEBUG &lt;&lt; &quot;CorsMiddleware::before - Processing request&quot;;        // 如果是浏览器发起的预检请求（CORS Preflight）    if (request.method() == HttpRequest::Method::kOptions)     &#123;        LOG_INFO &lt;&lt; &quot;Processing CORS preflight request&quot;;        HttpResponse response;  // 创建预检响应        handlePreflightRequest(request, response);        // 直接中断后续处理流程，抛出特殊的响应对象        throw response;    &#125;&#125;/** * @brief 处理 CORS 预检请求（OPTIONS） * 会校验 Origin，并返回允许的跨域头 */void CorsMiddleware::handlePreflightRequest(const HttpRequest&amp; request,                                           HttpResponse&amp; response) &#123;        // 从请求头获取 Origin    const std::string&amp; origin = request.getHeader(&quot;Origin&quot;);        // 校验是否允许跨域    if (!isOriginAllowed(origin))     &#123;        LOG_WARN &lt;&lt; &quot;Origin not allowed: &quot; &lt;&lt; origin;        response.setStatusCode(HttpResponse::k403Forbidden);        return;    &#125;    // 添加允许的跨域头,对预检请求返回 204 No Content；    //即响应体为空，对应返回的是options字段的预检请求的响应    addCorsHeaders(response, origin);    response.setStatusCode(HttpResponse::k204NoContent);    LOG_INFO &lt;&lt; &quot;Preflight request processed successfully&quot;;&#125;/** * @brief 检查给定 Origin 是否在允许列表里 * @param origin 来自浏览器请求头的 Origin * @return true 如果允许跨域，否则 false */bool CorsMiddleware::isOriginAllowed(const std::string&amp; origin) const &#123;    return config_.allowedOrigins.empty() ||            std::find(config_.allowedOrigins.begin(),                     config_.allowedOrigins.end(), &quot;*&quot;) != config_.allowedOrigins.end() ||           std::find(config_.allowedOrigins.begin(),                     config_.allowedOrigins.end(), origin) != config_.allowedOrigins.end(); &#125;/** * @brief 给响应添加标准的 CORS 头信息 * @param response 当前响应对象 * @param origin 本次请求允许的 Origin */void CorsMiddleware::addCorsHeaders(HttpResponse&amp; response,                                   const std::string&amp; origin) &#123;    try     &#123;           // 设置允许的 Origin        response.addHeader(&quot;Access-Control-Allow-Origin&quot;, origin);                // 是否允许携带 cookie        if (config_.allowCredentials)         &#123;            response.addHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);        &#125;                // 设置允许的方法列表,以，分割        if (!config_.allowedMethods.empty())         &#123;            response.addHeader(&quot;Access-Control-Allow-Methods&quot;,                              join(config_.allowedMethods, &quot;, &quot;));        &#125;                // 设置允许的自定义请求头列表        if (!config_.allowedHeaders.empty())         &#123;            response.addHeader(&quot;Access-Control-Allow-Headers&quot;,                              join(config_.allowedHeaders, &quot;, &quot;));        &#125;        // 设置预检结果的缓存时间（单位：秒）        response.addHeader(&quot;Access-Control-Max-Age&quot;,                           std::to_string(config_.maxAge));                LOG_DEBUG &lt;&lt; &quot;CORS headers added successfully&quot;;    &#125;     catch (const std::exception&amp; e)     &#123;        LOG_ERROR &lt;&lt; &quot;Error adding CORS headers: &quot; &lt;&lt; e.what();    &#125;&#125;/** * @brief 工具函数：把字符串数组用指定分隔符拼接起来 * @param strings 字符串列表 * @param delimiter 分隔符，如 &quot;, &quot; * @return 拼接后的字符串 */std::string CorsMiddleware::join(const std::vector&lt;std::string&gt;&amp; strings, const std::string&amp; delimiter) &#123;    std::ostringstream result;    for (size_t i = 0; i &lt; strings.size(); ++i)     &#123;        if (i &gt; 0) result &lt;&lt; delimiter;        result &lt;&lt; strings[i];    &#125;    return result.str();&#125;\n\n服务端填充响应这里的响应指的是正常处理客户端发来的请求后，在最终的响应头中添加CORS的相关信息\n/** * @brief 请求后钩子，正常请求处理完毕后执行。 * 不管是否跨域，都会在最终响应头里加上 CORS 相关头信息。 */void CorsMiddleware::after(HttpResponse&amp; response) &#123;    LOG_DEBUG &lt;&lt; &quot;CorsMiddleware::after - Processing response&quot;;        // 直接添加CORS头，简化处理逻辑    if (!config_.allowedOrigins.empty())     &#123;        // 如果允许所有源        if (std::find(config_.allowedOrigins.begin(), config_.allowedOrigins.end(), &quot;*&quot;)             != config_.allowedOrigins.end())         &#123;            addCorsHeaders(response, &quot;*&quot;);        &#125;         else         &#123;            // 简单处理：只取第一个允许的来源（可以按需改成匹配实际请求来源）            addCorsHeaders(response, config_.allowedOrigins[0]);        &#125;    &#125;&#125;\n抓包分析上图展示了请求与响应的抓包分析数据：当客户端向服务器请求加载登录页面时，服务器不仅会在响应体中返回HTML文件，还会在响应头中附带CORS配置信息供浏览器解析。CORS 详解，终于不用担心跨域问题了\n","categories":["Http后端服务器"],"tags":["网络","后端"]},{"title":"LiteHub之数据库连接池","url":"/undefined/LiteHub_databasepool/","content":"\n\n\n理论部分不使用数据库连接池我们先来看看普通的Mysql的连接过程，下图是我抓包分析的在端口3306的数据包：在执行Mysql命令之前，需要先经过Tcp的三次握手、Mysql的认证服务，TLS加密服务等操作；下图来自数据库连接池学习笔记（一）：原理介绍+常用连接池介绍经过上述分析，我们知道，如果不使用数据库连接池，执行单条Mysql命令会多了非常多我们不关心的网络交互。如果执行的Mysql查询命令比较多，就会严重影响性能。\n\n不使用数据库连接池：优点： 实现简单缺点： 网络IO较多数据库的负载较高响应时间较长及QPS较低应用频繁的创建连接和关闭连接，导致临时对象较多在关闭连接后，会出现大量TIME_WAIT 的TCP状态（在2个MSL之后关闭）\n\n使用数据库连接池\n初始连接建立当应用程序第一次访问数据库时，需要完成以下步骤：\n\n系统会创建一个新的数据库连接\n这个连接需要经过身份验证(用户名&#x2F;密码验证)\n建立TCP&#x2F;IP网络连接\n初始化会话参数和设置\n\n连接复用机制在后续访问中：\n\n系统会从连接池中获取先前建立的可用连接\n直接使用该连接执行SQL语句(如SELECT, INSERT, UPDATE等)\n执行过程中无需重新进行身份验证和连接建立\n典型的复用场景包括：\n用户多次查询同一数据表\n处理事务中的多个SQL操作\n执行批量数据处理任务\n\n\n\n连接回收过程\n每次查询完成后：\n\n系统会将连接标记为”空闲”状态\n连接会被归还到连接池中\n连接保持开启状态，等待下次请求\n如果连接空闲时间超过配置的阈值(如30分钟)，可能会被自动关闭\n\n这种机制显著提高了性能，减少了频繁创建和销毁连接的开销。\n常见的几种资源池在实际应用中，由于创建和销毁系统资源（如连接、内存块、线程等）的成本往往远高于使用资源的成本，因此通常会引入资源池的概念来提高系统性能。这种技术通过预先创建并维护一组可重用资源，避免了频繁的资源初始化和销毁操作，从而显著提升系统效率。\n常见的资源池包括以下几种类型：\n\n内存池：\n\n在C++程序开发中，malloc通过brk()系统调用向操作系统申请内存时，会一次性申请较大的内存块（只是通过brk方式申请的内存会维护内存池，小块内存；通过nmap方式申请的大块内存（默认是大于128k）没有内存池，是直接归还给操作系统了）\n当使用free释放内存时，这些内存并不会立即归还给操作系统，而是被缓存在malloc维护的内存池中\n当下次程序再次申请内存时，malloc会优先从内存池中分配可用内存块\n例如：当程序频繁进行小内存块的分配和释放时，内存池可以避免频繁的系统调用，提高内存分配效率\n\n\n线程池：\n\n传统的线程创建和销毁涉及操作系统层面的资源分配和回收，开销较大\n线程池通过预先创建一组线程并保持活跃状态，等待任务分配\n主要优势包括：\n线程复用：避免频繁创建销毁线程的开销\n任务解耦：将任务提交与执行分离，提高系统灵活性\n资源管理：可以限制并发线程数量，防止系统过载\n\n\n应用场景：Web服务器处理请求、批量数据处理等需要高并发的场景\n\n\n数据库连接池：\n\n建立数据库连接涉及网络通信、身份验证等耗时操作\n连接池维护一组已建立的数据库连接，应用程序使用时直接从池中获取\n使用完毕后连接归还池中而非关闭，供其他请求复用\n典型配置参数包括：最小连接数、最大连接数、连接超时时间等\n优势：显著降低连接建立开销，提高数据库访问效率\n\n\n\n这些资源池技术在现代软件系统中被广泛应用，特别是在高并发、高性能要求的场景下，合理配置资源池可以大幅提升系统整体性能。在实际应用中，由于创建和销毁系统资源（如连接、内存块、线程等）的成本往往远高于使用资源的成本，因此通常会引入资源池的概念来提高系统性能。这种技术通过预先创建并维护一组可重用资源，避免了频繁的资源初始化和销毁操作，从而显著提升系统效率。\n代码实现本项目数据库连接池实现了三个核心类：\n\nDbConnection：管理单个数据库连接\nDbConnectionPool：管理数据库连接池\nMysqlUtil：提供便捷的数据库操作接口\n\n以下就分别来了解一下这几个类的实现。\nDbConnection类实现成员变量：\n\nstd::shared_ptr&lt;sql::Connection&gt; conn_ 数据库连接\nstd::string    host_   数据库主机地址，如tcp:&#x2F;&#x2F;127.0.0.1:3306\nstd::string    user_    用户名\nstd::string  password_  密码\nstd::string database_  使用数据库\nstd::mutex  mutex_    互斥锁\n\n成员方法：\n\nDbConnection()构造函数, 创建并初始化数据库连接，设置连接属性（这里是设置的单语句执行，防止SQL的注入）\n~DbConnection()析构函数，自动清理连接资源，调用cleanup()函数\nping()函数，使用简单的SELECT 1语句检测与数据库的通信是否正常\nisValid()函数，与ping函数类似，区别在于不在意查询结果，遇到异常返回false\nreconnect() 函数，尝试重新建立数据库连接\ncleanup()函数，清理连接状态，需要确保所有事务以及完成，并且消费完所有查询结果\nbindParams(),绑定参数\nexecuteQuery()函数，执行sql语句的查询，并返回查询结果\nexecuteUpdate()函数，执行sql语句的更新操作\n\n在上述函数中比较重要的就是executeQuery()和executeUpdate()函数，以下是其代码定义与注释\nexecuteQuery()函数\ntemplate&lt;typename... Args&gt; //可变参数模板，接受任意数量、任意类型的参数sql::ResultSet* executeQuery(const std::string&amp; sql, Args&amp;&amp;... args)&#123;    std::lock_guard&lt;std::mutex&gt; lock(mutex_);  // 确保线程安全    try     &#123;        // 直接创建新的预处理语句，不使用缓存        std::unique_ptr&lt;sql::PreparedStatement&gt; stmt(            conn_-&gt;prepareStatement(sql)        );        bindParams(stmt.get(), 1, std::forward&lt;Args&gt;(args)...); // 绑定参数,std::forward 确保完美转发        return stmt-&gt;executeQuery(); //执行后返回 sql::ResultSet*    &#125;     catch (const sql::SQLException&amp; e)     &#123;        LOG_ERROR &lt;&lt; &quot;Query failed: &quot; &lt;&lt; e.what() &lt;&lt; &quot;, SQL: &quot; &lt;&lt; sql;        throw DbException(e.what());    &#125;&#125;\n这个是执行Sql查询的操作，在上层，通过代码\nstd::string sql = &quot;SELECT id FROM users WHERE username = ? AND password = ?&quot;;sql::ResultSet* res = mysqlUtil_.executeQuery(sql, username, password);\n传入了sql语句：”SELECT id FROM users WHERE username &#x3D; ? AND password &#x3D; ?”以及两个参数：username&#x3D;”user1“和password&#x3D;”123456“；通过参数绑定后，完整的sql语句就是“SELECT id FROM users WHERE username &#x3D; user1 AND password &#x3D;123456”随后执行Mysql的语句查询，返回查询到的结果。\nexecuteUpdate函数\ntemplate&lt;typename... Args&gt;    int executeUpdate(const std::string&amp; sql, Args&amp;&amp;... args)    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex_);        try         &#123;            // 直接创建新的预处理语句，不使用缓存            std::unique_ptr&lt;sql::PreparedStatement&gt; stmt(                conn_-&gt;prepareStatement(sql)            );            bindParams(stmt.get(), 1, std::forward&lt;Args&gt;(args)...);            return stmt-&gt;executeUpdate();        &#125;         catch (const sql::SQLException&amp; e)         &#123;            LOG_ERROR &lt;&lt; &quot;Update failed: &quot; &lt;&lt; e.what() &lt;&lt; &quot;, SQL: &quot; &lt;&lt; sql;            throw DbException(e.what());        &#125;    &#125;\n示例语句：\nconst std::string sql = &quot;INSERT INTO video_stats (video_name, view_count, like_count) VALUES (?, 0, 0) ON DUPLICATE KEY UPDATE video_name=video_name&quot;;int affected = mysqlUtil_.executeUpdate(sql, video_name);\n\n\nSQL注入的理解：当用户登录网站时，通常会输入用户名和密码。以下是一段正常的 SQL 查询代码：\nSELECT * FROM users WHERE username = &#x27;user1&#x27; AND password = &#x27;password1&#x27;;\n如果攻击者输入：\n用户名： admin&#x27; --密码： anything\n\nSQL查询变成：\nSELECT * FROM users WHERE username = &#x27;admin&#x27; --&#x27; AND password = &#x27;anything&#x27;;\n其中 – 是 SQL 的注释符号，忽略了密码条件，直接绕过了身份验证。更多可以参考SQL 注入\nDbConnectionPool类实现成员变量：\n\nstd::string     host_; 连接数据库的主机名\nstd::string     user_; 用户名\nstd::string     password_; 密码\nstd::string    database_; 指定使用的数据库\nstd::queue&lt;std::shared_ptr&lt;DbConnection&gt;&gt; connections_; 数据库连接池\nstd::mutex    mutex_; 互斥锁\nstd::condition_variable   cv_; 条件变量\nbool       initialized_ = false;   初始化标识,确保仅初始化一次\nstd::thread    checkThread_; &#x2F;&#x2F; 添加检查线程，检测数据库连接池的连接健康状况\n\n成员方法：使用单例模式，\n\ninit()函数，初始化线程池，创建 poolSize 个 DbConnection 对象，放入队列\nDbConnectionPool()构造函数，创建并分离后台线程，定期检查连接可用性\n~DbConnectionPool()析构函数，清空连接队列，释放所有连接资源\ngetConnection() 函数，从连接池获取一个可用连接\ncreateConnection() 函数，创建一个新的数据库连接\ncheckConnections() ，后台线程，定期检查所有连接是否可用。\n\n这里比较重要的就是getConnection() 函数，我贴出来代码\nstd::shared_ptr&lt;DbConnection&gt; DbConnectionPool::getConnection() &#123;    std::shared_ptr&lt;DbConnection&gt; conn;    &#123;        std::unique_lock&lt;std::mutex&gt; lock(mutex_);        // 如果连接池为空，则阻塞等待其他线程释放连接        while (connections_.empty())         &#123;            if (!initialized_)             &#123;                throw DbException(&quot;Connection pool not initialized&quot;);            &#125;            LOG_INFO &lt;&lt; &quot;Waiting for available connection...&quot;;            cv_.wait(lock);  // 等待条件变量通知        &#125;        // 从队列中取一个连接        conn = connections_.front();        connections_.pop();    &#125; // 释放锁        try     &#123;        // 在锁外检查连接        if (!conn-&gt;ping())         &#123;            LOG_WARN &lt;&lt; &quot;Connection lost, attempting to reconnect...&quot;;            conn-&gt;reconnect();        &#125;                // 使用自定义 deleter：        // 当外部 shared_ptr 被释放时，把连接放回连接池并通知等待线程        return std::shared_ptr&lt;DbConnection&gt;(conn.get(),             [this, conn](DbConnection*) &#123;                std::lock_guard&lt;std::mutex&gt; lock(mutex_);                connections_.push(conn);                cv_.notify_one();            &#125;);    &#125;     catch (const std::exception&amp; e)     &#123;           // 如果重连失败，则把连接放回队列并通知等待线程        LOG_ERROR &lt;&lt; &quot;Failed to get connection: &quot; &lt;&lt; e.what();        &#123;            std::lock_guard&lt;std::mutex&gt; lock(mutex_);            connections_.push(conn);            cv_.notify_one();        &#125;        throw;    &#125;&#125;\n函数的核心逻辑为：\n\n如果连接池为空，则阻塞等待（使用条件变量）\n连接池始终返回 std::shared_ptr&lt;DbConnection&gt;\n通过自定义的deleter在用户使用完数据库某条连接后自动归还给池使用lambda表达式，当conn使用完成后，将其归还到connections_池中去。\n\n// 使用自定义 deleter： // 当外部 shared_ptr 被释放时，把连接放回连接池并通知等待线程 return std::shared_ptr&lt;DbConnection&gt;(conn.get(),      [this, conn](DbConnection*) &#123;         std::lock_guard&lt;std::mutex&gt; lock(mutex_);         connections_.push(conn);         cv_.notify_one();     &#125;);\n\nMysqlUtil类实现static void init(const std::string&amp; host, const std::string&amp; user,                const std::string&amp; password, const std::string&amp; database,                size_t poolSize = 10)&#123;   //调用了 DbConnectionPool 的单例模式，保证全局唯一    http::db::DbConnectionPool::getInstance().init(        host, user, password, database, poolSize);&#125;template&lt;typename... Args&gt;sql::ResultSet* executeQuery(const std::string&amp; sql, Args&amp;&amp;... args)&#123;   //对外提供 执行查询（SELECT） 的接口    //使用者不需要显式创建 DbConnection，也不用关心 getConnection 和归还连接的逻辑    auto conn = http::db::DbConnectionPool::getInstance().getConnection();    return conn-&gt;executeQuery(sql, std::forward&lt;Args&gt;(args)...);&#125;template&lt;typename... Args&gt;int executeUpdate(const std::string&amp; sql, Args&amp;&amp;... args)&#123;       //对外提供 执行更新（INSERT / UPDATE / DELETE） 的接口    auto conn = http::db::DbConnectionPool::getInstance().getConnection();    return conn-&gt;executeUpdate(sql, std::forward&lt;Args&gt;(args)...);&#125;\nMysqlUtil类的实现比较简单，提供了对数据库的简单接口，隐藏了底层连接池的复杂性。主要是提供了三个方法，分别是数据库连接池的初始化、从连接池中获取连接以执行查询操作和更新（增删改）操作。MysqlUtil作为一个便捷的工具类，简化了调用接口，让业务层可以更轻松的使用连接池进行增删改查的工作。\n以上就是我对数据库连接池的一些理解，如有不当之处，敬请指出。\n","categories":["Http后端服务器"],"tags":["网络","后端","数据库"]},{"title":"LiteHub之文件下载与视频播放","url":"/undefined/LiteHub_filedownload&&videoplay/","content":"\n\n\n\n\n文件下载前端请求箭头函数//这个箭头函数可以形象理解为，x流入（=&gt;）x*x,//自然而然=&gt;前面的就是传入参数,=&gt;表示函数体x =&gt; x * x//相当于function (x) &#123;    return x * x;&#125;//如果参数不是一个，就需要用括号()括起来：(x, y) =&gt; x * x + y * y\n\n本项目的请求下载前端代码为：\n function downloadFile(resourceId, filename, progressBar, statusText) &#123;        fetch(&#x27;/resource/download&#x27;, &#123;            method: &#x27;POST&#x27;,            headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;,            body: JSON.stringify(&#123; resourceId &#125;) //通过post方式将要下载的文件路径发送给后端        &#125;)            .then(response =&gt; &#123;            if (!response.ok) &#123;                throw new Error(&#x27;下载失败&#x27;);            &#125;            const contentLength = response.headers.get(&#x27;Content-Length&#x27;);            const total = contentLength ? parseInt(contentLength, 10) : 0;//返回内容长度            const reader = response.body.getReader(); //这个可以逐块提供body            const chunks = [];            let received = 0;            const pump = () =&gt; reader.read()              .then((&#123; done, value &#125;) =&gt; &#123;                if (done) &#123;//如果读取完成，整个文件已下载                const blob = new Blob(chunks);//将所有小段chunks转换成一个完成的blob(binary large object)                const url = window.URL.createObjectURL(blob);//浏览器创建一个临时的URL地址来获取这个数据                //如blob:http://localhost/17dfc4b1-df34-4a93-a6a7-6df9f1e85e0c                const a = document.createElement(&#x27;a&#x27;);                a.href = url;                a.download = filename;                document.body.appendChild(a);                a.click();//模拟点击浏览器的下载行为                document.body.removeChild(a);                window.URL.revokeObjectURL(url);//避免内存泄露                progressBar.style.width = &#x27;100%&#x27;;                statusText.textContent = &#x27;下载完成&#x27;;                return;                &#125;                chunks.push(value);                received += value.length;                //更新下载进度                if (total &gt; 0) &#123;                const percent = Math.floor((received / total) * 100);                progressBar.style.width = percent + &#x27;%&#x27;;                progressBar.textContent = percent + &#x27;%&#x27;;                statusText.textContent = `下载中 $&#123;percent&#125;%`;                &#125; else &#123;                statusText.textContent = `下载中（未知大小）`;                &#125;                //递归调用 pump（继续读取下一段）                return pump();            &#125;);            return pump();            &#125;)            .catch(error =&gt; &#123;            console.error(&#x27;下载出错：&#x27;, error);            progressBar.style.backgroundColor = &#x27;red&#x27;;            statusText.textContent = &#x27;下载失败&#x27;;            &#125;);        &#125;//类比// 后端：用水龙头一点点把水流出来// 前端：接水并灌到瓶子里（Blob）// createObjectURL：给这瓶水贴个标签（blob URL）// 点击下载：把瓶子交给你下载// revokeObjectURL：把标签撕掉，清理内存\n对于pump函数的理解，结合箭头函数和promise\n\nreader.read() ○ 返回一个 Promise&lt;{ done: boolean, value: Uint8Array }&gt;。 ○ done: true 表示读取完了； ○ value 是当前读取的一段数据（Uint8Array 格式）。\n箭头函数 () &#x3D;&gt; reader.read().then(…)○  这是一个返回 Promise 的函数。○ done: true 表示读取完了；○ value 是当前读取的一段数据（Uint8Array 格式）。\n箭头函数 () &#x3D;&gt; reader.read().then(({ done, value }) &#x3D;&gt; { return dump()} ■ ()&#x3D;&gt;reader.read(),无参数传入，执行reader.read()，返回reader.read()执行的结果{done,value}。 ■ .then({ done, value })通过上一步接收这两个数据，然后通过这两个执行相应内容； ■ 如果done为false，表示还没执行完成，chunks.push(value)：把这一段加入缓存  ，更新进度条， 递归调用自身，继续下一段读取  （return pump()）。\n\n后端响应 FileUtil file(filePath); if (!file.isValid()) //判断请求的文件是否有效&#123;    LOG_WARN &lt;&lt; filePath &lt;&lt; &quot;not exist.&quot;;    resp-&gt;setStatusLine(req.getVersion(), http::HttpResponse::k404NotFound, &quot;Not Found&quot;);    resp-&gt;setContentType(&quot;text/plain&quot;);    std::string resp_info=&quot;File not found&quot;;    resp-&gt;setContentLength(resp_info.size());    resp-&gt;setBody(resp_info);&#125;//设置相应头resp-&gt;setStatusLine(req.getVersion(), http::HttpResponse::k200Ok, &quot;OK&quot;);resp-&gt;setCloseConnection(false);resp-&gt;setContentType(&quot;application/octet-stream&quot;);std::string filename = std::filesystem::path(filePath).filename().string();LOG_INFO&lt;&lt;&quot;filename:&quot;&lt;&lt;filename;resp-&gt;addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + filename + &quot;\\&quot;&quot;);//设置响应格式为文件类型，并添加文件的路径resp-&gt;setContentLength(file.size());resp-&gt;setisFileResponse(filePath);\n设计亮点在HttpResponse.h头文件中\npublic:    bool isFileResponse() const &#123;return isFileResponse_;&#125;    std::string getFilePath() &#123;return filePath_;&#125;    void setisFileResponse(const std::string&amp; path)    &#123;         isFileResponse_ = true;         filePath_ = path;    &#125;private:bool                               isFileResponse_; //判断是否是文件，如果是，采用流式发送std::string                        filePath_;\n在httpserver的请求函数中判断，如果是文件类型，就调用tcpconnection先将响应头发送出去，然后将消息体分小块发送，这里设置的是8kb；如果不是文件类型，直接将整个响应发送出去在HttpServer::onRequest函数中\n// 给response设置一个成员，判断是否请求的是文件，如果是文件设置为true，并且存在文件位置在这里send出去。if (!response.isFileResponse())&#123;\t    //不是文件类型    muduo::net::Buffer buf;    response.appendToBuffer(&amp;buf);        conn-&gt;send(&amp;buf);&#125;else&#123;     // 1. 构造响应头    muduo::net::Buffer headerBuf;    response.appendToBuffer(&amp;headerBuf);  // 只添加状态行和头部，不包含 body    conn-&gt;send(&amp;headerBuf);  // 先发 header    // 2. 发送文件内容（分块）    const std::string filePath = response.getFilePath();    std::ifstream file(filePath, std::ios::binary);// 以二进制模式打开文件    if (file) &#123;        const size_t bufferSize = 8192; \t\t\t// 8KB 缓冲区        char buffer[bufferSize];                  // 栈上分配缓冲区        while (file) &#123;                            // 循环直到文件读取结束或出错            file.read(buffer, bufferSize);        // 读取最多 bufferSize 字节到 buffer            std::streamsize bytesRead = file.gcount(); // 实际读取的字节数            if (bytesRead &gt; 0) &#123;                conn-&gt;send(muduo::StringPiece(buffer, bytesRead));// 发送数据块            &#125;        &#125;    &#125; else &#123;        // 文件打不开，补偿错误提示        muduo::net::Buffer errBuf;        errBuf.append(&quot;HTTP/1.1 500 Internal Server Error\\r\\n\\r\\nFile open failed&quot;);        conn-&gt;send(&amp;errBuf);    &#125;&#125;\n之所以是在httpserver上分块发送数据流，是为了保证代码较好的层次性，httpserver负责管理多个tcp连接，包括发送消息和接收消息等。\n视频播放  // 从请求中获取 Range 头，例如 &quot;bytes=1000-2000&quot;    std::string rangeHeader = req.getHeader(&quot;Range&quot;);    LOG_INFO &lt;&lt; &quot;Range Header: &quot; &lt;&lt; rangeHeader;    // 默认起始字节 start=0，结束字节 end=文件大小-1，表示完整文件    std::streamsize start = 0, end = fileSize - 1;    // 标记是否是分块响应    bool isPartial = false;    if (!rangeHeader.empty()) &#123;        // 如果客户端带了 Range，则标记为分块传输        isPartial = true;        long s = 0, e = -1;         // 使用 sscanf 解析格式 bytes=&lt;start&gt;-&lt;end&gt;        // 注意：用户可能只写了起始，没有写结束，所以要判断 sscanf 返回值        int n = sscanf(rangeHeader.c_str(), &quot;bytes=%ld-%ld&quot;, &amp;s, &amp;e);        start = s;        if (n == 1 || e == -1) &#123;// 如果只解析到 1 个数，或者结束为 -1，则表示读到文件末尾            end = fileSize - 1;        &#125; else &#123;            // 解析到两个数，且结束不能超过文件大小            end = std::min((std::streamsize)e, fileSize - 1);        &#125;         // 合法性检查：start 必须小于等于 end 且小于文件大小        if (start &gt; end || start &gt;= fileSize) &#123;            // 如果不合法，返回 416 状态码（Requested Range Not Satisfiable）            resp-&gt;setStatusLine(req.getVersion(), http::HttpResponse::k416RequestedRangeNotSatisfiable, &quot;Requested Range Not Satisfiable&quot;);            char rangeValue[64];            // Content-Range 必须带 &quot;*/总大小&quot;            snprintf(rangeValue, sizeof(rangeValue), &quot;bytes */%ld&quot;, fileSize);            resp-&gt;addHeader(&quot;Content-Range&quot;, rangeValue);            resp-&gt;setCloseConnection(true);            resp-&gt;setContentType(&quot;text/plain&quot;);            resp-&gt;setBody(&quot;Invalid Range&quot;);            return;        &#125;    &#125;    // 计算需要读取的 chunkSize    std::streamsize chunkSize = end - start + 1;    std::vector&lt;char&gt; buffer(chunkSize);    // 如果需要分块，最好这里限制一下 chunkSize，防止内存过大    // 定位到要读的起始位置    file.seekg(start, std::ios::beg);    // 从文件读出 chunkSize 大小的数据到 buffer    file.read(buffer.data(), chunkSize);    // === 构造响应 ===    if (isPartial) &#123;        resp-&gt;setStatusLine(req.getVersion(), http::HttpResponse::k206PartialContent, &quot;Partial Content&quot;);        char rangeHeaderValue[128];        snprintf(rangeHeaderValue, sizeof(rangeHeaderValue),                &quot;bytes %ld-%ld/%ld&quot;, start, end, fileSize);        resp-&gt;addHeader(&quot;Content-Range&quot;, rangeHeaderValue);    &#125; else &#123;        resp-&gt;setStatusLine(req.getVersion(), http::HttpResponse::k200Ok, &quot;OK&quot;);    &#125;    resp-&gt;addHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;);// 无论是否分块，都要告知支持分块    resp-&gt;setContentType(&quot;video/mp4&quot;);         // 设置内容类型为 mp4 视频    resp-&gt;setContentLength(buffer.size());     // 设置 Content-Length    resp-&gt;setBody(std::string(buffer.begin(), buffer.end()));  // 把读取的文件块设置到响应体&#125;\n后端涉及对请求体中的range字段进行解析，判断range字段的合法性，随后根据range字段请求内容决定是返回部分内容还是全部内容。请求所有内容：依次拖动播放进度条，range字段发生改变，格式为–字段，这里是请求从某一时刻到视频结束。请求部分内容：这里请求的是从字节6000-18000大小的数据，返回的响应为这里的响应头字段为206 partial content,表示响应返回的只是视频的一部分数据。\n\nrange的合法性校验这里我手动指定range的范围为6000-18000000000000，实际是超出了请求视频的最大范围，看看最后返回的什么。使用curl（这里因为是测试，所以去掉了权限的判定，实际上运行的时候使用curl是不可行的）可以看到这里返回的是文件的最大大小。\n","categories":["Http后端服务器"],"tags":["网络","后端"]},{"title":"LiteHub之环境配置","url":"/undefined/LiteHub_env_conf/","content":"\n\n\n仓库地址演示地址\n禁用自动更新sudo systemctl stop apt-daily.timersudo systemctl stop apt-daily-upgrade.timersudo systemctl disable apt-daily.timersudo systemctl disable apt-daily-upgrade.timer\n安装boostsudo apt-get install libbz2-devsudo apt-get install libicu-dev//下载地址https://sourceforge.net/projects/boost/files/boost/1.69.0/tar -xvf 压缩包./bootstrap.sh./b2sudo ./b2 --prefix=/usr/local/boost install//添加环境变量vim /etc/environmentCPLUS_INCLUDE_PATH=/usr/local/boost/includeLIBRARY_PATH=/usr/local/boost/lib\nLinux：编译安装boost 1.69库\n安装muduo库sudo apt install g++ cmake make libboost-dev//下载并解压文件./build.sh./build.sh installcd ../build/cd release-install-cpp11cd include/mv muduo/ /usr/include/cd ../libmv * /usr/local/lib/\nmuduo网络库下载安装教程\n安装mysqlsudo wget https://downloads.mysql.com/archives/get/p/23/file/mysql-server_5.7.29-1ubuntu18.04_amd64.deb-bundle.tarsudo tar -xvf mysql-server_5.7.29-1ubuntu18.04_amd64.deb-bundle.tar//更新依赖源sudo apt-get update//安装依赖包sudo apt-get install ./libmysql*sudo apt-get install libtinfo5sudo apt-get install ./mysql-community-client_5.7.29-1ubuntu18.04_amd64.debsudo apt-get install ./mysql-client_5.7.29-1ubuntu18.04_amd64.debsudo apt-get install ./mysql-community-server_5.7.29-1ubuntu18.04_amd64.deb sudo apt-get install ./mysql-server_5.7.29-1ubuntu18.04_amd64.deb//连接数据库mysql -u root -p//开启远程访问use mysql;select User,Host from user;GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;flush privileges;vim /etc/mysql/mysql.conf.d/mysqld.cnf 将Bindaddres 从127.0.0.1 改为0.0.0.0systemctl restart mysql\nUbuntu22部署MySQL5.7详细教程\nUbuntu22部署MySQL5.7详细教程\n其他配置//安装nlohmann/jsonsudo apt upgradesudo apt install nlohmann-json3-dev//c++ mysql 库sudo apt install libmysqlcppconn-dev//安装openssl开发库sudo apt install libssl-dev//安装ffmpeg库sudo apt-get install ffmpegffmpeg -version//安装gzipsudo apt-get install gzipgzip --versionsudo apt install zlibsudo apt install zlib1g-dev\n创建表操作//创建web数据库create database webdb;use webdb;//创建用户表create table users (id int(11) not null auto_increment,username varchar(255) not null,password varchar(255) not null,primary key(id));//创建文件信息表CREATE TABLE fileinfo (    id INT AUTO_INCREMENT PRIMARY KEY,    filename VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,    username VARCHAR(100) NOT NULL,    uploadtime DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,    duration FLOAT DEFAULT NULL,    isvideo   TINYINT(1) NOT NULL DEFAULT 0) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;;//创建评论表CREATE TABLE comments (  id INT AUTO_INCREMENT PRIMARY KEY,  video_name VARCHAR(255) NOT NULL,  user_id INT NOT NULL,  parent_id INT DEFAULT 0,  content TEXT NOT NULL,  created_at DATETIME DEFAULT CURRENT_TIMESTAMP) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;CREATE TABLE video_likes (    user_id INT(11) NOT NULL,    video_name VARCHAR(255)  NOT NULL,    PRIMARY KEY (user_id, video_name))CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;CREATE TABLE video_stats (    video_name VARCHAR(255)  NOT NULL,    view_count INT(11) DEFAULT 0,    like_count INT(11) DEFAULT 0,    PRIMARY KEY (video_name)) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;//或者直接设置整个数据库使用这个字符集ALTER DATABASE mydatabase CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n共创建如下几个表\n","categories":["Http后端服务器"],"tags":["后端"]},{"title":"LiteHub之中间件限流实现","url":"/undefined/LiteHub_middleware_traffic&&control/","content":"\n\n\n\n相关原理为什么要限流？\n\n在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流。其中，限流在很多场景中用来限制并发和请求量，比如说秒杀抢购，保护自身系统和下游系统不被巨型流量冲垮等。\n\n常见的限流方法包括计数器、滑动窗口、漏桶和令牌桶算法。\n计数器算法：在一段时间间隔内（时间窗&#x2F;时间区间，处理请求的最大数量固定，超过部分不做处理。简单粗暴，比如指定线程池大小，指定数据库连接池大小、nginx连接数等，这都属于计数器算法。\n计数器算法是限流算法里最简单也是最容易实现的一种算法。举个例子，比如我们规定对于接口A，我们1分钟的访问次数不能超过100个。\n计数器限流的做法是：我们可以初始化一个计数器counter，每当收到请求时counter加1。若counter值超过100且当前请求与首个请求的时间间隔小于1分钟，则判定为请求过多并拒绝访问；若时间间隔超过1分钟且counter仍在限流范围内，则重置counter。\n但是这个方法存在一个显著的问题，攻击者可以在0:59的时候一次性发100个请求；到1:00就会将计数器清零，然后在1:01的时候再发100个请求；对于0:00-1:00和1:00-2:00这两个一分钟的请求都是100个请求，看起来是满足系统的要求的；但是在0:59-1:01这不足1分钟的时间段内，却发起了200个请求，可能会引起系统奔溃。\n滑动窗口算法：\n滑动窗口（rolling window）是一种时间分段技术。在计数器算法中，如果限制1分钟内的访问次数，这个1分钟就是一个固定时间窗口。而滑动窗口则是将这个固定窗口进一步细分成多个更小的时间单元。\n\n例如：将1分钟的固定窗口划分为6个10秒的小窗口。整个红色矩形框代表一个大时间窗口，窗口会持续滑动，每10秒向右移动一格。假设在第一分钟的第59秒收到100个请求（落在灰色格子），第二分钟的1:00又收到100个请求（落在橘黄色格子）。此时滑动窗口检测到完整1分钟（红色框）内的总请求量达到200次，超过100次的限流阈值，就能及时触发限流机制。滑动窗口划分得越精细，限流统计的准确性就越高，但过于精细会增加系统负担。\n漏桶算法：\n水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会超过桶可接纳的容量时直接溢出。漏桶算法可以粗略的认为就是注水漏水过程，往桶中以任意速率流入水，以一定速率流出水，当水超过桶容量（capacity）则丢弃，因为桶容量是不变的，保证了整体的速率。总结：漏桶算法通过一个固定容量和固定漏水速率的水桶模型，强制将任意输入流量整形为恒定速率输出，并在流量超过容量时丢弃请求，以此实现速率限制、流量平滑和系统保护。\n\n令牌桶算法：\n令牌桶是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌，填满了就丢弃令牌，请求是否被处理要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求。在流量低峰的时候，令牌桶会出现堆积，因此当出现瞬时高峰的时候，有足够多的令牌可以获取，令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌。令牌桶中装的是令牌。\n\n\n特点：与漏桶算法相比，令牌桶算法允许短时间内的请求量激增（获得令牌后即可访问接口，可能出现瞬间消耗所有累积令牌的情况），但不会像计数算法那样产生过高峰值（因为令牌是匀速生成的）。因此，令牌桶算法在处理突发流量时表现更优。部分内容和图片来源：常见限流算法：计数器、滑动窗口、漏桶、令牌桶限流：计数器、漏桶、令牌桶 三大算法的原理与实战（史上最全）\n限流实现本项目我是基于令牌桶实现的访问限流，请看以下代码LimitMiddleware.h头文件\nclass LimitMiddleware: public Middleware &#123;public:    // 构造函数    // rate：令牌生成速率（个/秒）    // capacity：桶最大容量（最多存多少个令牌）    LimitMiddleware(int rate, int capacity);    // 在请求处理前调用，用于限流    void before(HttpRequest&amp; request) override;    void after(HttpResponse&amp; response) override &#123;&#125;;    double gettokens() const &#123;return tokens_;&#125;private:    // 补充令牌（根据时间推移）    void refillTokens();private:    int rate_;            // 令牌生成速率（个/秒）    int capacity_;        // 桶容量（最大令牌数）    double tokens_;       // 当前可用令牌数（允许小数，更精确）    std::chrono::steady_clock::time_point lastRefillTime_; // 上一次补充时间    std::mutex mutex_;    // 保护多线程访问&#125;;\nLimitMiddleware.cc文件\nusing namespace std::chrono;// 令牌桶限流中间件// 构造函数：指定令牌产生速率 rate (个/秒) 和桶容量 capacity (最多可存储多少令牌)LimitMiddleware::LimitMiddleware(int rate, int capacity)    : rate_(rate),      capacity_(capacity),      tokens_(capacity),  // 初始化时桶是满的，令牌数等于容量      lastRefillTime_(steady_clock::now())  // 记录上次补充令牌的时间&#123;&#125;// 令牌补充逻辑// 根据距离上次补充的时间，按速率补充新令牌void LimitMiddleware::refillTokens()&#123;    auto now = steady_clock::now();    auto elapsedMs = duration_cast&lt;milliseconds&gt;(now - lastRefillTime_).count();    if (elapsedMs &gt; 0)    &#123;           // 按照速率计算可以补充的令牌数        double newTokens = (elapsedMs / 1000.0) * rate_;        // 桶中的令牌数不能超过容量上限        tokens_ = std::min((double)capacity_, tokens_ + newTokens);        // 更新时间戳        lastRefillTime_ = now;    &#125;&#125;// 请求前执行：判断是否有足够的令牌//如果有足够的令牌，进行下一步操作//如果没有，拒绝访问，返回状态码429void LimitMiddleware::before(HttpRequest&amp; request)&#123;       // 加锁保证多线程安全    std::lock_guard&lt;std::mutex&gt; lock(mutex_);    // 先补充令牌    refillTokens();    if (tokens_ &gt;= 1.0)    &#123;        tokens_ -= 1.0;        // 有足够令牌，消费 1 个，允许请求通过    &#125;    else    &#123;           // 没有足够令牌，请求被拒绝，抛出 429 响应        HttpResponse resp;        resp.setStatusLine(request.getVersion(), http::HttpResponse::k429TooManyRequests, &quot;Too Many Requests&quot;);        resp.setCloseConnection(true);        resp.setContentType(&quot;application/json&quot;);        resp.setContentLength(0);        resp.setBody(&quot;Rate limit exceeded. Please try again later.&quot;);        throw resp;    &#125;&#125;\n\n核心逻辑是：\n\n按固定速率补充令牌（refillTokens）\n请求到来时消费令牌（before）\n没有令牌可用时返回（限流了，返回状态码429 Too Many Requests）\n\n限流测试在WebApps/LiteHubServer/src/LiteHubServer.cpp中的initializeMiddleware函数中，定义了限流中间件\nlimitMiddleware_ = std::make_shared&lt;http::middleware::LimitMiddleware&gt;(1,100); // 每秒最多100个请求httpServer_.addMiddleware(limitMiddleware_);\n这里定义的是一秒不超过100个请求，如果通过手动点击，这个1秒内怎么也到不了100次请求；所以我通过python脚本代码模拟一次大量的访问，python代码如下，\nimport requestsfrom concurrent.futures import ThreadPoolExecutor, as_completedimport timefrom collections import Counter# -------------------------------# 压测参数配置# -------------------------------TOTAL_REQUESTS = 150      # 总请求数MAX_WORKERS = 3           # 并发线程数REQUEST_INTERVAL = 0.02   # 相邻请求的间隔（秒），避免瞬间爆发TARGET_URL = &quot;http://47.122.77.97/&quot;  # 目标 URL# -------------------------------# 单次请求任务# index: 请求编号# -------------------------------def send_request(index):    try:        start_time = time.time()        # 发起 GET 请求        r = requests.get(TARGET_URL, timeout=3)        elapsed = time.time() - start_time        # 打印日志：时间戳 + 请求序号 + 响应码 + 耗时        print(f&quot;[&#123;time.strftime(&#x27;%H:%M:%S&#x27;)&#125;] 请求 &#123;index + 1:02d&#125; --&gt; 状态码: &#123;r.status_code&#125; (耗时: &#123;elapsed:.2f&#125;s)&quot;)        return r.status_code    except Exception as e:        # 异常时打印错误信息        print(f&quot;[&#123;time.strftime(&#x27;%H:%M:%S&#x27;)&#125;] 请求 &#123;index + 1:02d&#125; --&gt; 失败: &#123;str(e)&#125;&quot;)        return str(e)# -------------------------------# 主程序入口# -------------------------------def main():    print(f&quot;开始压测，总请求数：&#123;TOTAL_REQUESTS&#125;，最大并发数：&#123;MAX_WORKERS&#125;&quot;)    results = []    # 记录整个压测开始时间    total_start_time = time.time()    # 创建线程池    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:        futures = []        # 提交任务        for i in range(TOTAL_REQUESTS):            futures.append(executor.submit(send_request, i))            time.sleep(REQUEST_INTERVAL)  # 控制相邻请求的间隔        # 等待所有任务完成        for future in as_completed(futures):            results.append(future.result())    # 记录整个压测结束时间    total_elapsed = time.time() - total_start_time    # -------------------------------    # 统计与输出结果    # -------------------------------    print(&quot;\\n-----------------------------&quot;)    print(&quot;请求状态统计结果:&quot;)    counts = Counter(results)    for key, count in counts.items():        print(f&quot;&#123;key&#125;: &#123;count&#125; 次&quot;)    print(f&quot;\\n压测总耗时: &#123;total_elapsed:.2f&#125; 秒&quot;)    print(&quot;-----------------------------&quot;)if __name__ == &quot;__main__&quot;:    main()\n执行python代码的结果如下：\n\n可用看到总共有104次请求成功；46次拒绝访问。证明了设计的令牌桶限流策略有效。我们将REQUEST_INTERVAL 调整的大一些，避免瞬间的大量请求\nREQUEST_INTERVAL = 0.1   \n再执行一次：拒绝访问的次数也少了一些，从（46—&gt;&gt;&gt;34,即减少了12次）。\n下图为wireshark抓包到的429状态码响应：\n","categories":["Http后端服务器"],"tags":["网络","后端"]},{"title":"LiteHub之请求与响应报文分析","url":"/undefined/LiteHub_req_res/","content":"\n\n\n这一篇文章是基于项目LITEHUB分析的关于HTTP的请求和响应篇章，后续将仔细分析这个项目所涉及到的知识点。上图是使用wireshark抓包分析的HTTP刷新网页的请求以及返回的响应报文格式。接下来我们就详细分析：\n请求报文理论部分请求报文主要由请求行、请求头、空行、请求头构成。  请求行包括一下字段：常见的方法包括GET（请求信息）、POST（提交数据，表单）方法等，资源路径（请求资源的URI路径）、HTTP的版本（HTTP1.1&#x2F;HTTP2.0）请求头的字段较多，常使用的包含以下几个：● Host：请求的服务器的域名。● Accept：客户端能够处理的媒体类型。● Accept-Encoding：客户端能够解码的内容编码。● Authorization：用于认证的凭证信息，比如token数据。● Content-Length：请求体的长度。● Content-Type：请求体的媒体类型。● Cookie：存储在客户端的cookie数据，在我的项目中，也是通过存在cookie字段来区别不同用户。\n空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。而请求体通常用于 POST 和 PUT 请求，包含发送给服务器的数据。\nwireshark抓包分析\n\n请求行：这里使用请求方法为GET,请求的路径为/resource/list（服务器通过路由转发确定其实际请求的路径资源，后面会分析），并且使用的版本号是HTTP/1.1.\n请求头：是以一系列的键值对组成的。如上图包括Host:192.168.83.128(表示请求的服务器的域名，这个字段是为了区分在一个服务器上存在多个地址的问题，如百度和edge都在一台服务器的不同网卡上服务，通过这个字段可以区分)；Cookie: sessionId=ef4130be9ef3c2b7264455b2a201a1b1（保持访问的一个状态），其余字段感兴趣的话可以自己去了解\n空行： \\r\\n，用于分割请求头和请求体；\n请求体：这里为空；\n\n代码解析上面我们已经分析了请求体的格式，接下来我们就根据格式，通过代码解析请求报文。\n在HttpContext.h中定义解析的状态，只有当前状态成功解析完成后，才可以转到下一个状态；\nenum HttpRequestParseState&#123;    kExpectRequestLine, // 解析请求行    kExpectHeaders, // 解析请求头    kExpectBody, // 解析请求体    kGotAll, // 解析完成&#125;;\n在HttpContext.c中定义两个标志，用于标志每个状态解析是否出错以及是否解析完成（如果请求体有值，就需要解析到请求体；如果请求体为空，则解析到空行就行）。\nbool ok = true; // 解析每行请求格式是否正确bool hasMore = true; //是否还需要解析\n\n1.请求行解析当前的请求行是这样：GET /resource/list HTTP/1.1\\r\\n请看代码\n if (state_ == kExpectRequestLine)        &#123;           \t//找到\\r\\n            const char *crlf = buf-&gt;findCRLF(); // 注意这个返回值边界可能有错            if (crlf)            &#123;\t            \t//(buf-&gt;peek(), crlf)区间;其实就对应GET /resource/list HTTP/1.1                ok = processRequestLine(buf-&gt;peek(), crlf);                if (ok)                &#123;                    request_.setReceiveTime(receiveTime);                    //向后移动两个字符，跳过\\r\\n                    buf-&gt;retrieveUntil(crlf + 2);                    //并设置状态为kExpectHeaders，用于解析请求头                    state_ = kExpectHeaders;                &#125;                else                &#123;\t                \t//如果解析出错，停止解析                    hasMore = false;                &#125;            &#125;            else            &#123;\t            \t//如果请求行没有找到\\r\\n，说明请求行格式错误，停止解析                hasMore = false;            &#125;        &#125;//定义专门用来解析请求行的函数bool HttpContext::processRequestLine(const char *begin, const char *end)&#123;    bool succeed = false;    const char *start = begin;    //以这个为例，GET /resource/list HTTP/1.1    const char *space = std::find(start, end, &#x27; &#x27;);//找到第一个空格    if (space != end &amp;&amp; request_.setMethod(start, space))//将GET截取出来并存储到request_的请求方法字段    &#123;        start = space + 1;        space = std::find(start, end, &#x27; &#x27;);//继续找下一个空格        if (space != end)        &#123;            const char *argumentStart = std::find(start, space, &#x27;?&#x27;);            if (argumentStart != space) // 请求带参数            &#123;\t            \t//GET /search?q=example HTTP/1.1,类似这种会被解析为路径和对应参数                request_.setPath(start, argumentStart); // 注意这些返回值边界                request_.setQueryParameters(argumentStart + 1, space);            &#125;            else // 请求不带参数            &#123;\t            \t//将/resource/list添加到请求路径中                request_.setPath(start, space);            &#125;            start = space + 1;            //&quot;HTTP/1.1&quot;或者&quot;HTTP/1.0&quot;都是8个字节            succeed = ((end - start == 8) &amp;&amp; std::equal(start, end - 1, &quot;HTTP/1.&quot;));            if (succeed)            &#123;\t//设置HTTP版本协议号                if (*(end - 1) == &#x27;1&#x27;)                &#123;                    request_.setVersion(&quot;HTTP/1.1&quot;);                &#125;                else if (*(end - 1) == &#x27;0&#x27;)                &#123;                    request_.setVersion(&quot;HTTP/1.0&quot;);                &#125;                else                &#123;\t                    succeed = false;                &#125;            &#125;        &#125;    &#125;    return succeed;&#125;// 这是从问号后面分割参数void HttpRequest::setQueryParameters(const char *start, const char *end)&#123;    std::string argumentStr(start, end);    std::string::size_type pos = 0;    std::string::size_type prev = 0;    // 按 &amp; 分割多个参数    while ((pos = argumentStr.find(&#x27;&amp;&#x27;, prev)) != std::string::npos)    &#123;        std::string pair = argumentStr.substr(prev, pos - prev);        std::string::size_type equalPos = pair.find(&#x27;=&#x27;);        if (equalPos != std::string::npos)        &#123;            std::string key = pair.substr(0, equalPos);            std::string value = pair.substr(equalPos + 1);            queryParameters_[key] = value;        &#125;        prev = pos + 1;    &#125;    // 处理最后一个参数    std::string lastPair = argumentStr.substr(prev);    std::string::size_type equalPos = lastPair.find(&#x27;=&#x27;);    if (equalPos != std::string::npos)    &#123;        std::string key = lastPair.substr(0, equalPos);        std::string value = lastPair.substr(equalPos + 1);        queryParameters_[key] = value;    &#125;&#125;\n根据上述函数，我们就解析出来了请求行的三个字段，请求方法、url路径、以及Http的版本号。接下来就开始解析请求头了。\n2.请求头解析根据上述分析，请求头是以键值对形式存储的（每一行存储一个键值对），并且键和值的分割是以“：”分割，基于这个分析，请求头就比较好解析了。\n else if (state_ == kExpectHeaders)        &#123;            const char *crlf = buf-&gt;findCRLF();            if (crlf)            &#123;\t            \t//找到&#x27;:&#x27;                const char *colon = std::find(buf-&gt;peek(), crlf, &#x27;:&#x27;);                if (colon &lt; crlf)                &#123;\t                    request_.addHeader(buf-&gt;peek(), colon, crlf);                &#125;                else if (buf-&gt;peek() == crlf)                &#123;                     // 如果找到空行，则结束Header                    // 根据请求方法和Content-Length判断是否需要继续读取body                    if (request_.method() == HttpRequest::kPost ||                         request_.method() == HttpRequest::kPut)                    &#123;\t                        std::string contentLength = request_.getHeader(&quot;Content-Length&quot;);                        if (!contentLength.empty())                        &#123;                            request_.setContentLength(std::stoi(contentLength));                            if (request_.contentLength() &gt; 0)                            &#123;                                state_ = kExpectBody;                            &#125;                            else                            &#123;\t                            \t//如果不用解析请求体，则直接结束                                state_ = kGotAll;                                hasMore = false;                            &#125;                        &#125;                        else                        &#123;                            // POST/PUT 请求没有 Content-Length，是HTTP语法错误                            ok = false;                            hasMore = false;                        &#125;                    &#125;                    else                    &#123;                        // GET/HEAD/DELETE 等方法直接完成（没有请求体）                        state_ = kGotAll;                         hasMore = false;                    &#125;                &#125;                else                &#123;                    ok = false; // Header行格式错误                    hasMore = false;                &#125;                //跳过\\r\\n                buf-&gt;retrieveUntil(crlf + 2); // 开始读指针指向下一行数据            &#125;            else            &#123;                hasMore = false;            &#125;        &#125;void HttpRequest::addHeader(const char *start, const char *colon, const char *end)&#123;\t\t//&#x27;:&#x27;前的值作为key    std::string key(start, colon);    ++colon;    while (colon &lt; end &amp;&amp; isspace(*colon))    &#123;        ++colon;    &#125;    //&#x27;:&#x27;后的值作为value    std::string value(colon, end);    while (!value.empty() &amp;&amp; isspace(value[value.size() - 1])) // 消除尾部空格    &#123;        value.resize(value.size() - 1);    &#125;    //存储key-valua键值对    headers_[key] = value;&#125;\n在找到空行后，需要根据请求方法(判断是否是POST或者PUT方法)和Content-Length判断是否需要继续读取body；如果不需要，则直接退出解析；如果请求体有数据，开始解析请求体。\n3.请求体的解析        else if (state_ == kExpectBody)        &#123;                         // 检查缓冲区中是否有足够的数据            if (buf-&gt;readableBytes() &lt; request_.contentLength())            &#123;                hasMore = false; // 数据不完整，等待更多数据                return true;            &#125;            const std::string &amp;contentType = request_.getHeader(&quot;Content-Type&quot;);            if (contentType.find(&quot;multipart/form-data&quot;) != std::string::npos) //multipart/form-data表示支持多种复制格式的数据上传，如txt文件，mp4,rar等；这也是实现各种数据格式上传文件的解析            &#123;                               ok=parseMultipartData(buf);                request_.set_parseMultipartData_state(ok);                LOG_INFO&lt;&lt;&quot;multipart/form-data解析&quot;&lt;&lt;((ok)?&quot;成功&quot;:&quot;失败&quot;);                state_ = kGotAll;                hasMore = false;            &#125;            else            &#123;            \t//如果只是普通的数据，直接根据contentLength读入到body中即可。                // 只读取 Content-Length 指定的长度                std::string body(buf-&gt;peek(), buf-&gt;peek() + request_.contentLength());                request_.setBody(body);                // 准确移动读指针                buf-&gt;retrieve(request_.contentLength());                state_ = kGotAll;                hasMore = false;            &#125;        &#125;\t\tbool HttpContext::parseMultipartData(Buffer *buf)&#123;    // 1. 找到并跳过第一个 boundary（如 ------WebKitFormBoundaryxxxx）    const char* crlf = buf-&gt;findCRLF();    if (!crlf) return false; // 不完整    std::string boundary(buf-&gt;peek(),crlf);    LOG_INFO&lt;&lt;&quot;boundary:&quot;&lt;&lt;boundary;    buf-&gt;retrieveUntil(crlf + 2);     // // 2. 解析 Content-Disposition 行    crlf = buf-&gt;findCRLF();    if (!crlf) return false; // 不完整    std::string dispositionLine(buf-&gt;peek(), crlf);    buf-&gt;retrieveUntil(crlf + 2);    std::string Content_Disposition;    std::string name;    std::string filename;         size_t Content_Pos = dispositionLine.find(&quot;Content-Disposition:&quot;);    if (Content_Pos != std::string::npos)    &#123;        Content_Pos += 20;        size_t ContentEnd = dispositionLine.find(&#x27;&quot;&#x27;, Content_Pos);        if (ContentEnd != std::string::npos)            Content_Disposition.assign(dispositionLine.data() + Content_Pos, ContentEnd - Content_Pos);    &#125;    LOG_INFO&lt;&lt;&quot;Content_Disposition:&quot;&lt;&lt;Content_Disposition;    size_t namePos = dispositionLine.find(&quot;name=\\&quot;&quot;);    if (namePos != std::string::npos)    &#123;        namePos += 6;        size_t nameEnd = dispositionLine.find(&#x27;&quot;&#x27;, namePos);        if (nameEnd != std::string::npos)            name.assign(dispositionLine.data() + namePos, nameEnd - namePos);    &#125;    LOG_INFO&lt;&lt;&quot;name:&quot;&lt;&lt;name;    size_t filePos = dispositionLine.find(&quot;filename=\\&quot;&quot;);    if (filePos != std::string::npos)    &#123;        filePos += 10;        size_t fileEnd = dispositionLine.find(&#x27;&quot;&#x27;, filePos);        if (fileEnd != std::string::npos)            filename.assign(dispositionLine.data() + filePos, fileEnd - filePos);    &#125;    LOG_INFO&lt;&lt;&quot;filename:&quot;&lt;&lt;filename;     // 3. 跳过 Content-Type 行    crlf = buf-&gt;findCRLF();    if (!crlf) return false;     buf-&gt;retrieveUntil(crlf + 2);    // 4. 跳过空行（说明下一个就是正文）    crlf = buf-&gt;findCRLF();    if (!crlf) return false;    buf-&gt;retrieveUntil(crlf + 2);  // 5. 写入文件，直到遇到下一次 boundary    const char* fileStart = buf-&gt;peek(); // 文件内容起点    const char* fileEnd = std::search(        fileStart, buf-&gt;peek()+ buf-&gt;readableBytes(),        boundary.c_str(), boundary.c_str() + boundary.size()    );    if (fileEnd == buf-&gt;beginWrite()) &#123;    // 未找到结束 boundary，暂时数据不足    return false;    &#125;    LOG_INFO&lt;&lt;&quot;开始创建文件咯&quot;;     request_.set_filename(filename);    if (filename.find(&quot;.avi&quot;)!= std::string::npos ||filename.find(&quot;.mp4&quot;)!= std::string::npos||filename.find(&quot;.mkv&quot;)!= std::string::npos)    &#123;        FileUtil writer(&quot;/root/uploads/videos/&quot; + filename);        writer.writeBinary(fileStart, fileEnd - fileStart);        LOG_INFO&lt;&lt;&quot;这是一个视频&quot;&lt;&lt;filename;    &#125;    else    &#123;        FileUtil writer(&quot;/root/uploads/&quot; + filename);        writer.writeBinary(fileStart, fileEnd - fileStart);    &#125;           LOG_INFO&lt;&lt;&quot;创建完成&quot;;    // 6. 移动 buffer 指针，跳过文件数据和 boundary和\\r\\n    buf-&gt;retrieveUntil(fileEnd+2); // 跳过文件数据    //这里移动了，但是貌似还剩下一点东西，我测试了并没有发现问题，就不管啦！！！    return true;&#125;\n上面的抓包过程中没有文件上传的解析，这里我上传了一个txt文件，并抓包分析。\n上图的红框部分就是我此次上传的txt文件的请求体部分的抓包。以下是分析：\n\n边界值：——WebKitFormBoundaryLkDgzlyaqa0LgduN（细心的同学看到了，在请求体中的最开始部分和结尾部分都是以这个值作为分界线的，而在这直接的就是具体的内容）\nContent-Disposition: form-data; name&#x3D;”file”; filename&#x3D;”test.txt”；form-data表示是一个表单数据；name字段对应表单中的字段名；filename是客户端上传的一个原始文件名。这个字段是用于告知服务器如何处理这部分数据。\nContent-Type: text&#x2F;plain\\r\\n\\r\\n。这个是声明这部分数据的媒体类型。（text&#x2F;plain表示内容是无格式的纯文本）这部分就是实际的传输内容。传输如视频或者压缩文件为01二进制流。所以对于上传不同媒体数据的思想是，通过Content-Disposition中的filename字段，获取原数据的文件名，保存为相应的文件类型，并将实际的内容放到对应的文件中。\n\n视频上传的抓包截图：\n响应报文理论部分HTTP响应报文是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关的数据。一个标准的HTTP响应报文通常包含状态行、响应头、空行、响应体。状态行包含HTTP版本、状态码和状态消息。例如：HTTP&#x2F;1.1 200 OK，404表示没有找到，429表示请求连接过多，我的羡慕中使用令牌桶进行限流的时候，如果某一时候请求连接过多，就返回429状态码响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：● Content-Type：指定响应主体的媒体类型。● Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。● Content-Length：指定响应主体的长度（字节数）。● Expires: 响应的过期时间。● ETag: 响应体的实体标签，用于缓存和条件请求。● Last-Modified： 资源最后被修改的日期和时间。● Location：在重定向时指定新的资源位置。● Set-Cookie：在响应中设置Cookie。\n空行（Empty Line）在响应头和响应体之间，表示响应头的结束。而响应体是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可能为空。\nwireshark抓包分析\n\n状态行返回 HTTP&#x2F;1.1(协议版本)，200（状态码），ok(状态码对于的短语)\n响应头部，也是以键值对形式保存值的。Connection: Keep-Alive（表示这是一个长连接，即可以在这个连接上多次请求与响应）；Access-Control-Allow-Origin: *（支持跨域访问源，这里的‘*’表示所有源都可访问）；Content-Encoding: gzip（表示使用了gzip编码）；Content-Length: 325（这个字段表示响应体的数据大小为325字节）；Content-Type: application&#x2F;json（表示响应体的格式为json）\n响应体可以是多种格式，在这里是json格式，见下图这里的一个json文件中有3个值，filename,uploadtime,username；多个json文件构成了一个Array。\n\n代码实现响应字段是由浏览器解析的，这里我们不需要实现解析的部分。响应是由服务器生成并返回的，所以在这里需要实现HTTP响应报文的生成。请看代码：\n1.设置状态行void HttpResponse::setStatusLine(const std::string&amp; version,                                 HttpStatusCode statusCode,                                 const std::string&amp; statusMessage)&#123;    httpVersion_ = version; //设置HTTP的版本号    statusCode_ = statusCode;//设置响应状态码    statusMessage_ = statusMessage;//设置响应消息&#125;\n\n2.生成响应体void HttpResponse::appendToBuffer(muduo::net::Buffer* outputBuf) const&#123;    // HttpResponse封装的信息格式化输出    char buf[32];     // 为什么不把状态信息放入格式化字符串中，因为状态信息有长有短，不方便定义一个固定大小的内存存储    snprintf(buf, sizeof buf, &quot;%s %d &quot;, httpVersion_.c_str(), statusCode_);        outputBuf-&gt;append(buf);    outputBuf-&gt;append(statusMessage_);    outputBuf-&gt;append(&quot;\\r\\n&quot;);\t\t//是否设置长连接    if (closeConnection_)     &#123;        outputBuf-&gt;append(&quot;Connection: close\\r\\n&quot;);    &#125;    else    &#123;        outputBuf-&gt;append(&quot;Connection: Keep-Alive\\r\\n&quot;);    &#125;    for (const auto&amp; header : headers_)    &#123; // 为什么这里不用格式化字符串？因为key和value的长度不定        outputBuf-&gt;append(header.first);        outputBuf-&gt;append(&quot;: &quot;);         outputBuf-&gt;append(header.second);        outputBuf-&gt;append(&quot;\\r\\n&quot;);    &#125;    outputBuf-&gt;append(&quot;\\r\\n&quot;); //添加空行        outputBuf-&gt;append(body_); //添加响应体&#125;\n格式化响应之后，通过网络发送响应消息，浏览器解析响应并渲染，一次HTTP请求就完成了。\n","categories":["Http后端服务器"],"tags":["网络","后端"]},{"title":"LiteHub之gzip压缩算法","url":"/undefined/LiteHub_gzip/","content":"\n\n理论部分\ngzip是一种无损压缩算法，其基础为Deflate，Deflate是LZ77与哈弗曼编码的一个组合体。它的基本原理是：对于要压缩的文件，首先使用LZ77算法的一个变种进行压缩，对得到的结果再使用哈夫曼编码（根据情况，使用静态哈弗曼编码或动态哈夫曼编码）的方法进行压缩。\n\nLZ777算法几个术语\n\n等待编码区\n搜索缓冲区（已经编码的区域）\n滑动窗口（指定大小，包括“搜索缓冲区”和“待编码区”）\n\n具体的编码过程：接下来，介绍具体的编码过程：　　为了编码待编码区， 编码器在滑动窗口的搜索缓冲区查找直到找到匹配的字符串。匹配字符串的开始字符串与待编码缓冲区的距离称为“偏移值”，匹配字符串的长度称为“匹配长度”。　　编码器在编码时，会一直在搜索区中搜索，直到找到最大匹配字符串，并输出(o, l )，其中o是偏移值， l是匹配长度。然后窗口滑动l，继续开始编码。　　如果没有找到匹配字符串，则输出(0, 0, c)，c为待编码区下一个等待编码的字符，窗口滑动“1”。\n参考文章：LZ77压缩算法编码原理详解(结合图片和简单代码)\n下面我们以字符串“abababc”为例，来了解其编码过程：\n假设滑动窗口的大小足够大(LZ777设置的滑动窗口是32k)，可以覆盖整个字符串。\n第一步：\t&emsp;待编码区：abababc\t&emsp;搜索缓冲区：（初始为空）\t&emsp;操作：搜索缓冲区为空，无法找到匹配字符串。\t&emsp;输出：(0, 0, a)（表示没有找到匹配，输出字符a）\t&emsp;窗口滑动：窗口向右滑动1个字符。\t&emsp;结果：a已经被编码，剩下bababc。第二步：\t&emsp;待编码区：bababc\t&emsp;搜索缓冲区：a（已经编码的部分）\t&emsp;操作：在搜索缓冲区中查找b的匹配。搜索缓冲区中没有b。\t&emsp;输出：(0, 0, b)（表示没有找到匹配，输出字符b）\t&emsp;窗口滑动：窗口向右滑动1个字符。\t&emsp;结果：ab已经被编码，剩下ababc。第三步：\t&emsp;待编码区：ababc\t&emsp;搜索缓冲区：ab（已经编码的部分）\t&emsp;操作：在搜索缓冲区中查找ab的匹配。搜索缓冲区中存在ab，匹配长度为2。\t&emsp;输出：(2, 2)（表示匹配长度为2，偏移值为2）\t&emsp;窗口滑动：窗口向右滑动2个字符。\t&emsp;结果：abab已经被编码，剩下abc。第四步：\t&emsp;待编码区：abc\t&emsp;搜索缓冲区：abab（已经编码的部分）\t&emsp;操作：在搜索缓冲区中查找ab的匹配。搜索缓冲区中存在ab，匹配长度为2。\t&emsp;输出：(4, 2)（表示匹配长度为2，偏移值为4）\t&emsp;窗口滑动：窗口向右滑动2个字符。\t&emsp;结果：ababab已经被编码，剩下c。第五步：\t&emsp;待编码区：c\t&emsp;搜索缓冲区：ababab（已经编码的部分）\t&emsp;操作：在搜索缓冲区中查找c的匹配。搜索缓冲区中没有c。\t&emsp;输出：(0, 0, c)（表示没有找到匹配，输出字符c）\t&emsp;窗口滑动：窗口向右滑动1个字符。\t&emsp;结果：整个字符串已经编码完成。\n最终编码结果&emsp;经过上述步骤，字符串abababc的LZ77编码结果为：\n(0, 0, a) (0, 0, b) (2, 2) (4,2) (0, 0, c)\n使用LZ77压缩算法编码原理详解(结合图片和简单代码)给定的代码的编码结果是说明上述编码过程分析正确！！！\n上面的如(0, 0, a)这个其实根本不用写偏移和匹配长度，保留为原字符‘a’，占的编码长度还更短一些。\n(0, 0, a) (0, 0, b) (2, 2) (4,2) (0, 0, c)\n变为\nab(2, 2) (4,2)c\n霍夫曼编码算法霍夫曼编码是一种基于字符频率的变长编码方法，通过构建霍夫曼树来为每个字符分配一个唯一的二进制编码。霍夫曼树的构建过程依赖于字符的频率，频率越高的字符通常会被分配较短的编码。首先我们统计”abababc“中每一个字符出现的频率，如下所示\n\n\n\na\nb\nc\n\n\n\n3\n3\n1\n\n\n根据霍夫曼编码的规则，我们需要按照字符频率从低到高构建霍夫曼树。以下是构建过程：\n\n将字符串出现的频率视为优先级，放入一个最小优先队列中：\n\n\n\n然后弹出两个优先级最低的字符作为子节点, 构造出第一个二叉树; 父节点的优先级视为两个字节优先级之和, 然后把父节点插入队列中:\n重复这个操作, 最后我们会得到一颗二叉树. 这便是 Huffman编码 树.\n\n4.  我们把这棵树的左支编码为 0, 右支编码为 1, 那么从根节点向下遍历到叶子节点, 即可得出相应字符的 Huffman 编码. 因此我们得到上面例子的 Huffman 编码表为:\na:1b:01c:00\n现在对字符串中出现的频率都做了一个统计，只需要解决偏移量和匹配长度的编码就可以了。\n DEFLATE 算法对偏移距离和匹配长度已经做了一个统计，见下表： 偏移距离： 它有 0 至 29 一共 30 个编码. 距离编码的含义如下表所示: \n\ncode表示基本的编码表示，比如编码9对应的基准距离是25\nextra表示距离基准距离偏移了多少，编码9对应的extra为3位，最大为111（7），即25+7，最大可以表示32。\ndistance，可以表示的距离范围总结：code+extra可以灵活表示distance的任何数字\n\n 匹配长度：对于长度, 它与普通字符共用同一编码空间. 这个编码空间一共有 286 个编码, 范围是从 0 至 285. 其中 0 至 255 为普通字符编码, 256 表示压缩块的结束; 而 257 至 285 则表示长度. 长度编码的含义如下表所示:\n与距离编码类似, 每个编码都表示一个或多个长度, 表示多个长度时后面会有 extra 位指示具体的长度. 长度编码能表示的长度范围为 3 至 258.注意：所以在 DEFLATE 中，长度 12 的重复不会用匹配项表示（直接把这 12 个字节原样输出（即用字面值编码）通常比引用匹配（还要额外编码长度和距离）更短！）；只有长度 ≥ 3 时才会用匹配项 (length, distance) 来引用重复块。解压时, 当读到编码小于等于 255, 则认为这是个普通字符, 原样输出即可; 若在 257 至 285 之间, 则说明遇到了一个重复标记, 这意味着当前编码表示的是长度, 且下一个编码表示的是距离. 解码得到长度和距离, 再在解压缓冲区中找到相应的部分输出即可; 若为 256, 则说明压缩块结束了.\n从LZ777编码到霍夫曼编码上一步的LZ777编码结果为：\nab(2, 2) (4,2)c\n字符串统计频率为：\na:1b:01c:00\n字符编码为：\n101(2, 2) (4,2)00\n然后对偏移距离和匹配长度进行编码但是这里发现匹配字符长度是从3开始的，那么这个2怎么编码呢？原来这里的deflate算法是使用了改进型的LZ777算法参考文章：Gzip 格式和 DEFLATE 压缩算法\n改进型的LZ777算法\nLZ77压缩算法将所有数据都处理成为一个三元组串，每个三元组至少需要3个字节表示，如果在动态字典中未找到匹配字符串，会将1个字节输出为3个字节，这就导致了字节浪费。因此在DEFLATE算法中对其使用的LZ77算法进行了以下改进：\n对匹配字符串长度小于3的字符串不压缩。因为长度小于3的字符串，使用三元组表示，对原始数据不能起到压缩的作用。对字符串的匹配长度进行了限制，范围为（-128~127），用8bit表示，滑动窗口大小为32KB，用15bit表示，将压缩数据构造为标识+数据的形式，具体如表3所示。该存储方式，降低了压缩数据的存储空间。由于只查找匹配长度大于3的字符串，为提高算法速度，在查找匹配字符串时，使用了哈希链结构搜索算法，其中哈希算法将3字节压缩到2字节，虽然哈希链结构存在搜索到错误结果的可能，但还是大幅提高了搜索速度。\n\n所以最终的编码结果为：\na:1b:01c:00\n这里的字符串“abababc”，连续匹配都没有超过三个字符，直接按照这个字符串常量进行编码即可\n10110110100\n\n代码实现压缩对象在开始编写代码前，我们需要弄清楚，需要压缩的对象是什么？\n\n视频、音频、图片等文件本身就是压缩格式mp4、jpg、png、avi、mp3 这些格 已经过复杂压缩算法处理（如 H.264、H.265、JPEG、LZ77 等）。👉 所以再次使用 GZIP 压缩不会有太大效果，反而可能略微增加体积。\nGZIP 对二进制内容的压缩效率很低GZIP 是为文本内容设计的压缩算法（如 HTML、JSON、JavaScript 等）。它依赖数据的可预测性和重复性（如文本中的重复词、空格等）来压缩。视频文件的数据模式看起来是“随机的”，压缩器无法从中找到有效的模式。\n\ngzip实现GzipMiddleware.h代码：\n    GzipMiddleware():clientSupportGzip_(true)&#123;&#125;;    void before(HttpRequest&amp; request) override;    void after(HttpResponse&amp; response) override;    void setClientSupportGzip(bool flag)&#123;clientSupportGzip_=flag;&#125;    bool isClinetSupportGzip() const &#123;return clientSupportGzip_;&#125;    double getGzipEnableRate() const &#123;        uint64_t total = totalRequests_.load();        return total == 0 ? 0.0 : (double)gzipAppliedCount_.load() / total;    &#125;    double getAverageCompressionRatio() const &#123;        uint64_t original = originalSizeSum_.load();        return original == 0 ? 0.0 : (double)compressedSizeSum_.load() / original;    &#125;private:    bool compressGzip(const std::string&amp; input, std::string&amp; output);    bool clientSupportGzip_;      // gzip统计信息    void checkArchive();  // 检查是否需要归档    void resetStats();    // 重置统计信息    std::atomic&lt;uint64_t&gt; totalRequests_&#123;0&#125;;    std::atomic&lt;uint64_t&gt; gzipAppliedCount_&#123;0&#125;;    std::atomic&lt;uint64_t&gt; originalSizeSum_&#123;0&#125;;    std::atomic&lt;uint64_t&gt; compressedSizeSum_&#123;0&#125;;    // std::function&lt;void(uint64_t, uint64_t, uint64_t, uint64_t)&gt; archiveCallback_;    static constexpr uint64_t MAX_REQUESTS_BEFORE_ARCHIVE = 1e9;    static constexpr uint64_t MAX_ORIGINAL_SIZE_BEFORE_ARCHIVE = 1ULL &lt;&lt; 40; // 1 TB\n\nGzipMiddleware.cpp代码：\nvoid GzipMiddleware::before(HttpRequest&amp; request)&#123;       // 从客户端请求头中获取 Accept-Encoding 字段    std::string acceptEncoding=request.getHeader(&quot;Accept-Encoding&quot;);     // 判断是否包含 &quot;gzip&quot; 关键字    // 如果包含，说明客户端支持 gzip 压缩    // 否则，不支持 gzip 压缩，如果不支持，就不进行gzip压缩    acceptEncoding.find(&quot;gzip&quot;) != std::string::npos?setClientSupportGzip(true):setClientSupportGzip(false);&#125;//--------------------------------------// GzipMiddleware::after//--------------------------------------void GzipMiddleware::after(HttpResponse&amp; response) &#123;       // 统计总请求数（用于后续压缩统计归档）    totalRequests_++;    if (!isClinetSupportGzip())     // 如果客户端不支持 gzip，则直接跳过压缩        return;    //判断是否应该压缩，消息体大于256字节并且消息类型是文本、html等类型才可以    //对于视频、图片等已经使用了其他压缩算法进行压缩了的，就不再使用gzip进行压缩了    if (!response.isShouldGzipCompress())         return;    // 获取原始响应体内容    const std::string&amp; rawBody = response.getBody();    std::string compressed;    // 调用实际压缩方法    if (compressGzip(rawBody, compressed)) &#123;        // LOG_INFO&lt;&lt;&quot;gzipAppliedCount_:&quot;&lt;&lt;gzipAppliedCount_.load()&lt;&lt;&quot;originalSizeSum_&quot;&lt;&lt;originalSizeSum_.load()&lt;&lt;&quot;compressedSizeSum_&quot;&lt;&lt;compressedSizeSum_.load();        gzipAppliedCount_++;        originalSizeSum_ += rawBody.size();        compressedSizeSum_ +=compressed.size();        response.addHeader(&quot;Content-Encoding&quot;, &quot;gzip&quot;);  // 添加响应头标识压缩格式为 gzip        response.setContentLength(compressed.size());    // 更新 Content-Length 为压缩后大小        response.setBody(compressed);                    // 设置压缩后的响应体    &#125;    // 检查是否需要归档统计信息    checkArchive();&#125;//--------------------------------------// GzipMiddleware::compressGzip实际的压缩处理算法//--------------------------------------bool GzipMiddleware::compressGzip(const std::string&amp; input, std::string&amp; output)&#123;    constexpr int CHUNK = 16384;     z_stream strm&#123;&#125;;    //zlib 用于压缩的状态结构体，记录输入、输出缓冲区状态等    char out[CHUNK];    //输出缓冲区，用来暂存压缩后的数据块    strm.zalloc = Z_NULL;    strm.zfree = Z_NULL;    strm.opaque = Z_NULL;    if (deflateInit2(&amp;strm,             //压缩状态                     Z_BEST_COMPRESSION, //压缩等级（0~9），9 表示最高压缩比，牺牲性能                     Z_DEFLATED,         //使用 DEFLATE 算法                     15 + 16,           //15位窗口大小(32KB), +16启用 GZIP 格式输出（否则是 zlib）                     8,                 //内部压缩缓冲区大小参数，一般为 8                     Z_DEFAULT_STRATEGY) != Z_OK) //默认压缩策略    &#123;        return false;    &#125;    strm.avail_in = input.size();          // 待压缩数据长度    strm.next_in = (Bytef*)input.data();   // 待压缩数据    do &#123;        strm.avail_out = CHUNK;            //待压缩数据存储buffer 的长度，如果多次写，会覆盖之前的写的数据                                            //当然，之前的数据已经被读走了        strm.next_out = reinterpret_cast&lt;Bytef*&gt;(out); //待压缩数据存储的buffer        deflate(&amp;strm, Z_FINISH);            //如果输入和待输出的数据都被处理完，则返回 Z_STREAM_END        size_t have = CHUNK - strm.avail_out;//总长度-当前可写=已经写的数据长度        output.append(out, have);    &#125; while (strm.avail_out == 0);    deflateEnd(&amp;strm);                       //释放deflateInit2申请的空间    LOG_INFO&lt;&lt;&quot;原始的数据大小为:&quot;&lt;&lt; input.size();    LOG_INFO&lt;&lt;&quot;GZIP压缩完成,压缩比例为:&quot;&lt;&lt;(static_cast&lt;double&gt;(output.size()) / input.size());;    return true;&#125;void GzipMiddleware::checkArchive() &#123;    // 如果压缩的总请求数或原始数据累计大小超过阈值    // 就清理统计数据（可用于后续监控、日志）    if (totalRequests_ &gt;= MAX_REQUESTS_BEFORE_ARCHIVE ||        originalSizeSum_ &gt;= MAX_ORIGINAL_SIZE_BEFORE_ARCHIVE) &#123;        totalRequests_ = 0;        gzipAppliedCount_ = 0;        originalSizeSum_ = 0;        compressedSizeSum_ = 0;    &#125;&#125;\n实现的函数有：\n\nbefore()函数，判断请求是否支持gzip压缩\nafter()函数，统计请求，如果客户端不支持gzip压缩就返回；否则对其进行gzip压缩并填充响应体部分\ncompressGzip()函数，实际的压缩处理核心部分\ncheckArchive()函数，用于统计压缩的情况，如平均压缩率等\n\n本代码实现gzip的核心部分就是在compressGzip函数中进行了实际的压缩，compressGzip调用了deflate函数进行实际的压缩。关于deflate函数的介绍，可以参考深入理解数据压缩流程及 zlib 库中相关函数\n运行分析运行服务器，查看gzip压缩是否启用成功，有三个地方可以查看gzip的压缩启用是否成功。分别是日志系统、wireshark抓包分析、LiteHub前端展示。\n日志查看这个压缩比例计算方式是：压缩后的数据大小除以压缩前的数据大小。可以看到gzip是有效压缩成功了的。\nwireshark抓包查看首先看客户端发起的每一次请求都会携带Accept-Encoding:字段，该字段中携带了 gzip, deflate表示支持gzip压缩方式。\n这个报文是从服务器发回的响应报文，客户端收到压缩后的信息包后自动解压，从2380字节解压到原来的9182字节，这也进一步说明了设计的gzip压缩算法是有效的。\n后台管理界面查看此外，在LiteHub前端界面，也是可以通过管理员账户查看具体的gzip的一个压缩信息的。关于gzip的理解就分析到这了，如果有不恰当之前，请您指出。\n","categories":["Http后端服务器"],"tags":["网络","后端","中间件"]},{"title":"LiteHub之会话管理","url":"/undefined/LiteHub_session/","content":"\n\n\n\n会话管理理论为什么进行会话管理HTTP协议的特性与局限性Web应用程序的基础是HTTP（Hypertext Transfer Protocol）协议，该协议在设计时具有以下核心特点：\n\n请求&#x2F;响应模式：\n\n每次HTTP交互都遵循”客户端发起请求→服务器返回响应”的固定模式\n例如：用户访问电商网站时，点击商品页、加入购物车、结算等都是独立的请求\n各请求之间没有内在关联，服务器无法自动识别这些请求是否来自同一用户\n\n\n无状态性（Stateless）：\n\n协议本身不保存任何历史交互信息\n每个请求都被视为全新的交互，服务器不会”记住”之前的请求\n实际案例：刷新网页后，登录状态、表单填写内容等都将丢失\n\n\n无连接特性：\n\n每次TCP连接只处理一个请求&#x2F;响应\n请求完成后立即断开连接以节省资源\n导致的问题：无法维持长期对话，如在线聊天、多步骤表单等场景难以实现\n\n\n\n现实应用的需求矛盾虽然HTTP的这些特性使其简单高效，但现代Web应用需要：\n\n用户登录状态保持（如保持7天免登录）\n购物车商品跨页面保存\n多步骤表单数据暂存\n个性化内容推荐（基于历史浏览）\n\n因此需要引入会话管理机制来：\n\n识别同一用户的连续请求\n在服务器端存储用户特定数据\n维持应用的状态连续性\n\n常见解决方案包括：\n\nCookie技术\nSession会话\nToken令牌（如JWT）\nURL重写技术\n\n在这个项目中，我们使用的就是Session会话和Cookie技术结合使用来记录用户登录状态。\n什么是Session\n服务器为每个用户浏览器创建一个会话对象（session对象），一个浏览器只能产生一个session\n当新建一个窗口访问服务器时，还是原来的那个session。session中默认保存的是当前用户的信息。因此，在需要保存其他用户数据时，我们可以自己给session添加属性。\nsession（会话）可以看为是一种标识，通过带session的请求，可以让服务器知道是谁在请求数据。\n\nSession与cookie的区别与联系\nsession是由服务器创建的，并保存在服务器上的。在session创建好之后，会把sessionId（会话的唯一标识符）放在cookie中返回（response）给客户端。客户端将cookie是保存在客户端的。\n以后的每次请求都携带cookie，cookie中的内容是sessionId值。\nsession的过期和超时与cookie的过期无直接联系，都是可以分别进行设置的。当session或cookie中任意一方过期，那么用户就需要重新登录了\n\n注意：虽然 Cookie 是最主流的方式，但如果用户禁用 Cookie，服务器还可以通过其他方式传递 Session ID：URL 重写： 将 Session ID 作为查询参数附加到每个 URL 后面 (如 ?sessionid&#x3D;abc123xyz)。这种方式不太安全（容易泄露）且不美观。隐藏表单域： 将 Session ID 放在 HTML 表单的隐藏字段中。仅适用于表单提交。\n所以sessionid和cookie的更准确描述是：Session 机制通常利用 Cookie 用于在客户端存储和传递标识服务器端 Session 数据的 Session ID。Cookie 是 Session ID 的载体，而非 Session 生成了 Cookie。 服务器端的 Session 管理代码负责生成 Session ID 并指示浏览器（通过 Set-Cookie）存储它。\n第六章 会话管理（Session）\n会话管理代码实现会话管理中共实现了四个类实现：\n\nSession(会话)：表示一个会话。\nSessionManager(会话管理器)：用于管理多个会话的声明周期。\nSessionStorage(会话存储)：会话存储实现的抽象类。\nMemorySessionStorage(内存会话存储)：继承SessionStorage，具体的会话存储实现类。\n\nSession类实现\nSession 构造函数，用于初始化会话实例，记录 sessionId、设置最长有效时间（默认值为 1 小时）并关联会话管理器。\nisExpired（），判断当前会话是否过期\nrefresh（），刷新过期时间，当前时间加上最长有效时间（默认为一小时）\nsetValue（），以键值对形式存储会话数据\ngetValue（），根据传入key获取相应的会话数据（value）\nremove(),根据传入key删除相应的会话数据（value）\nclear()，清空所有会话数据\n\n 总结，session类实现了记录会话唯一标识符，维持会话过期时间，更新会话数据功能。\nSessionManager类实现\nSessionManager 构造函数，用于配置会话存储对象（负责会话存储）和随机数生成器（用于生成随机的会话ID）\ngetSession（）函数会从请求中提取cookie字段以获取sessionid，并返回相应的会话；若cookie不存在或者会话已过期，则创建一个新会话。\ngenerateSessionId（），生成一个唯一的会话标识符\ndestroySession（），从存储中移除会话\ngetSessionIdFromCookie（），从请求中的cookie字段获取sessionId\nsetSessionCookie（），在响应中设置cookie\n\n这几个函数比较重要，放这里注释一下，便于理解\n//从req请求中解析出sessionIdstd::string SessionManager::getSessionIdFromCookie(const HttpRequest&amp; req)&#123;    std::string sessionId;    std::string cookie = req.getHeader(&quot;Cookie&quot;);//找到Cookie字段    if (!cookie.empty())    &#123;\t    \t//格式一般为    \t//Cookie: sessionId=1dd3ce798f86bf092595840ac8ecadc8\\r\\n        size_t pos = cookie.find(&quot;sessionId=&quot;);        if (pos != std::string::npos)        &#123;            pos += 10; // 跳过&quot;sessionId=&quot;            size_t end = cookie.find(&#x27;;&#x27;, pos);            if (end != std::string::npos)            &#123;                sessionId = cookie.substr(pos, end - pos);            &#125;            else            &#123;\t            \t//从pos开始截取到字符串结束                sessionId = cookie.substr(pos);            &#125;        &#125;    &#125;        return sessionId;&#125;// 生成唯一的会话标识符，确保会话的唯一性和安全性std::string SessionManager::generateSessionId()&#123;    std::stringstream ss;    std::uniform_int_distribution&lt;&gt; dist(0, 15);    // 生成32个字符的会话ID，每个字符是一个十六进制数字    for (int i = 0; i &lt; 32; ++i)    &#123;        ss &lt;&lt; std::hex &lt;&lt; dist(rng_);//生成一个0~15之间的随机数    &#125;    return ss.str();&#125;//在响应中添加cookie字段void SessionManager::setSessionCookie(const std::string&amp; sessionId, HttpResponse* resp)&#123;    // 设置会话ID到响应头中，作为Cookie    std::string cookie = &quot;sessionId=&quot; + sessionId + &quot;; Path=/; HttpOnly&quot;;    resp-&gt;addHeader(&quot;Set-Cookie&quot;, cookie);&#125;std::shared_ptr&lt;Session&gt; SessionManager::getSession(const HttpRequest&amp; req, HttpResponse* resp)&#123;   \t//从请求中的cookie字段中取出sessionid    std::string sessionId = getSessionIdFromCookie(req);        std::shared_ptr&lt;Session&gt; session;\t    if (!sessionId.empty())//如果sessionId存在    &#123;        session = storage_-&gt;load(sessionId); //根据sessionId获取对应会话    &#125;    if (!session || session-&gt;isExpired())//如果sesseion不存在或者说session过期，重新创建一个    &#123;        sessionId = generateSessionId();//生成唯一的sessionId        session = std::make_shared&lt;Session&gt;(sessionId, this);//传入sessionid和SessionManager构建一个会话        setSessionCookie(sessionId, resp);//在响应resp中setCookie中添加sessionId    &#125;    else     &#123;        session-&gt;setManager(this); // 为现有会话设置管理器    &#125;    session-&gt;refresh();\t//刷新会话的过期时间，因为当前有新的访问，过期时间需要重新被设置    storage_-&gt;save(session);  // 保存会话    return session;&#125;\nMemorySessionStorage类实现SessionStorage定义了抽象类提供了save()、load()、remove()接口，而MemorySessionStorage对重写了这些函数。MemorySessionStorage是以&lt;std::string, std::shared_ptr&lt;Session&gt;&gt;构造的无序键值对保存的。\n\nsave()函数，保存会话\nload()函数，根据sessionId找到对应的会话，如果会话过期则删除会话；否则返回会话\nremove()函数，通过sessionId删除会话\n\n会话管理抓包分析1.首次访问网页此时还没登录（此时还不需要维护用户的登录状态），这时的请求中还没有cookie字段。这是发起的请求是为了请求网页，服务器返回的响应，可以看到，此时服务器也没有set-cookie字段；此时服务器返回前端渲染需要的网页（响应体中）\n2.点击登录时这时可以看到请求的报文，是以POST方式将用户登录的username和password上传到服务器（这里是明文传输，这是HTTP的缺点，在网络传输中容易被抓包导致密码和账户泄露；后面这个项目看能不能扩展成HTTPS协议）\n3.服务器处理此时通过点击登录按钮，将登录请求发送到服务器，服务器根据相应的路由，转发到专门用于登录处理的函数中\n// 根据账号密码，查找数据库是否有该账号密码int LoginHandler::queryUserId(const std::string &amp;username, const std::string &amp;password)&#123;    // 前端用户传来账号密码，查找数据库是否有该账号密码    // 使用预处理语句, 防止sql注入    std::string sql = &quot;SELECT id FROM users WHERE username = ? AND password = ?&quot;;    sql::ResultSet* res = mysqlUtil_.executeQuery(sql, username, password);    if (res-&gt;next())    &#123;        int id = res-&gt;getInt(&quot;id&quot;);        return id;    &#125;    // 如果查询结果为空，则返回-1    return -1;&#125;void LoginHandler::handle(const http::HttpRequest &amp;req, http::HttpResponse *resp)&#123;    // ...其他代码        // JSON 解析使用 try catch 捕获异常    try    &#123;        json parsed = json::parse(req.getBody());        std::string username = parsed[&quot;username&quot;];        std::string password = parsed[&quot;password&quot;]; //从请求体中解析得到username 和password         // 验证用户是否存在，是否注册过        int userId = queryUserId(username, password);        if (userId != -1)        &#123;            // 获取会话            auto session = server_-&gt;getSessionManager()-&gt;getSession(req, resp);                                 // 在会话中存储用户信息            session-&gt;setValue(&quot;userId&quot;, std::to_string(userId));            session-&gt;setValue(&quot;username&quot;, username);            session-&gt;setValue(&quot;isLoggedIn&quot;, &quot;true&quot;);\t\t\t\t\t\t//其他代码        &#125;        else // 账号密码错误，请重新登录        &#123;            // 封装json数据，返回401未认证状态码            return;        &#125;    &#125;    catch (const std::exception &amp;e)    &#123;       \t//...其他代码，返回错误信息        return;    &#125;&#125;\n上述代码中的 server_-&gt;getSessionManager()-&gt;getSession(req, resp)负责返回会话，或者新建会话，具体为：\n\n如果当前用户存在会话并且会话有效，则直接返回会话\n否则创建新的会话（这里是首次登录，所以默认就是这种情况）\n\n 并在会话中存储如&quot;userId&quot;，&quot;username&quot;，&quot;isLoggedIn&quot;字段。\n4.服务器返回响应在getSession(req, resp)—&gt;&gt;&gt;setSessionCookie(sessionId, resp);设置响应报文\nvoid SessionManager::setSessionCookie(const std::string&amp; sessionId, HttpResponse* resp)&#123;    // 设置会话ID到响应头中，作为Cookie    std::string cookie = &quot;sessionId=&quot; + sessionId + &quot;; Path=/; HttpOnly&quot;;    resp-&gt;addHeader(&quot;Set-Cookie&quot;, cookie);&#125;\n服务器响应设置了cookie字段，以后的客户端的每次请求都将携带这个字段。\n5.客户端的下一次请求从上图可知，设置cookie之后的每一次请求，都会带上cookie这个字段。\n","categories":["Http后端服务器"],"tags":["网络","后端"]},{"title":"C++指针的深入解析","url":"/undefined/cpp_pointer/","content":"\n\n指针的概念\n指针是一种特殊的数据类型，用于存储变量的内存地址而非直接存储值。通过指针可以间接访问或操作内存中的数据，常用于动态内存分配、数组操作和函数参数传递等场景。\nint var = 10;     // 定义整型变量int *ptr = &amp;var;  // 指针ptr存储var的地址\n动态内存管理：通过指针可以在程序运行时动态分配或释放内存（如malloc和free）。  \nint *arr = (int*)malloc(5 * sizeof(int)); // 动态分配数组free(arr);                                // 释放内存\n\n高效数据传递：函数参数传递指针可避免数据复制，提升性能。如下面代码所示\nvoid modify(int *x) &#123; *x = 20; &#125;int main() &#123;    int a = 10;    modify(&amp;a); // a的值被改为20&#125;\nTips:未初始化的指针可能指向非法内存，导致崩溃。指针的字节固定为4字节或者8字节（根据操作系统确定）。如int是4字节，char 是1字节，double是8字节；但是对于指针来说char *，和int *，double *都是4字节。\n#include &lt;iostream&gt;using namespace std;class A&#123;\tint ma_;\tint mb_;\tint mc_;&#125;;int main()&#123;\tcout &lt;&lt; &quot;sizeof(char)   :&quot; &lt;&lt; sizeof(char) &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof(int)    :&quot; &lt;&lt; sizeof(int) &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof(double) :&quot; &lt;&lt; sizeof(double) &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof(class A):&quot; &lt;&lt; sizeof(A) &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof(char *) :&quot; &lt;&lt; sizeof(char *) &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof(int *)  :&quot; &lt;&lt; sizeof(int *) &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof(double*):&quot; &lt;&lt; sizeof(double*) &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof(class A *) :&quot; &lt;&lt; sizeof(A *) &lt;&lt; endl;\treturn 0;&#125;\n打印的结果为：其实也很好理解，指针本质是内存的地址，对于32位系统来说，指针的长度为4字节；对于64位系统来说，指针的长度为8字节。\nconst关键字const是C&#x2F;C++语言中的一个重要关键字，用于定义常量，表示该变量的值在程序运行期间不能被修改。const关键字可以应用于变量、函数参数、函数返回值以及成员函数。\nconst特点：\n\n不可变性：const变量的值一旦初始化后就不能再被修改(定义时初始化)\n编译期检查：编译器会在编译时检查对const变量的修改操作，并报错\n类型安全：const提供了额外的类型安全保证\n\n以下是const使用过程中可能出现的错误：1.const常量不能再作为左值,（不然会直接修改常量的值）,如:\nconst int a=10;a=20;//尝试直接修改常量，错误\n2.不能把常量的地址泄露给一个普通的指针或者引用变量（不然会间接的修改常量的值）,只能传给const类型的指针或变量\nconst int a=10;int *p=&amp;a;//这样可以间接通过指针解引用方法修改内存a的值。*p=20;//正确的定义方式为 const int *p=&amp;a;\n\n判断const修改的类型C++中const修饰符的规则如下：const修饰的是与其最近的表达式（需先去除类型说明符如int、int*）并且遵循最少原则：在int*和int之间优先选择int。去除类型说明符后的表达式即表示该部分不可修改。\nconst和一级指针常量指针见代码：\nint a=10;int b=100;const int *p=&amp;a;int const *p=&amp;a; //与上一行等效，const与int的位置互换不影响含义//这里去掉最近的类型，即 int ,const修饰的是*p，表示*p不能被修改。*p=20; //错误：试图修改常量指针指向的内容p=&amp;b; //正确：可以改变指针的指向\n该指针可以指向不同的int类型的内存地址，但不能通过指针间接修改所指向内存的值。\n指针常量代码如下\nint a=10;int b=100;int * const p=&amp;a; //const最近且满足最少原则的类型应该是int *,则其修饰的表达是为 p,表示p不能被修改//指针p是常量，不能再指向其他内存，但是可以通过指针解引用修改指向内存的值p=&amp;b； //错误*p=20; //正确\nconst修饰失效注意：当const 右边没有指针符号*时，const不参与类型定义。\nint * q1=nullptr;int *const q2=nullptr;int const *q3=nullptr;//这里q1和q2的类型都是 int *; q3的类型是int const *;\n\n\nconst和二级指针的组合指向常量的二级指针int x = 10;const int* p = &amp;x;const int** pp = &amp;p;// *pp = &amp;y; // 合法// **pp = 20; // 非法，x是常量\n\n表示指向一个指向常量的指针的指针\n可以通过二级指针修改一级指针的指向,可以修改二级指针\n但不能修改最终指向的值\n\n指向指针常量的二级指针int x = 10;int* const p = &amp;x;int* const* pp = &amp;p;// *pp = &amp;y; // 非法，p是常量指针// **pp = 20; // 合法，x可以被修改\n\n表示指向一个指针常量的指针\n不能通过二级指针修改一级指针的指向\n但可以修改一级指针指向的值，可以修改二级指针\n\n二级指针常量int x = 10;int* p = &amp;x;int** const pp = &amp;p;// pp = &amp;q; // 非法，pp是常量// *pp = &amp;y; // 合法，修改p的指向// **pp = 20; // 合法，修改x的值\n\n表示二级指针本身是常量\n不能修改二级指针的指向\n但可以修改一级指针的指向及其指向的值\n\n完全常量二级指针const int* const* pp;\n\n表示指向一个指向常量的指针常量的指针\n既不能修改一级指针的指向，也不能修改最终指向的值\n\n总结 const 和 指针的类型转换公式在C++中，指针和const的组合使用需要注意类型转换的规则。以下是总结的一些转换方式：\n一级指针转换int * &lt;&lt;&lt;=== const int *  ;//是错误的!!!// 不能将const指针赋值给非const指针，这会导致const保护失效const int * &lt;&lt;&lt;=== int *;  //是正确的!!!// 可以将非const指针赋值给const指针，这是安全的类型降级// 例如：int a = 10;int *pa = &amp;a;const int *cpa = pa; // 合法转换\n\n二级指针转换int ** &lt;&lt;&lt;=== const int **; //是错误的!!!const int **&lt;&lt;&lt;=== int **; //是错误的!!!//在二级指针甚至多级指针中，两边都要有const 才算正确；int ** &lt;&lt;&lt;===int * const *;//是错误的!!!//前面说到，const只负责其右边的类型构造，上面可以简化为int * &lt;&lt;&lt;===int  const *; //判断为错误int *const *&lt;&lt;&lt;=== int **;  //是正确的!!!//简化为 int const *&lt;&lt;&lt;=== int *; \n\n以下是一些转换的错误样例\n错误样例int a=10;const int *p=&amp;a;int *q=p;//这里 int *&lt;&lt;&lt;===const int *,不匹配\n\nint a=10;int *p=&amp;a;const int **q=&amp;p; //const int ** &lt;&lt;&lt;=== int  **,不匹配，&amp;p取地址加一个*\n\nint a=10;int *const p=&amp;a;  //p为int *,const 只在其右边有指针时起作用；int **q=&amp;p;//因为这有一个取地址操作，则 int ** &lt;&lt;&lt;===int *const *,不匹配\n\nint a=10;const int *p=&amp;a;int *const*q =&amp;p; //int *const *&lt;&lt;&lt;===const int **,左边是const 与一级指针结合，右边是const 与二级指针结合，不匹配（我是这么理解的，不知道有没有更好的解释）\n指针与数组结合数组指针//数组类型的指针//指针有各种类型 ，int *,float *//将数组当作一种数据类型，定义一个指向数组的指针int a=10;int *pa=&amp;pa;int arr=&#123;1,2,3&#125;;int (*pa) []=&amp;arr;//表明这是一个指针，并且指向一个数组，这个数组中的类型是int 类型\n\n指针数组int a=10,b=20,c=30;int *arr[]=&#123;&amp;a,&amp;b,&amp;c&#125;;//arr先与[]结合，表示这是一个数组，并且这个数组的类型是int *\n指针与函数结合函数指针//是一个指针，指向一个函数，函数返回类型是int 型int (*fun) (int x);\n\n指针函数int *fun (int x)//fun先与()结合，表示这是一个函数，返回类型为int *;","categories":["cppr容器"],"tags":["c++"]},{"title":"文件系统的理解","url":"/undefined/disk/","content":"","categories":["note"],"tags":["随笔"]},{"title":"STL空间配置器的理解","url":"/undefined/stl_allocator/","content":"\n\n\n这里以自定义的vector类为例，谈谈为什么需要空间配置器。\n自定义实现一个简单的vector这里定义了三个成员变量，分别是_first（vector起始地址），_last（vector实际存放的末尾元素地址），_end（vector开辟的空间地址）。使用模板类封装实现了vector，实现了以下函数：\n\nvector构造函数，使用new开辟内存+构造对象\n析构函数，使用delete删除内存\n拷贝构造函数\n赋值构造函数\npush_back（）函数，从vector最后插入\npop_back（）函数，从vector最后弹出\nback()，获取末尾元素\nempty（）,判断是否为空\nfull（）,判断是否满\nsize（）,获取元素大小\n\ntemplate&lt;typename T&gt;class vector&#123;public:\tvector(int size = 5)\t&#123;\t\t_first = new T[size];\t\t_last = _first;\t\t_end = _first + size;\t&#125;\t~vector()\t&#123;\t\tdelete[]_first;\t\t_first = _last = _end = nullptr;\t&#125;\tvector(const vector&lt;T&gt;&amp; cp)//拷贝构造函数\t&#123;\t\tint size = cp._end - cp._first;\t\t_first = new T[size];\t\tint len = cp._last - cp._first;\t\tfor (int i = 0; i &lt; len; i++)//这里是深拷贝\t\t&#123;\t\t\t_first[i] = cp._first[i];\t\t&#125;\t\t_last = _first + len;\t\t_end = _first + size;\t&#125;\tvector&lt;T&gt;&amp; operator=(const vector&lt;T&gt;&amp; cp) //赋值构造函数\t&#123;\t\t\t//1.防止自赋值\t\tif (this == &amp;cp)\t\t\treturn*this;\t\t//2.删除原有空间\t\tdelete[]_first;\t\t\t\t//创建新的空间并执行深拷贝\t\tint size = cp._end - cp._first;\t\t_first = new T[size];\t\tint len = cp._last - cp._first;\t\tfor (int i = 0; i &lt; len; i++)\t\t&#123;\t\t\t_first[i] = cp._first[i];\t\t&#125;\t\t_last = _first + len;\t\t_end = _first + size;\t\treturn *this;\t&#125;\tvoid push_back(const T&amp; val)\t&#123;\t\t//如果空间满了，则扩容\t\tif (full())\t\t\texpand();\t\t*_last++ = val;\t&#125;\tvoid pop_back()\t&#123;\t\t\t//判断是否还有值\t\tif (empty())\t\t\treturn;\t\t--_last;\t&#125;\tT back() const\t&#123;\t\t\t//返回最后一个元素\t\tif (empty())\t\t\tthrow &quot;stack is empty&quot;; //抛出异常\t\treturn *(_last - 1);\t&#125;\tbool empty() const&#123; return _first == _last;\t&#125; //判断是否为空\tbool full() const &#123; return _last == _end;&#125;  //判断是否已满\tint size() const &#123; return _last - _first; &#125;//计算实际存储的数据大小private:\tT* _first; //指向数组起始的位置\tT* _last;  //指向数组中有效元素的后继位置\tT* _end;  //指向数组的结尾\tvoid expand() //扩容操作\t&#123;\t\t\t//1.重新构造\t\tint size = _end - _first;\t\tT* ptmp = new T[2 * size];\t\t//2.深拷贝\t\tfor (int i = 0; i &lt; size; i++)\t\t&#123;\t\t\tptmp[i] = _first[i];\t\t&#125;\t\t//3.删除原来的内存空间\t\tdelete[]_first;\t\t\t\t\t\t_first = ptmp;\t\t_last = _first + size;\t\t_end = _first + 2 * size;\t&#125;&#125;;\n可以实现vector简单的插入、弹出、扩容等操作。运行下面的代码，\nclass Test&#123;public:\tTest() &#123; cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl; &#125;\t~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125;\tTest(const Test&amp;)\t&#123;\t\tcout &lt;&lt; &quot;拷贝构造&quot; &lt;&lt; endl;\t&#125;\tTest&amp; operator= (const Test&amp; cp)\t&#123;\t\tcout &lt;&lt; &quot;赋值构造&quot; &lt;&lt; endl;\t\treturn *this;\t&#125;&#125;;int main()&#123;\tTest t1, t2, t3; //调用赋值构造函数，打印Test();\tvector&lt;Test&gt; vec;//创建一个大小为size的空间，这里默认为5，并且这里会调用默认vector构造函数构造对象\tcout &lt;&lt; vec.size() &lt;&lt; endl; //理论上的有效空间为0，但这里已经有数据了；\tvec.push_back(t1);         //这里调用的是打印的是赋值构造函数，该处原来有值（定义的时候生成的空对象）\tvec.push_back(t2);\tvec.push_back(t3);\tcout &lt;&lt; vec.size() &lt;&lt; endl; //有效空间为3\tvec.pop_back(); //调用析构函数\tcout &lt;&lt; vec.size() &lt;&lt; endl; //有效空间为2\treturn 0;&#125;\n存在以下问题：1.在初始化的时候，开辟内存和对象构造是一起执行的；但是有些时候我只是为了声明变量（如vector&lt;Test&gt; vec,在这里只是为了声明定义以Test类的vec数组，但是上图是开辟内存+构造对象），这样就会带来没必要的开销（声明时构造对象，出作用域时析构对象）；2.上述实现的vector的pop_back是采用的指针回退策略，但如果该指针指向的test对象指向了外部资源，单纯的指针回退会导致这一部分资源无法管理，导致空间泄露\nclass Test&#123;public:\tTest()\t &#123;\t \t_ps=new int[5];\t &#125;\t~Test() \t&#123; \t\tdelete []_ps;\t\t_ps=nullptr;\t&#125;\tprivate:\tint *_ps;&#125;;\n这里定义的Test类中是指向了外部对象的（_ps=new int[5];），如果仅仅是指针回退，而不析构对应的对象的话，会造成管理的内存资源泄露。\n空间配置器实现所以很自然的就是想到，将内存的开辟和对象的构造分开；内存的释放和对象的析构分开。而空间配置器就是为了实现这样的功能，具体为，空间配置器实现了几个比较重要的函数：\n\nallocate（），负责内存的开辟\ndeallocate（），负责内存的释放\nconstruct（），负责对象的构造\ndestroy（），负责对象的析构\n\n具体代码如下：\n//容器的空间配置其allocator 做四件事情  //内存开辟/内存释放  对象构造/对象析构template &lt;typename T&gt;struct Allocator&#123;\tT* allocate(size_t size) //负责内存开辟\t&#123;\t\treturn (T*)malloc(sizeof(T) * size);\t&#125;\tvoid deallocate(void* p)  //负责内存释放\t&#123;\t\tfree(p);\t&#125;\tvoid construct(T* p, const T&amp; val) //负责对象构造\t&#123;\t\tnew (p) T(val); //采用定位new的方式\t&#125;\tvoid destroy(T* p) //负责对象析构\t&#123;\t\tp-&gt;~T();    //~T()代表了T类型的析构函数\t&#125;&#125;;\n这样做的好处有，在声明对象的时候只是开辟内存空间，而不进行无意义的默认对象构造；并且在删除资源的时候，先执行对象的析构函数，确保对象指向的外部资源被释放后，才清除当前堆内存，步骤如下。\n实现空间配置器后的vector/** 容器底层的内存开辟、内存释放，对象构造和析构,都通过allocator空间配置器来实现*/template&lt;typename T,typename Alloc = Allocator&lt;T&gt;&gt;class vector&#123;public:\tvector(int size = 10)\t&#123;\t\t\t//只开辟内存空间\t\t_first = _allocator.allocate(size);\t\t_last = _first;\t\t_end = _first + size;\t&#125;\t~vector()\t&#123;\t\t//先析构容器有效元素\t\tfor (T* p = _first; p != _last; ++p)\t\t&#123;\t\t\t_allocator.destroy(p); //把内存中的有效元素进行析构操作\t\t&#125;\t\t//然后释放_first指向的堆内存\t\t_allocator.deallocate(_first); \t\t_first = _last = _end = nullptr;\t&#125;\tvector(const vector&lt;T&gt;&amp; cp)\t&#123;\t\tint size = cp._end - cp._first;\t\t//分配堆内存\t\t_first = _allocator.allocate(size);\t\tint len = cp._last - cp._first;\t\tfor (int i = 0; i &lt; len; i++)\t\t&#123;\t\t\t//逐个根据cp的值构造对象\t\t\t_allocator.construct(_first + i, cp._first[i]);\t\t&#125;\t\t_last = _first + len;\t\t_end = _first + size;\t&#125;\tvector&lt;T&gt;&amp; operator=(const vector&lt;T&gt;&amp; cp)\t&#123;\t\tif (this == &amp;cp)\t\t\treturn*this;\t\t//把内存中的对象进行析构操作\t\tfor (T* p = _first; p != _last; ++p)\t\t&#123;\t\t\t_allocator.destroy(p); \t\t&#125;\t\t//释放原来堆上的内存\t\t_allocator.deallocate(_first); \t\tint size = cp._end - cp._first;\t\t//申请新的内存空间\t\t_first = _allocator.allocate(size);\t\tint len = cp._last - cp._first;\t\tfor (int i = 0; i &lt; len; i++)\t\t&#123;\t\t\t//逐个根据cp的值构造对象\t\t\t_allocator.construct(_first + i, cp._first[i]);\t\t&#125;\t\t_last = _first + len;\t\t_end = _first + size;\t\treturn *this;\t&#125;\tvoid push_back(const T&amp; val)\t&#123;\t\tif (full())\t\t\texpand();\t\t//根据val的值在_last位置上构造对象\t\t_allocator.construct(_last, val);\t\t_last++;\t&#125;\tvoid pop_back()\t&#123;\t\tif (empty())\t\t\treturn;\t\t//析构_last位置上的对象\t\t--_last;\t\t_allocator.destroy(_last);\t\t\t&#125;\tT back() const\t&#123;\t\tif (empty())\t\t\tthrow &quot;stack is empty&quot;; //抛出异常\t\treturn *(_last - 1);\t&#125;\tT&amp; operator [] (int index)\t&#123;\t\tif (index &lt; 0 || index &gt;= size())\t\t\tthrow &quot;index out of range Exception&quot;;\t\treturn _first[index];\t&#125;\tbool empty() const &#123; return _first == _last; &#125;\tbool full() const &#123; return _last == _end; &#125;\tint size() const &#123; return _last - _first; &#125;private:\tT* _first; //指向数组起始的位置\tT* _last;  //指向数组中有效元素的后继位置\tT* _end;  //指向数组的结尾\tAlloc _allocator; //定义容器的空间配置器对象\tvoid expand()\t&#123;\t\tint size = _end - _first;\t\t//分配原来2倍大小的内存空间\t\tT* ptmp = _allocator.allocate(2 * size);\t\tfor (int i = 0; i &lt; size; i++)\t\t&#123;\t\t\t//逐个根据_first[i]的值构造对象\t\t\t_allocator.construct(ptmp+i, _first[i]);\t\t\t//逐个析构_first+i对象\t\t\t_allocator.destroy(_first+i);\t\t&#125;\t\t//删除原有堆内存空间\t\t_allocator.deallocate(_first);\t\t_first = ptmp;\t\t_last = _first + size;\t\t_end = _first + 2 * size;\t&#125;&#125;;\n\n从上图可以看到，实现了自定义的空间配置器之后，在定义vector&lt;Test&gt; vec; 时就不会出现没必要的对象构造了。\n关于空间配置器的作用就先讲解到这了，空间配置器的实现可以参考。5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码\n","categories":["STL模板库"],"tags":["c++"]},{"title":"STL迭代器的理解","url":"/undefined/stl_iterator/","content":"\n\n迭代器简介绍迭代器就像是一个”指针”，指向容器（比如vector、list）中的某个元素。通过迭代器，我们不仅可以访问和修改容器中的元素，还能在容器中自由移动（前进或后退）。简而言之，迭代器充当着容器与算法之间的纽带，让你无需了解容器内部实现细节，就能方便地遍历和操作容器元素。迭代器可以透明地访问容器内部的元素的值。STL中提供的一些迭代器：\n\nconst_iterator:常量的正向迭代器，只能读，不能通过该迭代器修改值\niterator:普通的正向迭代器\nconst_reverse_iterator:常量的反向迭代器，只能读，不能写\nreverse_iterator:普通的反向迭代器\n\n以下是迭代器使用的样例代码：\nvector &lt;int&gt; vec;for (int i = 0; i &lt; 20; i++)&#123;\tvec.push_back(rand() % 100 + 1);&#125;//普通的正向迭代器vector&lt;int&gt;::iterator it1= vec.begin();for (; it1 != vec.end(); ++it1)&#123;\tcout &lt;&lt; *it1 &lt;&lt; &quot; &quot;;\tif (*it1 % 2 == 0)\t&#123;\t\t*it1 =0;\t&#125;\t&#125;cout &lt;&lt; endl;//const_iterator是iterator的基类vector&lt;int&gt;::const_iterator it2 = vec.begin();for (; it2 != vec.end(); ++it2)&#123;\tcout &lt;&lt; *it2 &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;vector&lt;int&gt;::reverse_iterator it3 = vec.rbegin();for (;it3!=vec.rend();++it3)&#123; \tcout &lt;&lt; *it3 &lt;&lt; &quot; &quot;;\tif (*it3 == 0)\t&#123;\t\t*it3 = 1;\t&#125;&#125;cout &lt;&lt; endl;//const_reverse_iterator也是reverse_iterator的基类vector&lt;int&gt;::const_reverse_iterator it4 = vec.rbegin();for (; it4 != vec.rend(); ++it4)&#123;\tcout &lt;&lt; *it4 &lt;&lt; &quot; &quot;;&#125;\n\n自定义实现迭代器迭代器一般嵌套实现在容器内部，在上一篇实现容器配置器中我们实现了自定义的vector,本节我们继续在此基础上探索迭代器的实现。\n//迭代器一般实现在容器的嵌套类型class iterator&#123;public:\t//迭代器的四要素\t//1,构造函数\titerator(T* p=nullptr) :_p(p) &#123;&#125;\t//2.!=运算符重载\tbool operator!= (const iterator&amp; it) const\t&#123;\t\treturn _p != it._p;\t&#125;\t//3.前置运算符重载\t//前置++不会产生临时量，效率相对来说更高\tvoid operator++()\t&#123;\t\t++_p;\t&#125;\t//4.解引用方法重载\t//提供解引用的两个版本，普通方法和常方法\tT&amp; operator*() &#123; return *_p; &#125;\tconst T&amp; operator*()const &#123; return *_p; &#125;;private:\tT* _p;//根据容器的变量定义&#125;;//返回容器底层首元素的迭代器表示iterator begin() &#123; return iterator(_first); &#125;//返回容器末尾元素的迭代器表示iterator end() &#123; return iterator(_last); &#125;\n\n将上述的iterator添加到自定义的vector内部后 ，就可以通过迭代器遍历自定义的vector内部元素了。\nint main()&#123;\tvector &lt;int&gt; vec;\tfor (int i = 0; i &lt; 20; i++)\t&#123;\t\tvec.push_back(rand() % 100 + 1);\t&#125;\t//[]（中括号运算符重载）方式遍历，针对连续内存使用\tfor (int i = 0; i &lt; vec.size(); i++)\t&#123;\t\tcout &lt;&lt; vec[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//迭代器方式遍历\tvector&lt;int&gt;::iterator it = vec.begin();\tfor (; it != vec.end(); ++it)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\tfor (int val : vec)//其底层就是通过容器的迭代器来实现遍历的\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;\n迭代器失效迭代器为什么会失效？\n\n当容器调用erase方法后，当前位置到容器末尾的所有迭代器全部失效了\n当调用insert方法后，分为两种情况\n如果没有扩容操作，当前插入点到末尾的所有迭代器全部失效\n如果有扩容操作，容器全部失效\n\n\n\n 迭代器失效部分的代码比较复杂，我这里就使用stl中的vector进行记录\n插入操作导致的迭代器失效：\nvector&lt;int&gt; vec;vec.reserve(10); //预留10个int元素大小for (int i = 1; i &lt;= 10; i++)&#123;\tvec.push_back(i);&#125;for (auto it = vec.begin(); it != vec.end(); ++it)&#123;\tif (*it % 5 == 0)\t&#123;\t\tvec.insert(it, *it - 1);//程序在这执行了一次插入操作后，迭代器就已经失效了\t&#125;&#125;\n执行这里代码是异常退出的；删除操作导致的迭代器失效：\nvector&lt;int&gt; vec;vec.reserve(10); //预留10个int元素大小for (int i = 1; i &lt;= 10; i++)&#123;\tvec.push_back(i);&#125;for (auto it = vec.begin(); it != vec.end(); ++it)&#123;\tif (*it % 2 == 0)\t&#123;\t\t\t//第一次调用erase以后，迭代器it就失效了\t\tvec.erase(it);\t&#125;&#125;\n\n解决迭代器失效问题的方法当容器（如vector、list、map等）在进行插入或删除操作时，会导致迭代器失效。那如何解决上述提到的迭代器失效问题呢？其实erase函数和insert函数返回了对应的一个迭代器，当进行插入或者删除后，会返回下一个元素的迭代器。以下是详细分析：\n\nerase函数的正确用法\n标准库中的erase函数会返回被删除元素的下一个有效迭代器\n\n\n\nvector&lt;int&gt; vec;\tvec.reserve(10); //预留10个int元素大小\tfor (int i = 1; i &lt;= 10; i++)\t&#123;\t\tvec.push_back(i);\t&#125;\tfor (auto it = vec.begin(); it != vec.end(); )\t&#123;\t\tif (*it % 2 == 0)//删除容器中的偶数\t\t&#123;\t\t\t\t//返回删除元素的下一个有效迭代器\t\t\tit=vec.erase(it);\t\t&#125;\t\telse\t\t&#123;\t\t\t++it;\t\t&#125;\t&#125;\tfor (auto it = vec.begin(); it != vec.end(); ++it)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot; ;\t&#125;\t\n\n\ninsert函数的正确用法\ninsert函数同样会返回新插入元素的迭代器\n\n\n\nvector&lt;int&gt; vec;vec.reserve(10); //预留10个int元素大小for (int i = 1; i &lt;= 10; i++)&#123;\tvec.push_back(i);&#125;//在5的倍数前插入1for (auto it = vec.begin(); it != vec.end(); ++it)&#123;\tif (*it % 5 == 0)\t&#123;\t\t\t//返回已插入元素的下一个有效迭代器\t\tit=vec.insert(it,1);//这里1是插入5的前面,返回插入元素的下一个有效迭代器实际是指向5\t\t++it; //所以这里需要后移一位，移动元素5的下一个位置，即6；\t&#125;&#125;for (auto it = vec.begin(); it != vec.end(); ++it)&#123;\tcout &lt;&lt; *it &lt;&lt; &quot; &quot; ;&#125;\t\n\n总结迭代器失效看起来很复杂，但只要记住几个简单的规则，就能轻松避开这个坑：\nvector: 插入或删除元素后，该位置及其后面的迭代器都会失效；如果重新分配内存，所有迭代器都会失效。list/forward_list: 只有被删除元素的迭代器会失效。map/set/multimap/multiset: 只有被删除元素的迭代器会失效。unordered_map/unordered_set: 插入操作可能导致所有迭代器失效（rehash）；删除操作只会导致被删除元素的迭代器失效。\n迭代器失效：99%的C++程序员都会踩的坑 !\n","categories":["STL模板库"],"tags":["c++"]},{"title":"对STL容器的理解","url":"/undefined/stl_container/","content":"\n\n顺序容器vector（向量容器）\nvector是STL容器中的一种常用的容器，和数组类似，由于其大小(size)可变，常用于数组大小不可知的情况下来替代数组。vector也是一种顺序容器，在内存中连续排列，因此可以通过下标快速访问，时间复杂度为O(1)。然而，连续排列也意味着大小固定，数据超过vector的预定值时vector将自动扩容。\n\n以下代码是创建vector，插入元素(push_back)，删除元素(pop_back)等的用法。\nvector&lt;int&gt; vec;vec.push_back(20);//末尾添加元素，时间复杂度o(1)vec.pop_back();//删除末尾元素,时间复杂度o(1)for (int i = 0; i &lt; 10; i++)&#123;\tvec.push_back(i+1);&#125;for (int i = 0; i &lt; 10; i++)&#123;\tcout &lt;&lt; vec[i] &lt;&lt; &quot; &quot;; //使用[]遍历数组&#125;cout &lt;&lt; endl;\n在上述代码中，定义了vector&lt;int&gt; vec;这个时候vec的大小是多少呢？这里没有指定开辟多大空间，那么这个vec的大小默认就是0了；那么在上述代码中，频繁的指向插入操作，就会频繁的扩容，涉及到内存中数据的频繁拷贝，效率低；所以一般在定义vector时会预留vector的大小，请看下面代码：\n/** reserve(20),开辟20大小的内存，但是不初始化* resize(20),扩容为20大小，初始化为0*/vector&lt;int&gt; vec1;vector&lt;int&gt; vec2;vec1.reserve(20);vec2.resize(20);cout &lt;&lt; vec1.empty() &lt;&lt; vec2.empty() &lt;&lt; endl;for (auto it = vec2.begin(); it != vec2.end(); ++it)&#123;\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;; //这里打印全为零&#125;\ntips:这里reserve函数在内存中给vec1预留了20大小的内存，但是需要注意的是现在vec1实际的大小为0；如果想访问vec1[0]会报数组越界错误。\n使用迭代器删除和插入元素，这里要防止迭代器失效。关于迭代器失效，可以参考我的另一篇文章\n//删除所有偶数，erase()的时间复杂度为o(n)\tauto it = vec.begin();\twhile (it != vec.end())\t&#123;\t\tif (*it % 2 == 0)\t\t&#123;\t\t\t\t//这里的it需要接收erase函数返回的迭代器，不然会迭代器失效\t\t\tit=vec.erase(it); //erase函数删除指定位置的迭代器，并且返回下一个元素的迭代器\t\t&#125;\t\telse\t\t&#123;\t\t\tit++;\t\t&#125;\t&#125;\tfor (auto it = vec.begin(); it != vec.end(); ++it)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//在所有数中插入比原来数字小1的数，insert()的时间复杂度为o(n)\tit = vec.begin();\tfor (; it != vec.end(); ++it)\t&#123;\t\tif (*it%2)\t\t&#123;\t\t\t//这里的it需要接收erase函数返回的迭代器，不然会迭代器失效\t\t\tit = vec.insert(it, *it - 1);//insert函数插入在指定位置之前，并且返回新插入元素的迭代器\t\t\t++it;//这里的it必须加1，不然会一直在遇到的第一个奇数中一直插入（死循环）\t\t&#125;\t&#125;\tfor (auto it = vec.begin(); it != vec.end(); ++it)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\nvector的扩容原理在学习过程中，遇到地关于vector扩容有两种说法，一是按照1.5倍扩容，一是按照2倍扩容，下面就通过代码验证一下。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;\tvector&lt;int&gt; vec;\tint count = 1;\tint* init_addr = nullptr;\tfor (int i = 0; i &lt; 128; i++)\t&#123;\t\tvec.push_back(i);\t\tif (init_addr != &amp;(vec[0]))\t\t&#123;\t\t\t\tcout &lt;&lt;&quot;第&quot;&lt;&lt;count&lt;&lt;&quot;次扩容&quot;&lt;&lt; &quot;扩容后大小为：&quot; &lt;&lt; vec.capacity() &lt;&lt;&quot;扩容后的地址为：&quot; &lt;&lt;init_addr&lt;&lt; endl;\t\t\tinit_addr = &amp;(vec[0]);\t\t\tcount++;\t\t&#125;\t&#125;\treturn 0;&#125;\n在windows平台下执行，打印结果为可以看到，在该平台下，是按照1 → 2 (11.5&#x3D;1.5，取2)2 → 3 (21.5&#x3D;3，取3)3 → 4 (31.5&#x3D;4.5，取4)4 → 6 (41.5&#x3D;6，取6)6 → 9 (61.5&#x3D;9，取9)9 → 13 (91.5&#x3D;13.5，取13)13 → 19 (131.5&#x3D;19.5，取19)19 → 28 (191.5&#x3D;28.5，取28)28 → 42 (281.5&#x3D;42，取42)42 → 63 (421.5&#x3D;63，取63)63 → 94 (631.5&#x3D;94.5，取94)94 → 141 (941.5&#x3D;141，取141)可以看到，如果采用的是1.5倍扩容方法，在这里我们需要申请128大小的空间，而最后申请的空间是141；并且前几次申请的空间1+2+3+4+6+9+13+19+28+42+63+94=284&gt;128,如果前面申请的空间是连续的，也就可以直接复用前面的内存了比如说，在上图中，第9次扩容和第11次扩容的地址就是一样的（表明旧内存块在扩容后被释放，新分配的内存可能重新利用之前的地址。这说明1.5倍扩容在内存回收和复用上有优势。）采用1.5倍扩容的缺点也比较明显，也就是涉及到多次的扩容操作，申请128大小的需要扩容13次；而采用2倍扩容方法只需要。。。\n在linux平台下执行，打印结果为并且前几次申请的空间1+2+4+8+16+32+64=127&lt;128,不可以完整的复用前面申请的内存空间（但是这里第2次和第4次扩容后的起始地址是一样的，暂时还没了解清楚）【C++ Primer】 erase和insert返回的迭代器位置总结\n详解C++STL容器系列（一）—— vector的详细用法和底层原理这篇关于vector的讲解还挺不错的，大家可以参考\ndeque（双端队列容器）deque即（double-ended queue）双端队列容器，支持o(1)时间复杂度内在头部和尾部插入和删除元素；deque没有容量的概念，而是动态地以分段连续空间组合而成，随时可以增加一段新的空间并连接起来。\n初始时，first和last指针位于二维数组的中间位置（感觉这里类似两个vector拼接而成的结构）。当从尾部插入元素时，last指针向后移动；当从头部插入元素时，first指针向前移动。\n\n增加元素操作：deq.push_back(20);从末尾添加元素，时间复杂度o(1)deq.push_front(10);从首部添加元素，时间复杂度o(1)deq.insert(it,30);it指向的位置添加元素\n\n\n删除操作：deq.pop_back(20);从末尾删除元素，时间复杂度o(1)deq.pop_front(10);从首部删除元素，时间复杂度o(1)deq.erase(it);it指向的位置删除元素\n\n\n查询操作：iterator（连续的insert和erase一定要考虑迭代器失效问题）\n\n更多关于deque的理解，请参考详解STL中的deque\nlist（链表容器）\n\n模板类list是一个容器，list是由双向链表来实现的，每个节点存储1个元素。list支持前后两种移动方向。\n\n 优势 ：任何位置执行插入和删除动作都非常快。 缺点 ：不支持随机存取，查找某个元素的效率较低。\n小结deque和list，比vector容器多出来的增加删除的接口为：push_front()和pop_front()。vector特点：动态数组，内存是连续的，以2倍的方式进行扩容（linux平台下是2倍，在windoes平台下是1.5倍）deque特点：动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容的时候（第一维的数组进行2倍扩容，再把原来的第二维数组放到新扩容的第一维数组的中间部分，便于支持deque前后的插入与删除）\ndeque底层是否是连续的？答：并不是，deque的每一个第二维数组都是连续的，整体来看是分段连续的。第一维指向不同的二维连续区域（deque是动态开辟的二维数组）\nvector和deque的区别\n\n底层数据结构：vector是动态数组，deque是动态二维数组\nvector的中间和首部插入元素时间复杂度为o(n),末尾插入时间复杂度为o(1);deque的首部和末尾插入时间复杂度为o(1)，中间插入的时间复杂度为o（n）\n内存的使用效率：vector的内存使用效率低，原因是vector需要一片连续的内存空间，当发生扩容时，原来内存上的已存在的数据需要复制到新开辟的内存空间中去；而deque不要求整片连续的空间，只要求分段连续就可以，当发生扩容的时候，也只是第一维发生扩容，（在第二维不会发生复制，应该还是保留在原来的内存去，只需要开辟额外需要的内存就行？不如说第一维度从2扩容到4，第二维只需要新开辟2个连续的内存空间就好，加上原来的两个内存空间上的数据，尚未实验验证）\n在中间进行insert和erase,vector的效率会更高一些。虽然两者的时间复杂度都为o(n)，但是由于vector是一整片连续的内存空间，由于cpu的缓存机制，即时间局部性和空间局部性原理，vector的效率必然会更高一些。\n\n\n空间局部性（Spatial Locality）：如果程序访问了某个内存地址，很可能很快会访问其附近的内存。vector 的优势：元素在内存中是连续的，CPU 会预加载相邻元素到缓存（缓存行通常为 64 字节），后续访问命中缓存，速度极快。\n时间局部性（Temporal Locality）： 最近访问的数据很可能被再次访问。vector的优势：移动元素时，被操作的元素在内存中是连续的，缓存命中率高。\n\nvector和list的区别类比数组和链表的区别\n\n底层数据结构：数组、双向循环链表\n\n时间复杂度\n  1.vector的增加、删除时间复杂度为o(n)，下标随机访问o(1)，查找特定元素复杂度o(n);  2.list的增加、删除(不考虑查找待删除元素)时间复杂度为o(1),查询操作为o(n);\n\n\n容器适配器容器适配器包括statck、queue、priority_queue。1.适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全由底层依赖的容器实现的。2.没有实现自己的迭代器（不可通过迭代器访问）\nstatck的源码截图如下：stack的简单框架如下：\ntemplate&lt;typename T,typename Container=deque&lt;T&gt;&gt;class Stack&#123;public:\tvoid push(const T&amp; val) &#123; con.push_back(val); &#125;\tvoid pop() &#123; con.pop_back(); &#125;\tT top() const &#123; return con.back(); &#125;private:\tContainer con;&#125;;\n\n容器适配器的操作方法statck:\n\npush入栈  \npop出栈  \ntop查看栈顶元素  \nempty判断栈空  \nsize返回元素个数\n\nqueue:\n\npush入队 \npop出队 \nfront查看队头元素 \nback查看队尾元素  \nempty判断队空 \nsize返回元素个数\n\npriority_queue:\n\npush入队 \npop出队 \ntop查看队头元素   \nempty判断对空 \nsize返回元素个数\n\nint main()&#123;\t\t/*************以stack为例********************/\tstack&lt;int&gt; st;\tfor (int i = 1; i &lt;= 20; i++)\t&#123;\t\tst.push(i);\t&#125;\tcout &lt;&lt; endl;\tcout &lt;&lt; st.size() &lt;&lt; endl;\twhile (!st.empty())\t&#123;\t\tcout &lt;&lt; st.top() &lt;&lt; &quot; &quot;;\t\tst.pop();\t&#125;\tcout &lt;&lt; endl;\t/**************以priority_queue为例*******************/\tpriority_queue&lt;int&gt; pque;\tfor (int i = 1; i &lt;= 20; i++)\t&#123;\t\tpque.push(rand()%100+1); //默认大根堆，乱序输入\t&#125;\tcout &lt;&lt; endl;\tcout &lt;&lt; pque.size() &lt;&lt; endl;\twhile (!pque.empty())\t&#123;\t\tcout &lt;&lt; pque.top() &lt;&lt; &quot; &quot;; //顺序输出\t\tpque.pop();\t&#125;\tcout &lt;&lt; endl;\treturn 0;&#125;\n底层容器statck依赖deque、queue也依赖deque容器、priority_queue依赖vector容器。\nstack和queue为什么依赖deque容器？\n\nvector的初始内存使用效率太低了，需要从1-2-4-8频繁扩容；而deque的第二维度默认开辟空间4096/sizeof(int)=1024字节大小内存\n对于queue来说，需要实现先进先出，即需要实现头删尾插，而deque的首尾操作的时间复杂度为o(1)\nvector需要大片的连续内存，而deque只需要分段连续的内存；对于大量数据存储，deque的内存利用率更好一些（随着程序的运行，会产生大量的内存碎片，此时要找一块连续且空间较大的内存相对较复杂）。\n\npriority_queue为什么依赖vector容器？\npriority_queue采用堆的存储，底层默认把数据组织成大根堆结构（也存在小根堆），要求在一片连续的内存空间。\n\n核心概念：堆是一颗完全二叉树，它的特点是可以用一维数组来储存。\n\n「数组」堆排序 &#x2F; 大根堆优化（C++）\n对于一个序号从0开始的堆结构\n\n对于第idx个节点父节点序号：（idx-1）&#x2F;2左子节点顺序： idx* 2+1右子节点顺序： idx* 2+2\n\n对于堆结构来说，采用数组存储方式是因为父子节点与其下标之间存在联系。根据存储元素在数组中的下标，可以计算得到父节点，左子节点，右子节点的下标，然后分别得到对应的值。\n如确定节点2的父节点、左子节点、右字节点的值步骤如下：\n\nidx&#x3D;2父节点值：vec[(idx-1)&#x2F;2]&#x3D;vec[0]&#x3D;10左子节点：vec[idx2+1]&#x3D;vec[5]&#x3D;40右子节点：vec[idx2+1]&#x3D;vec[6]&#x3D;50\n\n总结：由于 std::vector 将元素存储在连续的内存块中，使得通过下标 i 访问元素 vec[i] 变得极其高效。vec[i] 的地址只需起始地址加上 i 乘以元素大小的偏移量 (start_address + i * sizeof(element))。这种 O(1) 复杂度的随机访问能力，是堆能够利用简单的下标计算（如 父节点&#x3D;(i-1)&#x2F;2, 左孩子&#x3D;2i+1, 右孩子&#x3D;2i+2) 在数组中高效模拟树形结构并快速定位父子节点的根本前提。非连续存储的数据结构（如链表）无法进行这种直接的下标计算和访问。\n关联容器有序关联容器，底层为红黑树，增删查的时间复杂度为o(log2(n)),2为底数\n\nset  （集合 key）\nmultiset (多重集合)\nmap  (映射表 [key,value])\nmultimap  (多重映射表)\n\n无序关联容器，底层为链式哈希表  增删查的时间复杂度为o(1)\n\nunordered_set  \nunordered_multiset \nunordered_map\nunordered_multimap\n\n常用方法：增加：insert(val)遍历：iterator搜索，调用find成员方法删除：erase(key) 、erase(iterator)\n无序容器unordered_set的常见方法：\nunordered_set&lt;int&gt; set1;//元素不可重复unordered_multiset&lt;int&gt; set2;//元素可重复set1.insert(15);set1.insert(20);set1.insert(30);set1.count(15); //判断15是否存在于set1中，只能存在1个或0个set2.count(15);//计算15在set2中个数，可存在多个auto it = set1.begin();/*可以迭代器遍历\t*/ for(;it!=set1.end();++it) &#123;\t cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; set1.erase(20); //按key值删除元素 for (it = set1.begin(); it != set1.end();) &#123;\tif (*it == 30)\t &#123;\t\t it = set1.erase(it); //迭代器遍历删除指定元素\t &#125;\telse\t&#123;\t\t++it;\t&#125; &#125; //在set1中找20，如果存在返回迭代器；不存在访问容器末尾的迭代器 it = set1.find(20);  if (it != set1.end()) &#123;\t cout &lt;&lt; *it &lt;&lt; endl; &#125;\n\nunordered_map的常见方法：\nunordered_map&lt;int, string &gt; map1; //不允许key重复//三种插入方式map1.insert(&#123; 1, &quot;excelent&quot; &#125;);map1.insert(make_pair(100, &quot;寒&quot;));//打包成pair对//这里也可以通过emplace()函数，传入参数，直接调用构造函数加入map中map1.emplace(66, &quot;lucky&quot;);//map的operator []/** 1.查询* 2.如果key不存在，会插入一对数据[key,string(&quot; &quot;)],因为这里定义的是unordered_map&lt;int, string &gt; map1* 3.如果给定值，map1[10]=&quot;good&quot;;，会插入一对数据[10,string(&quot;good&quot;)]*/map1[10] = &quot;good&quot;;cout&lt;&lt;map1[20]&lt;&lt;endl; cout &lt;&lt; map1.size() &lt;&lt; endl;//打印map的大小cout &lt;&lt; map1[10] &lt;&lt; endl; //访问元素map1.erase(10); //删除指定key的pair对auto it = map1.find(100);if (it != map1.end())&#123;\tcout &lt;&lt; &quot;key:  &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;  value:  &quot; &lt;&lt; it-&gt;second&lt;&lt;endl;&#125;/*两种遍历方式*///这里需要返回常引用，普通引用会报错(普通引用可以间接修改容器内部的值，不安全)for (const pair&lt;int, string &gt;&amp; m : map1)&#123;\tcout &lt;&lt; m.first &lt;&lt;&quot;  &quot; &lt;&lt; m.second &lt;&lt; endl;&#125;for (auto it = map1.begin(); it != map1.end(); ++it)&#123;\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second&lt;&lt;endl;&#125;\n\n场景应用：统计所有数据的出现次数，打印出现频次大于1的数的值及其出现频次：一般使用unordered_map将给定的大量数据进行去重，仅打印出现1次的数：一般使用unordered_set\n有序容器有序容器的基本操作与无序容器的基本操作一致，略有不同的是，有序容器内部会保持元素的顺序（默认是升序）。\nclass student&#123;public:\tstudent(int id, string name) :id_(id), name_(name) &#123;&#125;private:\tint id_;\tstring name_;&#125;;int main()&#123;\t\tset&lt;student&gt; set1;\tset1.insert(student(1, &quot;寒&quot;));\tset1.insert(student(2, &quot;宇&quot;));&#125;\n这里我们自定义了一个学生类容器放到set有序集合容器中，报错了\n这是因为在自定义的student类中并没有实现小于运算符重载,代码修改如下\nclass student&#123;public:\tstudent(int id, string name) :id_(id), name_(name) &#123;&#125;\tbool operator &lt;(const student&amp; stu) const//定义的&lt;运算符重载\t&#123;\t\treturn id_ &lt; stu.id_;\t&#125;private:\tint id_;\tstring name_; \tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, const student&amp; stu);&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, const student&amp; stu)&#123;\tout &lt;&lt; &quot;id:&quot; &lt;&lt; stu.id_ &lt;&lt; &quot; &quot; &lt;&lt; &quot;name: &quot; &lt;&lt; stu.name_ ;\treturn out;&#125;int main()&#123;\t\tset&lt;student&gt; set1;\tset1.insert(student(1, &quot;寒&quot;));\tset1.insert(student(2, &quot;宇&quot;));\tset1.insert(student(3, &quot;哈哈&quot;));\tfor (auto it = set1.begin(); it != set1.end(); ++it)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; endl;\t&#125;&#125;\n打印结果为：\nmap容器\nmap&lt;int,student&gt; stuMap;//如果要使用自定义的类student定义map，要求自定义的类存在默认构造函数class student&#123;public:\t//student(int id, string name) :id_(id), name_(name) &#123;&#125;  这个不行\tstudent(int id=0, string name=&quot;&quot;) :id_(id), name_(name) &#123;&#125;&#125;\n\n\n这里对应STL容器的总结还不够全面，主要是在我学习过程中遇到的一些知识点进行记录。后序学习过程中遇到了会继续更新。\n","categories":["STL模板库"],"tags":["c++"]}]