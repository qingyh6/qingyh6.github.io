<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://localhost/atom.xml" rel="self"/>
  
  <link href="https://localhost/"/>
  <updated>2025-07-12T03:46:05.610Z</updated>
  <id>https://localhost/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件系统的理解</title>
    <link href="https://localhost/undefined/disk/"/>
    <id>https://localhost/undefined/disk/</id>
    <published>2025-07-12T03:45:19.000Z</published>
    <updated>2025-07-12T03:46:05.610Z</updated>
    
    
    <summary type="html">文件系统的理解</summary>
    
    
    
    <category term="note" scheme="https://localhost/categories/note/"/>
    
    
    <category term="随笔" scheme="https://localhost/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>对STL容器的理解</title>
    <link href="https://localhost/undefined/stl_container/"/>
    <id>https://localhost/undefined/stl_container/</id>
    <published>2025-07-10T07:52:39.000Z</published>
    <updated>2025-07-12T05:51:03.207Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><h2 id="vector（向量容器）"><a href="#vector（向量容器）" class="headerlink" title="vector（向量容器）"></a>vector（向量容器）</h2><blockquote><p>vector是STL容器中的一种常用的容器，和数组类似，由于其大小(size)可变，常用于数组大小不可知的情况下来替代数组。vector也是一种顺序容器，在内存中连续排列，因此可以通过下标快速访问，时间复杂度为O(1)。然而，连续排列也意味着大小固定，数据超过vector的预定值时vector将自动扩容。</p></blockquote><p>以下代码是创建<code>vector</code>，插入元素(<code>push_back</code>)，删除元素(<code>pop_back</code>)等的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">20</span>);<span class="comment">//末尾添加元素，时间复杂度o(1)</span></span><br><span class="line">vec.<span class="built_in">pop_back</span>();<span class="comment">//删除末尾元素,时间复杂度o(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//使用[]遍历数组</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在上述代码中，定义了<code>vector&lt;int&gt; vec;</code>这个时候vec的大小是多少呢？这里没有指定开辟多大空间，那么这个vec的大小默认就是0了；那么在上述代码中，频繁的指向插入操作，就会频繁的扩容，涉及到内存中数据的频繁拷贝，效率低；所以一般在定义vector时会预留vector的大小，请看下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* reserve(20),开辟20大小的内存，但是不初始化</span></span><br><span class="line"><span class="comment">* resize(20),扩容为20大小，初始化为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec2;</span><br><span class="line">vec<span class="number">1.</span><span class="built_in">reserve</span>(<span class="number">20</span>);</span><br><span class="line">vec<span class="number">2.</span><span class="built_in">resize</span>(<span class="number">20</span>);</span><br><span class="line">cout &lt;&lt; vec<span class="number">1.</span><span class="built_in">empty</span>() &lt;&lt; vec<span class="number">2.</span><span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec<span class="number">2.</span><span class="built_in">begin</span>(); it != vec<span class="number">2.</span><span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//这里打印全为零</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tips:</code>这里reserve函数在内存中给vec1预留了20大小的内存，但是需要注意的是现在vec1实际的大小为0；如果想访问vec1[0]会报数组越界错误。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/4104dda585e24653a6365fa20975b7a9.png"                        alt="在这里插入图片描述"                 ></p><p>使用迭代器删除和插入元素，这里要防止迭代器失效。关于迭代器失效，可以参考我的<a class="link"   href="https://blog.csdn.net/weixin_52288941/article/details/149098124?spm=1011.2415.3001.5331" >另一篇文章<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除所有偶数，erase()的时间复杂度为o(n)</span></span><br><span class="line"><span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != vec.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里的it需要接收erase函数返回的迭代器，不然会迭代器失效</span></span><br><span class="line">it=vec.<span class="built_in">erase</span>(it); <span class="comment">//erase函数删除指定位置的迭代器，并且返回下一个元素的迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在所有数中插入比原来数字小1的数，insert()的时间复杂度为o(n)</span></span><br><span class="line">it = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it%<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里的it需要接收erase函数返回的迭代器，不然会迭代器失效</span></span><br><span class="line">it = vec.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);<span class="comment">//insert函数插入在指定位置之前，并且返回新插入元素的迭代器</span></span><br><span class="line">++it;<span class="comment">//这里的it必须加1，不然会一直在遇到的第一个奇数中一直插入（死循环）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>vector的扩容原理</strong><br>在学习过程中，遇到地关于vector扩容有两种说法，一是按照1.5倍扩容，一是按照2倍扩容，下面就通过代码验证一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* init_addr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (init_addr != &amp;(vec[<span class="number">0</span>]))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;count&lt;&lt;<span class="string">&quot;次扩容&quot;</span>&lt;&lt; <span class="string">&quot;扩容后大小为：&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt;<span class="string">&quot;扩容后的地址为：&quot;</span> &lt;&lt;init_addr&lt;&lt; endl;</span><br><span class="line">init_addr = &amp;(vec[<span class="number">0</span>]);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>windows平台</code>下执行，打印结果为<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/ff5308d9057943378f03993619a10dac.png"                        alt="在这里插入图片描述"                 ><br>可以看到，在该平台下，是按照<br>1 → 2 (1<em>1.5&#x3D;1.5，取2)<br>2 → 3 (2</em>1.5&#x3D;3，取3)<br>3 → 4 (3<em>1.5&#x3D;4.5，取4)<br>4 → 6 (4</em>1.5&#x3D;6，取6)<br>6 → 9 (6<em>1.5&#x3D;9，取9)<br>9 → 13 (9</em>1.5&#x3D;13.5，取13)<br>13 → 19 (13<em>1.5&#x3D;19.5，取19)<br>19 → 28 (19</em>1.5&#x3D;28.5，取28)<br>28 → 42 (28<em>1.5&#x3D;42，取42)<br>42 → 63 (42</em>1.5&#x3D;63，取63)<br>63 → 94 (63<em>1.5&#x3D;94.5，取94)<br>94 → 141 (94</em>1.5&#x3D;141，取141)<br>可以看到，如果采用的是1.5倍扩容方法，在这里我们需要申请128大小的空间，而最后申请的空间是141；并且前几次申请的空间<code>1+2+3+4+6+9+13+19+28+42+63+94=284&gt;128</code>,如果前面申请的空间是连续的，也就可以直接复用前面的内存了<br>比如说，在上图中，第9次扩容和第11次扩容的地址就是一样的（表明旧内存块在扩容后被释放，新分配的内存可能重新利用之前的地址。这说明1.5倍扩容在内存回收和复用上有优势。）<br>采用1.5倍扩容的缺点也比较明显，也就是涉及到多次的扩容操作，申请128大小的需要扩容13次；而采用2倍扩容方法只需要。。。</p><p>在<code>linux平台</code>下执行，打印结果为<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/5d8a75f7534b437aad2a42fd7b7c037b.png"                        alt="在这里插入图片描述"                 ><br>并且前几次申请的空间<code>1+2+4+8+16+32+64=127&lt;128</code>,不可以完整的复用前面申请的内存空间<br>（但是这里第2次和第4次扩容后的起始地址是一样的，暂时还没了解清楚）<br><a class="link"   href="https://zhuanlan.zhihu.com/p/642358957" >【C++ Primer】 erase和insert返回的迭代器位置总结<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://blog.csdn.net/aruewds/article/details/117375364" >详解C++STL容器系列（一）—— vector的详细用法和底层原理<i class="fas fa-external-link-alt"></i></a>这篇关于vector的讲解还挺不错的，大家可以参考</p><h2 id="deque（双端队列容器）"><a href="#deque（双端队列容器）" class="headerlink" title="deque（双端队列容器）"></a>deque（双端队列容器）</h2><p>deque即（double-ended queue）双端队列容器，支持o(1)时间复杂度内在头部和尾部插入和删除元素；deque没有容量的概念，而是动态地以分段连续空间组合而成，随时可以增加一段新的空间并连接起来。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/aecda8cdeea046909ec5c80eddf3333c.png"                        alt="在这里插入图片描述"                 ></p><p>初始时，first和last指针位于二维数组的中间位置（感觉这里类似两个vector拼接而成的结构）。当从尾部插入元素时，last指针向后移动；当从头部插入元素时，first指针向前移动。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/cb05a182261d4553a3c9e157cd8211f9.png"                        alt="在这里插入图片描述"                 ></p><blockquote><p>增加元素操作：<br>deq.push_back(20);从末尾添加元素，时间复杂度o(1)<br>deq.push_front(10);从首部添加元素，时间复杂度o(1)<br>deq.insert(it,30);it指向的位置添加元素</p></blockquote><blockquote><p>删除操作：<br>deq.pop_back(20);从末尾删除元素，时间复杂度o(1)<br>deq.pop_front(10);从首部删除元素，时间复杂度o(1)<br>deq.erase(it);it指向的位置删除元素</p></blockquote><blockquote><p>查询操作：<br>iterator（连续的insert和erase一定要考虑迭代器失效问题）</p></blockquote><p>更多关于deque的理解，请参考<a class="link"   href="https://zhuanlan.zhihu.com/p/345798683" >详解STL中的deque<i class="fas fa-external-link-alt"></i></a></p><h2 id="list（链表容器）"><a href="#list（链表容器）" class="headerlink" title="list（链表容器）"></a>list（链表容器）</h2><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/f6e9d1e8135b445d8149ae57cc381838.png"                        alt="在这里插入图片描述"                 ></p><blockquote><p>模板类list是一个容器，list是由双向链表来实现的，每个节点存储1个元素。list支持前后两种移动方向。</p></blockquote><p> <strong>优势</strong> ：任何位置执行插入和删除动作都非常快。<br> <strong>缺点</strong> ：不支持随机存取，查找某个元素的效率较低。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>deque和list，比vector容器多出来的增加删除的接口为：push_front()和pop_front()。<br><strong>vector特点</strong>：动态数组，内存是连续的，以2倍的方式进行扩容（linux平台下是2倍，在windoes平台下是1.5倍）<br><strong>deque特点</strong>：动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容的时候（第一维的数组进行2倍扩容，再把原来的第二维数组放到新扩容的第一维数组的中间部分，便于支持deque前后的插入与删除）</p><p><strong>deque底层是否是连续的</strong>？<br>答：并不是，deque的每一个第二维数组都是连续的，整体来看是分段连续的。第一维指向不同的二维连续区域（deque是动态开辟的二维数组）</p><p><strong>vector和deque的区别</strong></p><ul><li>底层数据结构：vector是动态数组，deque是动态二维数组</li><li>vector的中间和首部插入元素时间复杂度为o(n),末尾插入时间复杂度为o(1);deque的首部和末尾插入时间复杂度为o(1)，中间插入的时间复杂度为o（n）</li><li>内存的使用效率：vector的内存使用效率低，原因是vector需要一片连续的内存空间，当发生扩容时，原来内存上的已存在的数据需要复制到新开辟的内存空间中去；而deque不要求整片连续的空间，只要求分段连续就可以，当发生扩容的时候，也只是第一维发生扩容，（在第二维不会发生复制，应该还是保留在原来的内存去，只需要开辟额外需要的内存就行？不如说第一维度从2扩容到4，第二维只需要新开辟2个连续的内存空间就好，加上原来的两个内存空间上的数据，尚未实验验证）</li><li>在中间进行insert和erase,vector的效率会更高一些。虽然两者的时间复杂度都为o(n)，但是由于vector是一整片连续的内存空间，由于cpu的缓存机制，即时间局部性和空间局部性原理，vector的效率必然会更高一些。</li></ul><blockquote><p>空间局部性（Spatial Locality）：<br>如果程序访问了某个内存地址，很可能很快会访问其附近的内存。<br>vector 的优势：元素在内存中是连续的，CPU 会预加载相邻元素到缓存（缓存行通常为 64 字节），后续访问命中缓存，速度极快。</p><p>时间局部性（Temporal Locality）： 最近访问的数据很可能被再次访问。<br>vector的优势：移动元素时，被操作的元素在内存中是连续的，缓存命中率高。</p></blockquote><p><strong>vector和list的区别</strong><br>类比数组和链表的区别</p><ul><li><p>底层数据结构：数组、双向循环链表</p></li><li><p>时间复杂度</p><p>  1.vector的增加、删除时间复杂度为o(n)，下标随机访问o(1)，查找特定元素复杂度o(n);<br>  2.list的增加、删除(不考虑查找待删除元素)时间复杂度为o(1),查询操作为o(n);</p></li></ul><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>容器适配器包括statck、queue、priority_queue。<br>1.适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全由底层依赖的容器实现的。<br>2.没有实现自己的迭代器（不可通过迭代器访问）</p><p>statck的源码截图如下：<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/e79fd4a0530e4a88b483743273b86cc1.png"                        alt="在这里插入图片描述"                 ><br>stack的简单框架如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Container=deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">void</span> <span class="built_in">push</span>(<span class="type">const</span> T&amp; val) &#123; con.<span class="built_in">push_back</span>(val); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; con.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line"><span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> con.<span class="built_in">back</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Container con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="容器适配器的操作方法"><a href="#容器适配器的操作方法" class="headerlink" title="容器适配器的操作方法"></a>容器适配器的操作方法</h2><p><strong>statck</strong>:</p><ul><li>push入栈  </li><li>pop出栈  </li><li>top查看栈顶元素  </li><li>empty判断栈空  </li><li>size返回元素个数</li></ul><p><strong>queue</strong>:</p><ul><li>push入队 </li><li>pop出队 </li><li>front查看队头元素 </li><li>back查看队尾元素  </li><li>empty判断队空 </li><li>size返回元素个数</li></ul><p><strong>priority_queue</strong>:</p><ul><li>push入队 </li><li>pop出队 </li><li>top查看队头元素   </li><li>empty判断对空 </li><li>size返回元素个数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*************以stack为例********************/</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************以priority_queue为例*******************/</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pque;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pque.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">100</span><span class="number">+1</span>); <span class="comment">//默认大根堆，乱序输入</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pque.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (!pque.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pque.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//顺序输出</span></span><br><span class="line">pque.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层容器"><a href="#底层容器" class="headerlink" title="底层容器"></a>底层容器</h2><p>statck依赖deque、queue也依赖deque容器、priority_queue依赖vector容器。</p><p><strong>stack和queue为什么依赖deque容器</strong>？</p><ul><li>vector的初始内存使用效率太低了，需要从1-2-4-8频繁扩容；而deque的第二维度默认开辟空间<code>4096/sizeof(int)=1024</code>字节大小内存</li><li>对于queue来说，需要实现先进先出，即需要实现头删尾插，而deque的首尾操作的时间复杂度为o(1)</li><li>vector需要大片的连续内存，而deque只需要分段连续的内存；对于大量数据存储，deque的内存利用率更好一些（随着程序的运行，会产生大量的内存碎片，此时要找一块连续且空间较大的内存相对较复杂）。</li></ul><p><strong>priority_queue为什么依赖vector容器</strong>？</p><p>priority_queue采用堆的存储，底层默认把数据组织成大根堆结构（也存在小根堆），要求在一片连续的内存空间。</p><blockquote><p><strong>核心概念</strong>：堆是一颗完全二叉树，它的特点是可以用一维数组来储存。</p></blockquote><p><a class="link"   href="https://blog.csdn.net/dakingffo/article/details/142285574" >「数组」堆排序 &#x2F; 大根堆优化（C++）<i class="fas fa-external-link-alt"></i></a></p><p>对于一个序号从0开始的堆结构</p><blockquote><p>对于第idx个节点<br>父节点序号：（idx-1）&#x2F;2<br>左子节点顺序： idx* 2+1<br>右子节点顺序： idx* 2+2</p></blockquote><p>对于堆结构来说，采用数组存储方式是因为父子节点与其下标之间存在联系。根据存储元素在数组中的下标，可以计算得到父节点，左子节点，右子节点的下标，然后分别得到对应的值。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/2be5cbed148a4232aa4d254a020ab08f.png"                        alt="在这里插入图片描述"                 ></p><p>如确定节点2的父节点、左子节点、右字节点的值步骤如下：</p><blockquote><p>idx&#x3D;2<br>父节点值：vec[(idx-1)&#x2F;2]&#x3D;vec[0]&#x3D;10<br>左子节点：vec[idx<em>2+1]&#x3D;vec[5]&#x3D;40<br>右子节点：vec[idx</em>2+1]&#x3D;vec[6]&#x3D;50</p></blockquote><p><code>总结</code>：由于 std::vector 将元素存储在连续的内存块中，使得通过下标 i 访问元素 vec[i] 变得极其高效。vec[i] 的地址只需起始地址加上 i 乘以元素大小的偏移量 (start_address + i * sizeof(element))。这种 O(1) 复杂度的随机访问能力，是堆能够利用简单的下标计算（如 父节点&#x3D;(i-1)&#x2F;2, 左孩子&#x3D;2<em>i+1, 右孩子&#x3D;2</em>i+2) 在数组中高效模拟树形结构并快速定位父子节点的根本前提。非连续存储的数据结构（如链表）无法进行这种直接的下标计算和访问。</p><h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>有序关联容器，底层为红黑树，增删查的时间复杂度为o(log2(n)),2为底数</p><ul><li>set  （集合 key）</li><li>multiset (多重集合)</li><li>map  (映射表 [key,value])</li><li>multimap  (多重映射表)</li></ul><p>无序关联容器，底层为链式哈希表  增删查的时间复杂度为o(1)</p><ul><li>unordered_set  </li><li>unordered_multiset </li><li>unordered_map</li><li>unordered_multimap</li></ul><p>常用方法：<br>增加：insert(val)<br>遍历：iterator搜索，调用find成员方法<br>删除：erase(key) 、erase(iterator)</p><h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p><strong>unordered_set的常见方法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; set1;<span class="comment">//元素不可重复</span></span><br><span class="line">unordered_multiset&lt;<span class="type">int</span>&gt; set2;<span class="comment">//元素可重复</span></span><br><span class="line">set<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">set<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">set<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">set<span class="number">1.</span><span class="built_in">count</span>(<span class="number">15</span>); <span class="comment">//判断15是否存在于set1中，只能存在1个或0个</span></span><br><span class="line">set<span class="number">2.</span><span class="built_in">count</span>(<span class="number">15</span>);<span class="comment">//计算15在set2中个数，可存在多个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = set<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">/*可以迭代器遍历*/</span></span><br><span class="line"> <span class="keyword">for</span>(;it!=set<span class="number">1.</span><span class="built_in">end</span>();++it)</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> set<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">20</span>); <span class="comment">//按key值删除元素</span></span><br><span class="line"> <span class="keyword">for</span> (it = set<span class="number">1.</span><span class="built_in">begin</span>(); it != set<span class="number">1.</span><span class="built_in">end</span>();)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">if</span> (*it == <span class="number">30</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> it = set<span class="number">1.</span><span class="built_in">erase</span>(it); <span class="comment">//迭代器遍历删除指定元素</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在set1中找20，如果存在返回迭代器；不存在访问容器末尾的迭代器</span></span><br><span class="line"> it = set<span class="number">1.f</span>ind(<span class="number">20</span>); </span><br><span class="line"> <span class="keyword">if</span> (it != set<span class="number">1.</span><span class="built_in">end</span>())</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>unordered_map的常见方法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string &gt; map1; <span class="comment">//不允许key重复</span></span><br><span class="line"><span class="comment">//三种插入方式</span></span><br><span class="line">map<span class="number">1.</span><span class="built_in">insert</span>(&#123; <span class="number">1</span>, <span class="string">&quot;excelent&quot;</span> &#125;);</span><br><span class="line">map<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">100</span>, <span class="string">&quot;寒&quot;</span>));<span class="comment">//打包成pair对</span></span><br><span class="line"><span class="comment">//这里也可以通过emplace()函数，传入参数，直接调用构造函数加入map中</span></span><br><span class="line">map<span class="number">1.</span><span class="built_in">emplace</span>(<span class="number">66</span>, <span class="string">&quot;lucky&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map的operator []</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.查询</span></span><br><span class="line"><span class="comment">* 2.如果key不存在，会插入一对数据[key,string(&quot; &quot;)],因为这里定义的是unordered_map&lt;int, string &gt; map1</span></span><br><span class="line"><span class="comment">* 3.如果给定值，map1[10]=&quot;good&quot;;，会插入一对数据[10,string(&quot;good&quot;)]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">map1[<span class="number">10</span>] = <span class="string">&quot;good&quot;</span>;</span><br><span class="line">cout&lt;&lt;map1[<span class="number">20</span>]&lt;&lt;endl; </span><br><span class="line">cout &lt;&lt; map<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//打印map的大小</span></span><br><span class="line">cout &lt;&lt; map1[<span class="number">10</span>] &lt;&lt; endl; <span class="comment">//访问元素</span></span><br><span class="line"></span><br><span class="line">map<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">10</span>); <span class="comment">//删除指定key的pair对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = map<span class="number">1.f</span>ind(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (it != map<span class="number">1.</span><span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key:  &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;  value:  &quot;</span> &lt;&lt; it-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*两种遍历方式*/</span></span><br><span class="line"><span class="comment">//这里需要返回常引用，普通引用会报错(普通引用可以间接修改容器内部的值，不安全)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> pair&lt;<span class="type">int</span>, string &gt;&amp; m : map1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m.first &lt;&lt;<span class="string">&quot;  &quot;</span> &lt;&lt; m.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = map<span class="number">1.</span><span class="built_in">begin</span>(); it != map<span class="number">1.</span><span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景应用</strong>：<br>统计所有数据的出现次数，打印出现频次大于1的数的值及其出现频次：一般使用unordered_map<br>将给定的大量数据进行去重，仅打印出现1次的数：一般使用unordered_set</p><h2 id="有序容器"><a href="#有序容器" class="headerlink" title="有序容器"></a>有序容器</h2><p>有序容器的基本操作与无序容器的基本操作一致，略有不同的是，有序容器内部会保持元素的顺序（默认是升序）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">student</span>(<span class="type">int</span> id, string name) :<span class="built_in">id_</span>(id), <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> id_;</span><br><span class="line">string name_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;student&gt; set1;</span><br><span class="line">set<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">student</span>(<span class="number">1</span>, <span class="string">&quot;寒&quot;</span>));</span><br><span class="line">set<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">student</span>(<span class="number">2</span>, <span class="string">&quot;宇&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们自定义了一个学生类容器放到set有序集合容器中，报错了</p><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/8aaa3a39458e44b1bef6e3646e83bab0.png"                        alt="在这里插入图片描述"                 ><br>这是因为在自定义的student类中并没有实现小于运算符重载,代码修改如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">student</span>(<span class="type">int</span> id, string name) :<span class="built_in">id_</span>(id), <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> student&amp; stu) <span class="type">const</span><span class="comment">//定义的&lt;运算符重载</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> id_ &lt; stu.id_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> id_;</span><br><span class="line">string name_; </span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> student&amp; stu);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> student&amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;id:&quot;</span> &lt;&lt; stu.id_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; stu.name_ ;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;student&gt; set1;</span><br><span class="line">set<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">student</span>(<span class="number">1</span>, <span class="string">&quot;寒&quot;</span>));</span><br><span class="line">set<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">student</span>(<span class="number">2</span>, <span class="string">&quot;宇&quot;</span>));</span><br><span class="line">set<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">student</span>(<span class="number">3</span>, <span class="string">&quot;哈哈&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = set<span class="number">1.</span><span class="built_in">begin</span>(); it != set<span class="number">1.</span><span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/2f0844ccc8874450b3929f3f974edcfd.png"                        alt="在这里插入图片描述"                 ></p><p><strong>map容器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,student&gt; stuMap;<span class="comment">//如果要使用自定义的类student定义map，要求自定义的类存在默认构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//student(int id, string name) :id_(id), name_(name) &#123;&#125;  这个不行</span></span><br><span class="line"><span class="built_in">student</span>(<span class="type">int</span> id=<span class="number">0</span>, string name=<span class="string">&quot;&quot;</span>) :<span class="built_in">id_</span>(id), <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对应STL容器的总结还不够全面，主要是在我学习过程中遇到的一些知识点进行记录。后序学习过程中遇到了会继续更新。</p>]]></content>
    
    
    <summary type="html">对于STL中常见容器的一个理解</summary>
    
    
    
    <category term="STL模板库" scheme="https://localhost/categories/STL%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    
    
    <category term="c++" scheme="https://localhost/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>LiteHub之文件下载与视频播放</title>
    <link href="https://localhost/undefined/LiteHub_filedownload&amp;&amp;videoplay/"/>
    <id>https://localhost/undefined/LiteHub_filedownload&amp;&amp;videoplay/</id>
    <published>2025-07-10T02:25:32.000Z</published>
    <updated>2025-07-12T05:50:12.573Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><h2 id="前端请求"><a href="#前端请求" class="headerlink" title="前端请求"></a>前端请求</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个箭头函数可以形象理解为，x流入（=&gt;）x*x,</span></span><br><span class="line"><span class="comment">//自然而然=&gt;前面的就是传入参数,=&gt;表示函数体</span></span><br><span class="line">x =&gt; x * x</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果参数不是一个，就需要用括号()括起来：</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br></pre></td></tr></table></figure><p>本项目的请求下载前端代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">downloadFile</span>(<span class="params">resourceId, filename, progressBar, statusText</span>) &#123;</span><br><span class="line">        <span class="title function_">fetch</span>(<span class="string">&#x27;/resource/download&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;,</span><br><span class="line">            <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; resourceId &#125;) <span class="comment">//通过post方式将要下载的文件路径发送给后端</span></span><br><span class="line">        &#125;)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;下载失败&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> contentLength = response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;Content-Length&#x27;</span>);</span><br><span class="line">            <span class="keyword">const</span> total = contentLength ? <span class="built_in">parseInt</span>(contentLength, <span class="number">10</span>) : <span class="number">0</span>;<span class="comment">//返回内容长度</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>(); <span class="comment">//这个可以逐块提供body</span></span><br><span class="line">            <span class="keyword">const</span> chunks = [];</span><br><span class="line">            <span class="keyword">let</span> received = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">pump</span> = (<span class="params"></span>) =&gt; reader.<span class="title function_">read</span>()</span><br><span class="line">              .<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; done, value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;<span class="comment">//如果读取完成，整个文件已下载</span></span><br><span class="line">                <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>(chunks);<span class="comment">//将所有小段chunks转换成一个完成的blob(binary large object)</span></span><br><span class="line">                <span class="keyword">const</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(blob);<span class="comment">//浏览器创建一个临时的URL地址来获取这个数据</span></span><br><span class="line">                <span class="comment">//如blob:http://localhost/17dfc4b1-df34-4a93-a6a7-6df9f1e85e0c</span></span><br><span class="line">                <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                a.<span class="property">href</span> = url;</span><br><span class="line">                a.<span class="property">download</span> = filename;</span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(a);</span><br><span class="line">                a.<span class="title function_">click</span>();<span class="comment">//模拟点击浏览器的下载行为</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">                <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(url);<span class="comment">//避免内存泄露</span></span><br><span class="line"></span><br><span class="line">                progressBar.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line">                statusText.<span class="property">textContent</span> = <span class="string">&#x27;下载完成&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                chunks.<span class="title function_">push</span>(value);</span><br><span class="line">                received += value.<span class="property">length</span>;</span><br><span class="line">                <span class="comment">//更新下载进度</span></span><br><span class="line">                <span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> percent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((received / total) * <span class="number">100</span>);</span><br><span class="line">                progressBar.<span class="property">style</span>.<span class="property">width</span> = percent + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                progressBar.<span class="property">textContent</span> = percent + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                statusText.<span class="property">textContent</span> = <span class="string">`下载中 <span class="subst">$&#123;percent&#125;</span>%`</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                statusText.<span class="property">textContent</span> = <span class="string">`下载中（未知大小）`</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//递归调用 pump（继续读取下一段）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">pump</span>();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">pump</span>();</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;下载出错：&#x27;</span>, error);</span><br><span class="line">            progressBar.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">            statusText.<span class="property">textContent</span> = <span class="string">&#x27;下载失败&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类比</span></span><br><span class="line"><span class="comment">// 后端：用水龙头一点点把水流出来</span></span><br><span class="line"><span class="comment">// 前端：接水并灌到瓶子里（Blob）</span></span><br><span class="line"><span class="comment">// createObjectURL：给这瓶水贴个标签（blob URL）</span></span><br><span class="line"><span class="comment">// 点击下载：把瓶子交给你下载</span></span><br><span class="line"><span class="comment">// revokeObjectURL：把标签撕掉，清理内存</span></span><br></pre></td></tr></table></figure><p>对于<code>pump</code>函数的理解，结合箭头函数和<code>promise</code></p><ol><li>reader.read()<br> ○ 返回一个 Promise&lt;{ done: boolean, value: Uint8Array }&gt;。<br> ○ done: true 表示读取完了；<br> ○ value 是当前读取的一段数据（Uint8Array 格式）。</li><li>箭头函数 () &#x3D;&gt; reader.read().then(…)<br>○  这是一个返回 Promise 的函数。<br>○ done: true 表示读取完了；<br>○ value 是当前读取的一段数据（Uint8Array 格式）。</li><li>箭头函数 () &#x3D;&gt; reader.read().then(({ done, value }) &#x3D;&gt; { return dump()}<br> ■ ()&#x3D;&gt;reader.read(),无参数传入，执行reader.read()，返回reader.read()执行的结果{done,value}。<br> ■ .then({ done, value })通过上一步接收这两个数据，然后通过这两个执行相应内容；<br> ■ 如果done为false，表示还没执行完成，chunks.push(value)：把这一段加入缓存  ，更新进度条， 递归调用自身，继续下一段读取  （return pump()）。</li></ol><h3 id="后端响应"><a href="#后端响应" class="headerlink" title="后端响应"></a>后端响应</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">FileUtil <span class="title">file</span><span class="params">(filePath)</span></span>; </span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">isValid</span>()) <span class="comment">//判断请求的文件是否有效</span></span><br><span class="line">&#123;</span><br><span class="line">    LOG_WARN &lt;&lt; filePath &lt;&lt; <span class="string">&quot;not exist.&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k404NotFound, <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    resp-&gt;<span class="built_in">setContentType</span>(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">    std::string resp_info=<span class="string">&quot;File not found&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">setContentLength</span>(resp_info.<span class="built_in">size</span>());</span><br><span class="line">    resp-&gt;<span class="built_in">setBody</span>(resp_info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置相应头</span></span><br><span class="line">resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k200Ok, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">resp-&gt;<span class="built_in">setCloseConnection</span>(<span class="literal">false</span>);</span><br><span class="line">resp-&gt;<span class="built_in">setContentType</span>(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::string filename = std::filesystem::<span class="built_in">path</span>(filePath).<span class="built_in">filename</span>().<span class="built_in">string</span>();</span><br><span class="line">LOG_INFO&lt;&lt;<span class="string">&quot;filename:&quot;</span>&lt;&lt;filename;</span><br><span class="line">resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + filename + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//设置响应格式为文件类型，并添加文件的路径</span></span><br><span class="line">resp-&gt;<span class="built_in">setContentLength</span>(file.<span class="built_in">size</span>());</span><br><span class="line">resp-&gt;<span class="built_in">setisFileResponse</span>(filePath);</span><br></pre></td></tr></table></figure><h3 id="设计亮点"><a href="#设计亮点" class="headerlink" title="设计亮点"></a>设计亮点</h3><p>在<code>HttpResponse.h</code>头文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFileResponse</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> isFileResponse_;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getFilePath</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> filePath_;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setisFileResponse</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         isFileResponse_ = <span class="literal">true</span>;</span><br><span class="line">         filePath_ = path;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span>                               isFileResponse_; <span class="comment">//判断是否是文件，如果是，采用流式发送</span></span><br><span class="line">std::string                        filePath_;</span><br></pre></td></tr></table></figure><p>在httpserver的请求函数中判断，如果是文件类型，就调用tcpconnection先将响应头发送出去，然后将消息体分小块发送，这里设置的是8kb；如果不是文件类型，直接将整个响应发送出去<br>在<code>HttpServer::onRequest</code>函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给response设置一个成员，判断是否请求的是文件，如果是文件设置为true，并且存在文件位置在这里send出去。</span></span><br><span class="line"><span class="keyword">if</span> (!response.<span class="built_in">isFileResponse</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不是文件类型</span></span><br><span class="line">    muduo::net::Buffer buf;</span><br><span class="line">    response.<span class="built_in">appendToBuffer</span>(&amp;buf);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(&amp;buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 1. 构造响应头</span></span><br><span class="line">    muduo::net::Buffer headerBuf;</span><br><span class="line">    response.<span class="built_in">appendToBuffer</span>(&amp;headerBuf);  <span class="comment">// 只添加状态行和头部，不包含 body</span></span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(&amp;headerBuf);  <span class="comment">// 先发 header</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 发送文件内容（分块）</span></span><br><span class="line">    <span class="type">const</span> std::string filePath = response.<span class="built_in">getFilePath</span>();</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filePath, std::ios::binary)</span></span>;<span class="comment">// 以二进制模式打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> bufferSize = <span class="number">8192</span>; <span class="comment">// 8KB 缓冲区</span></span><br><span class="line">        <span class="type">char</span> buffer[bufferSize];                  <span class="comment">// 栈上分配缓冲区</span></span><br><span class="line">        <span class="keyword">while</span> (file) &#123;                            <span class="comment">// 循环直到文件读取结束或出错</span></span><br><span class="line">            file.<span class="built_in">read</span>(buffer, bufferSize);        <span class="comment">// 读取最多 bufferSize 字节到 buffer</span></span><br><span class="line">            std::streamsize bytesRead = file.<span class="built_in">gcount</span>(); <span class="comment">// 实际读取的字节数</span></span><br><span class="line">            <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                conn-&gt;<span class="built_in">send</span>(muduo::<span class="built_in">StringPiece</span>(buffer, bytesRead));<span class="comment">// 发送数据块</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件打不开，补偿错误提示</span></span><br><span class="line">        muduo::net::Buffer errBuf;</span><br><span class="line">        errBuf.<span class="built_in">append</span>(<span class="string">&quot;HTTP/1.1 500 Internal Server Error\r\n\r\nFile open failed&quot;</span>);</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(&amp;errBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以是在httpserver上分块发送数据流，是为了保证代码较好的层次性，httpserver负责管理多个tcp连接，包括发送消息和接收消息等。</p><h1 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 从请求中获取 Range 头，例如 &quot;bytes=1000-2000&quot;</span></span><br><span class="line">    std::string rangeHeader = req.<span class="built_in">getHeader</span>(<span class="string">&quot;Range&quot;</span>);</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;Range Header: &quot;</span> &lt;&lt; rangeHeader;</span><br><span class="line">    <span class="comment">// 默认起始字节 start=0，结束字节 end=文件大小-1，表示完整文件</span></span><br><span class="line">    std::streamsize start = <span class="number">0</span>, end = fileSize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标记是否是分块响应</span></span><br><span class="line">    <span class="type">bool</span> isPartial = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!rangeHeader.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果客户端带了 Range，则标记为分块传输</span></span><br><span class="line">        isPartial = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> s = <span class="number">0</span>, e = <span class="number">-1</span>;</span><br><span class="line">         <span class="comment">// 使用 sscanf 解析格式 bytes=&lt;start&gt;-&lt;end&gt;</span></span><br><span class="line">        <span class="comment">// 注意：用户可能只写了起始，没有写结束，所以要判断 sscanf 返回值</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">sscanf</span>(rangeHeader.<span class="built_in">c_str</span>(), <span class="string">&quot;bytes=%ld-%ld&quot;</span>, &amp;s, &amp;e);</span><br><span class="line">        start = s;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || e == <span class="number">-1</span>) &#123;<span class="comment">// 如果只解析到 1 个数，或者结束为 -1，则表示读到文件末尾</span></span><br><span class="line">            end = fileSize - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解析到两个数，且结束不能超过文件大小</span></span><br><span class="line">            end = std::<span class="built_in">min</span>((std::streamsize)e, fileSize - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 合法性检查：start 必须小于等于 end 且小于文件大小</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end || start &gt;= fileSize) &#123;</span><br><span class="line">            <span class="comment">// 如果不合法，返回 416 状态码（Requested Range Not Satisfiable）</span></span><br><span class="line">            resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k416RequestedRangeNotSatisfiable, <span class="string">&quot;Requested Range Not Satisfiable&quot;</span>);</span><br><span class="line">            <span class="type">char</span> rangeValue[<span class="number">64</span>];</span><br><span class="line">            <span class="comment">// Content-Range 必须带 &quot;*/总大小&quot;</span></span><br><span class="line">            <span class="built_in">snprintf</span>(rangeValue, <span class="built_in">sizeof</span>(rangeValue), <span class="string">&quot;bytes */%ld&quot;</span>, fileSize);</span><br><span class="line">            resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Content-Range&quot;</span>, rangeValue);</span><br><span class="line">            resp-&gt;<span class="built_in">setCloseConnection</span>(<span class="literal">true</span>);</span><br><span class="line">            resp-&gt;<span class="built_in">setContentType</span>(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            resp-&gt;<span class="built_in">setBody</span>(<span class="string">&quot;Invalid Range&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算需要读取的 chunkSize</span></span><br><span class="line">    std::streamsize chunkSize = end - start + <span class="number">1</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(chunkSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要分块，最好这里限制一下 chunkSize，防止内存过大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到要读的起始位置</span></span><br><span class="line">    file.<span class="built_in">seekg</span>(start, std::ios::beg);</span><br><span class="line">    <span class="comment">// 从文件读出 chunkSize 大小的数据到 buffer</span></span><br><span class="line">    file.<span class="built_in">read</span>(buffer.<span class="built_in">data</span>(), chunkSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 构造响应 ===</span></span><br><span class="line">    <span class="keyword">if</span> (isPartial) &#123;</span><br><span class="line">        resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k206PartialContent, <span class="string">&quot;Partial Content&quot;</span>);</span><br><span class="line">        <span class="type">char</span> rangeHeaderValue[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(rangeHeaderValue, <span class="built_in">sizeof</span>(rangeHeaderValue),</span><br><span class="line">                <span class="string">&quot;bytes %ld-%ld/%ld&quot;</span>, start, end, fileSize);</span><br><span class="line">        resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Content-Range&quot;</span>, rangeHeaderValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k200Ok, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Accept-Ranges&quot;</span>, <span class="string">&quot;bytes&quot;</span>);<span class="comment">// 无论是否分块，都要告知支持分块</span></span><br><span class="line">    resp-&gt;<span class="built_in">setContentType</span>(<span class="string">&quot;video/mp4&quot;</span>);         <span class="comment">// 设置内容类型为 mp4 视频</span></span><br><span class="line">    resp-&gt;<span class="built_in">setContentLength</span>(buffer.<span class="built_in">size</span>());     <span class="comment">// 设置 Content-Length</span></span><br><span class="line">    resp-&gt;<span class="built_in">setBody</span>(std::<span class="built_in">string</span>(buffer.<span class="built_in">begin</span>(), buffer.<span class="built_in">end</span>()));  <span class="comment">// 把读取的文件块设置到响应体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端涉及对请求体中的range字段进行解析，判断range字段的合法性，随后根据range字段请求内容决定是返回部分内容还是全部内容。<br><strong>请求所有内容：</strong><br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/ee7976fbdf5f41038547b48512e08171.png"                        alt="在这里插入图片描述"                 ><br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/7df5f3d2072d4f6aa8130d09a8d2e533.png"                        alt="在这里插入图片描述"                 ><br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/83a40f17377044c5a56c3d1d9dbcaaf4.png"                        alt="在这里插入图片描述"                 ><br>依次拖动播放进度条，range字段发生改变，格式为<start>–<end>字段，这里是请求从某一时刻到视频结束。<br><strong>请求部分内容：</strong><br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/4f0a75336d8b4506af21d2252f8401e1.png"                        alt="在这里插入图片描述"                 ><br>这里请求的是从字节6000-18000大小的数据，返回的响应为<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/15b86b0e768f43098a4f93fe16619642.png"                        alt="在这里插入图片描述"                 ><br>这里的响应头字段为<code>206 partial content</code>,表示响应返回的只是视频的一部分数据。</p><hr><p><strong>range的合法性校验</strong><br>这里我手动指定range的范围为<code>6000-18000000000000</code>，实际是超出了请求视频的最大范围，看看最后返回的什么。使用curl（这里因为是测试，所以去掉了权限的判定，实际上运行的时候使用curl是不可行的）<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/57982f440f6c48c88d496051ce9a7004.png"                        alt="在这里插入图片描述"                 ><br>可以看到这里返回的是文件的最大大小。</p>]]></content>
    
    
    <summary type="html">这是LiteHub的环境配置系列命令。</summary>
    
    
    
    <category term="Http后端服务器" scheme="https://localhost/categories/Http%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="后端" scheme="https://localhost/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>LiteHub之数据库连接池</title>
    <link href="https://localhost/undefined/LiteHub_databasepool/"/>
    <id>https://localhost/undefined/LiteHub_databasepool/</id>
    <published>2025-07-09T02:27:52.000Z</published>
    <updated>2025-07-12T05:50:06.528Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><h3 id="不使用数据库连接池"><a href="#不使用数据库连接池" class="headerlink" title="不使用数据库连接池"></a>不使用数据库连接池</h3><p>我们先来看看普通的Mysql的连接过程，下图是我抓包分析的在端口3306的数据包：<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/00ccb843634f426f8d9e626e21862ef5.png"                        alt="在这里插入图片描述"                 ><br>在执行Mysql命令之前，需要先经过Tcp的三次握手、Mysql的认证服务，TLS加密服务等操作；<br>下图来自<a class="link"   href="https://blog.csdn.net/CrankZ/article/details/82874158" >数据库连接池学习笔记（一）：原理介绍+常用连接池介绍<i class="fas fa-external-link-alt"></i></a><br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/89e3aedfb8d74ed0a7c3df83cd79c296.png"                        alt="在这里插入图片描述"                 ><br>经过上述分析，我们知道，如果不使用数据库连接池，执行单条Mysql命令会多了非常多我们不关心的网络交互。<br>如果执行的Mysql查询命令比较多，就会严重影响性能。</p><blockquote><p>不使用数据库连接池：<br><strong>优点</strong>： 实现简单<br><strong>缺点</strong>： 网络IO较多<br>数据库的负载较高<br>响应时间较长及QPS较低<br>应用频繁的创建连接和关闭连接，导致临时对象较多<br>在关闭连接后，会出现大量TIME_WAIT 的TCP状态（在2个MSL之后关闭）</p></blockquote><h3 id="使用数据库连接池"><a href="#使用数据库连接池" class="headerlink" title="使用数据库连接池"></a>使用数据库连接池</h3><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/0e89367c1d894d8bb9f18c93dfb68773.png"                        alt="在这里插入图片描述"                 ></p><p><strong>初始连接建立</strong><br>当应用程序第一次访问数据库时，需要完成以下步骤：</p><ol><li>系统会创建一个新的数据库连接</li><li>这个连接需要经过身份验证(用户名&#x2F;密码验证)</li><li>建立TCP&#x2F;IP网络连接</li><li>初始化会话参数和设置</li></ol><p><strong>连接复用机制</strong><br>在后续访问中：</p><ol><li>系统会从连接池中获取先前建立的可用连接</li><li>直接使用该连接执行SQL语句(如SELECT, INSERT, UPDATE等)</li><li>执行过程中无需重新进行身份验证和连接建立</li><li>典型的复用场景包括：<ul><li>用户多次查询同一数据表</li><li>处理事务中的多个SQL操作</li><li>执行批量数据处理任务</li></ul></li></ol><p><strong>连接回收过程</strong></p><p>每次查询完成后：</p><ol><li>系统会将连接标记为”空闲”状态</li><li>连接会被归还到连接池中</li><li>连接保持开启状态，等待下次请求</li><li>如果连接空闲时间超过配置的阈值(如30分钟)，可能会被自动关闭</li></ol><p>这种机制显著提高了性能，减少了频繁创建和销毁连接的开销。</p><h3 id="常见的几种资源池"><a href="#常见的几种资源池" class="headerlink" title="常见的几种资源池"></a>常见的几种资源池</h3><p>在实际应用中，由于创建和销毁系统资源（如连接、内存块、线程等）的成本往往远高于使用资源的成本，因此通常会引入资源池的概念来提高系统性能。这种技术通过预先创建并维护一组可重用资源，避免了频繁的资源初始化和销毁操作，从而显著提升系统效率。</p><p>常见的资源池包括以下几种类型：</p><ol><li><p><strong>内存池</strong>：</p><ul><li>在C++程序开发中，malloc通过brk()系统调用向操作系统申请内存时，会一次性申请较大的内存块（只是通过brk方式申请的内存会维护内存池，小块内存；通过nmap方式申请的大块内存（默认是大于128k）没有内存池，是直接归还给操作系统了）</li><li>当使用free释放内存时，这些内存并不会立即归还给操作系统，而是被缓存在malloc维护的内存池中</li><li>当下次程序再次申请内存时，malloc会优先从内存池中分配可用内存块</li><li>例如：当程序频繁进行小内存块的分配和释放时，内存池可以避免频繁的系统调用，提高内存分配效率</li></ul></li><li><p><strong>线程池</strong>：</p><ul><li>传统的线程创建和销毁涉及操作系统层面的资源分配和回收，开销较大</li><li>线程池通过预先创建一组线程并保持活跃状态，等待任务分配</li><li>主要优势包括：<ul><li>线程复用：避免频繁创建销毁线程的开销</li><li>任务解耦：将任务提交与执行分离，提高系统灵活性</li><li>资源管理：可以限制并发线程数量，防止系统过载</li></ul></li><li>应用场景：Web服务器处理请求、批量数据处理等需要高并发的场景</li></ul></li><li><p><strong>数据库连接池</strong>：</p><ul><li>建立数据库连接涉及网络通信、身份验证等耗时操作</li><li>连接池维护一组已建立的数据库连接，应用程序使用时直接从池中获取</li><li>使用完毕后连接归还池中而非关闭，供其他请求复用</li><li>典型配置参数包括：最小连接数、最大连接数、连接超时时间等</li><li>优势：显著降低连接建立开销，提高数据库访问效率</li></ul></li></ol><p>这些资源池技术在现代软件系统中被广泛应用，特别是在高并发、高性能要求的场景下，合理配置资源池可以大幅提升系统整体性能。在实际应用中，由于创建和销毁系统资源（如连接、内存块、线程等）的成本往往远高于使用资源的成本，因此通常会引入资源池的概念来提高系统性能。这种技术通过预先创建并维护一组可重用资源，避免了频繁的资源初始化和销毁操作，从而显著提升系统效率。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>本项目数据库连接池实现了三个核心类：</p><ul><li><code>DbConnection</code>：管理单个数据库连接</li><li><code>DbConnectionPool</code>：管理数据库连接池</li><li><code>MysqlUtil</code>：提供便捷的数据库操作接口</li></ul><p>以下就分别来了解一下这几个类的实现。</p><h3 id="DbConnection类实现"><a href="#DbConnection类实现" class="headerlink" title="DbConnection类实现"></a>DbConnection类实现</h3><p><strong>成员变量</strong>：</p><ul><li><code>std::shared_ptr&lt;sql::Connection&gt; conn_</code> 数据库连接</li><li><code>std::string    host_</code>   数据库主机地址，如tcp:&#x2F;&#x2F;127.0.0.1:3306</li><li><code>std::string    user_</code>    用户名</li><li><code>std::string  password_</code>  密码</li><li><code>std::string database_</code>  使用数据库</li><li><code>std::mutex  mutex_</code>    互斥锁</li></ul><p><strong>成员方法</strong>：</p><ul><li><code>DbConnection()</code>构造函数, 创建并初始化数据库连接，设置连接属性（这里是设置的单语句执行，防止SQL的注入）</li><li><code>~DbConnection()</code>析构函数，自动清理连接资源，调用cleanup()函数</li><li><code>ping()</code>函数，使用简单的<code>SELECT 1</code>语句检测与数据库的通信是否正常</li><li><code>isValid()</code>函数，与ping函数类似，区别在于不在意查询结果，遇到异常返回false</li><li><code>reconnect()</code> 函数，尝试重新建立数据库连接</li><li><code>cleanup()</code>函数，清理连接状态，需要确保所有事务以及完成，并且消费完所有查询结果</li><li><code>bindParams()</code>,绑定参数</li><li><code>executeQuery()</code>函数，执行sql语句的查询，并返回查询结果</li><li><code>executeUpdate()</code>函数，执行sql语句的更新操作</li></ul><p>在上述函数中比较重要的就是<code>executeQuery()</code>和<code>executeUpdate()</code>函数，以下是其代码定义与注释</p><p><strong>executeQuery()函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="comment">//可变参数模板，接受任意数量、任意类型的参数</span></span><br><span class="line"><span class="function">sql::ResultSet* <span class="title">executeQuery</span><span class="params">(<span class="type">const</span> std::string&amp; sql, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;  <span class="comment">// 确保线程安全</span></span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接创建新的预处理语句，不使用缓存</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;sql::PreparedStatement&gt; <span class="title">stmt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            conn_-&gt;prepareStatement(sql)</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="built_in">bindParams</span>(stmt.<span class="built_in">get</span>(), <span class="number">1</span>, std::forward&lt;Args&gt;(args)...); <span class="comment">// 绑定参数,std::forward 确保完美转发</span></span><br><span class="line">        <span class="keyword">return</span> stmt-&gt;<span class="built_in">executeQuery</span>(); <span class="comment">//执行后返回 sql::ResultSet*</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> sql::SQLException&amp; e) </span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;Query failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;, SQL: &quot;</span> &lt;&lt; sql;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DbException</span>(e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是执行Sql查询的操作，在上层，通过代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string sql = <span class="string">&quot;SELECT id FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line">sql::ResultSet* res = mysqlUtil_.<span class="built_in">executeQuery</span>(sql, username, password);</span><br></pre></td></tr></table></figure><p>传入了sql语句：”SELECT id FROM users WHERE username &#x3D; ? AND password &#x3D; ?”<br>以及两个参数：username&#x3D;”<code>user1</code>“和password&#x3D;”<code>123456</code>“；<br>通过参数绑定后，完整的sql语句就是<br>“SELECT id FROM users WHERE username &#x3D; user1 AND password &#x3D;123456”<br>随后执行Mysql的语句查询，返回查询到的结果。</p><p><strong>executeUpdate函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="type">const</span> std::string&amp; sql, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 直接创建新的预处理语句，不使用缓存</span></span><br><span class="line">            <span class="function">std::unique_ptr&lt;sql::PreparedStatement&gt; <span class="title">stmt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                conn_-&gt;prepareStatement(sql)</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>;</span><br><span class="line">            <span class="built_in">bindParams</span>(stmt.<span class="built_in">get</span>(), <span class="number">1</span>, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">return</span> stmt-&gt;<span class="built_in">executeUpdate</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> sql::SQLException&amp; e) </span><br><span class="line">        &#123;</span><br><span class="line">            LOG_ERROR &lt;&lt; <span class="string">&quot;Update failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;, SQL: &quot;</span> &lt;&lt; sql;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">DbException</span>(e.<span class="built_in">what</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>示例语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::string sql = <span class="string">&quot;INSERT INTO video_stats (video_name, view_count, like_count) VALUES (?, 0, 0) ON DUPLICATE KEY UPDATE video_name=video_name&quot;</span>;</span><br><span class="line"><span class="type">int</span> affected = mysqlUtil_.<span class="built_in">executeUpdate</span>(sql, video_name);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>SQL注入的理解</strong>：<br>当用户登录网站时，通常会输入用户名和密码。<br>以下是一段正常的 SQL 查询代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = <span class="string">&#x27;user1&#x27;</span> AND password = <span class="string">&#x27;password1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果攻击者输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名： admin<span class="string">&#x27; --</span></span><br><span class="line"><span class="string">密码： anything</span></span><br></pre></td></tr></table></figure><p>SQL查询变成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = <span class="string">&#x27;admin&#x27;</span> --<span class="string">&#x27; AND password = &#x27;</span>anything<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure><p>其中 – 是 SQL 的注释符号，忽略了密码条件，直接绕过了身份验证。<br>更多可以参考<br><a class="link"   href="https://www.runoob.com/sql/sql-injection.html" >SQL 注入<i class="fas fa-external-link-alt"></i></a></p><h3 id="DbConnectionPool类实现"><a href="#DbConnectionPool类实现" class="headerlink" title="DbConnectionPool类实现"></a>DbConnectionPool类实现</h3><p>成员变量：</p><ul><li><code>std::string     host_</code>; 连接数据库的主机名</li><li><code>std::string     user_;</code> 用户名</li><li><code>std::string     password_;</code> 密码</li><li><code>std::string    database_;</code> 指定使用的数据库</li><li><code>std::queue&lt;std::shared_ptr&lt;DbConnection&gt;&gt; connections_;</code> 数据库连接池</li><li><code>std::mutex    mutex_;</code> 互斥锁</li><li><code>std::condition_variable   cv_;</code> 条件变量</li><li><code>bool       initialized_ = false;</code>   初始化标识,确保仅初始化一次</li><li><code>std::thread    checkThread_;</code> &#x2F;&#x2F; 添加检查线程，检测数据库连接池的连接健康状况</li></ul><p>成员方法：<br>使用单例模式，</p><ul><li><code>init()</code>函数，初始化线程池，创建 poolSize 个 DbConnection 对象，放入队列</li><li><code>DbConnectionPool()</code>构造函数，创建并分离后台线程，定期检查连接可用性</li><li><code>~DbConnectionPool()</code>析构函数，清空连接队列，释放所有连接资源</li><li><code>getConnection()</code> 函数，从连接池获取一个可用连接</li><li><code>createConnection()</code> 函数，创建一个新的数据库连接</li><li><code>checkConnections()</code> ，后台线程，定期检查所有连接是否可用。</li></ul><p>这里比较重要的就是<code>getConnection()</code> 函数，我贴出来代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;DbConnection&gt; <span class="title">DbConnectionPool::getConnection</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;DbConnection&gt; conn;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="comment">// 如果连接池为空，则阻塞等待其他线程释放连接</span></span><br><span class="line">        <span class="keyword">while</span> (connections_.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initialized_) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">DbException</span>(<span class="string">&quot;Connection pool not initialized&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            LOG_INFO &lt;&lt; <span class="string">&quot;Waiting for available connection...&quot;</span>;</span><br><span class="line">            cv_.<span class="built_in">wait</span>(lock);  <span class="comment">// 等待条件变量通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从队列中取一个连接</span></span><br><span class="line">        conn = connections_.<span class="built_in">front</span>();</span><br><span class="line">        connections_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; <span class="comment">// 释放锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在锁外检查连接</span></span><br><span class="line">        <span class="keyword">if</span> (!conn-&gt;<span class="built_in">ping</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">&quot;Connection lost, attempting to reconnect...&quot;</span>;</span><br><span class="line">            conn-&gt;<span class="built_in">reconnect</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用自定义 deleter：</span></span><br><span class="line">        <span class="comment">// 当外部 shared_ptr 被释放时，把连接放回连接池并通知等待线程</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;DbConnection&gt;(conn.<span class="built_in">get</span>(), </span><br><span class="line">            [<span class="keyword">this</span>, conn](DbConnection*) &#123;</span><br><span class="line">                std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex_);</span><br><span class="line">                connections_.<span class="built_in">push</span>(conn);</span><br><span class="line">                cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 如果重连失败，则把连接放回队列并通知等待线程</span></span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;Failed to get connection: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            connections_.<span class="built_in">push</span>(conn);</span><br><span class="line">            cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数的核心逻辑为：</p><ul><li>如果连接池为空，则阻塞等待（使用条件变量）</li><li>连接池始终返回 <code>std::shared_ptr&lt;DbConnection&gt;</code></li><li>通过自定义的deleter在用户使用完数据库某条连接后自动归还给池<br>使用lambda表达式，当conn使用完成后，将其归还到connections_池中去。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义 deleter：</span></span><br><span class="line"> <span class="comment">// 当外部 shared_ptr 被释放时，把连接放回连接池并通知等待线程</span></span><br><span class="line"> <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;DbConnection&gt;(conn.<span class="built_in">get</span>(), </span><br><span class="line">     [<span class="keyword">this</span>, conn](DbConnection*) &#123;</span><br><span class="line">         std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex_);</span><br><span class="line">         connections_.<span class="built_in">push</span>(conn);</span><br><span class="line">         cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><h3 id="MysqlUtil类实现"><a href="#MysqlUtil类实现" class="headerlink" title="MysqlUtil类实现"></a>MysqlUtil类实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> std::string&amp; host, <span class="type">const</span> std::string&amp; user,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> std::string&amp; password, <span class="type">const</span> std::string&amp; database,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> poolSize = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//调用了 DbConnectionPool 的单例模式，保证全局唯一</span></span><br><span class="line">    http::db::DbConnectionPool::<span class="built_in">getInstance</span>().<span class="built_in">init</span>(</span><br><span class="line">        host, user, password, database, poolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">sql::ResultSet* <span class="title">executeQuery</span><span class="params">(<span class="type">const</span> std::string&amp; sql, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//对外提供 执行查询（SELECT） 的接口</span></span><br><span class="line">    <span class="comment">//使用者不需要显式创建 DbConnection，也不用关心 getConnection 和归还连接的逻辑</span></span><br><span class="line">    <span class="keyword">auto</span> conn = http::db::DbConnectionPool::<span class="built_in">getInstance</span>().<span class="built_in">getConnection</span>();</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;<span class="built_in">executeQuery</span>(sql, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="type">const</span> std::string&amp; sql, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//对外提供 执行更新（INSERT / UPDATE / DELETE） 的接口</span></span><br><span class="line">    <span class="keyword">auto</span> conn = http::db::DbConnectionPool::<span class="built_in">getInstance</span>().<span class="built_in">getConnection</span>();</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;<span class="built_in">executeUpdate</span>(sql, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MysqlUtil类的实现比较简单，提供了对数据库的简单接口，隐藏了底层连接池的复杂性。主要是提供了三个方法，分别是数据库连接池的初始化、从连接池中获取连接以执行查询操作和更新（增删改）操作。MysqlUtil作为一个便捷的工具类，简化了调用接口，让业务层可以更轻松的使用连接池进行增删改查的工作。</p><p>以上就是我对数据库连接池的一些理解，如有不当之处，敬请指出。</p>]]></content>
    
    
    <summary type="html">在实际应用中，由于创建和销毁系统资源（如连接、内存块、线程等）的成本往往远高于使用资源的成本，因此通常会引入资源池的概念来提高系统性能。这种技术通过预先创建并维护一组可重用资源，避免了频繁的资源初始化和销毁操作，从而显著提升系统效率。本小节我们着重介绍数据库线程池的概念。</summary>
    
    
    
    <category term="Http后端服务器" scheme="https://localhost/categories/Http%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="后端" scheme="https://localhost/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="https://localhost/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LiteHub之gzip压缩算法</title>
    <link href="https://localhost/undefined/LiteHub_gzip/"/>
    <id>https://localhost/undefined/LiteHub_gzip/</id>
    <published>2025-07-05T02:28:46.000Z</published>
    <updated>2025-07-12T05:50:16.031Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><blockquote><p>gzip是一种无损压缩算法，其基础为Deflate，Deflate是LZ77与哈弗曼编码的一个组合体。它的基本原理是：对于要压缩的文件，首先使用LZ77算法的一个变种进行压缩，对得到的结果再使用哈夫曼编码（根据情况，使用静态哈弗曼编码或动态哈夫曼编码）的方法进行压缩。</p></blockquote><h3 id="LZ777算法"><a href="#LZ777算法" class="headerlink" title="LZ777算法"></a>LZ777算法</h3><p>几个术语</p><ul><li>等待编码区</li><li>搜索缓冲区（已经编码的区域）</li><li>滑动窗口（指定大小，包括“搜索缓冲区”和“待编码区”）</li></ul><p>具体的编码过程：<br>接下来，介绍具体的编码过程：<br>　　为了编码待编码区， 编码器在滑动窗口的搜索缓冲区查找直到找到匹配的字符串。匹配字符串的开始字符串与待编码缓冲区的距离称为“偏移值”，匹配字符串的长度称为“匹配长度”。<br>　　编码器在编码时，会一直在搜索区中搜索，直到找到最大匹配字符串，并输出(o, l )，其中o是偏移值， l是匹配长度。然后窗口滑动l，继续开始编码。<br>　　如果没有找到匹配字符串，则输出(0, 0, c)，c为待编码区下一个等待编码的字符，窗口滑动“1”。</p><p>参考文章：<a class="link"   href="https://www.cnblogs.com/junyuhuang/p/4138376.html" >LZ77压缩算法编码原理详解(结合图片和简单代码)<i class="fas fa-external-link-alt"></i></a></p><p>下面我们以字符串“<code>abababc</code>”为例，来了解其编码过程：</p><p>假设滑动窗口的大小足够大(LZ777设置的滑动窗口是32k)，可以覆盖整个字符串。</p><p><strong>第一步</strong>：<br>&emsp;待编码区：abababc<br>&emsp;搜索缓冲区：（初始为空）<br>&emsp;操作：搜索缓冲区为空，无法找到匹配字符串。<br>&emsp;输出：(0, 0, a)（表示没有找到匹配，输出字符a）<br>&emsp;窗口滑动：窗口向右滑动1个字符。<br>&emsp;结果：a已经被编码，剩下bababc。<br><strong>第二步</strong>：<br>&emsp;待编码区：bababc<br>&emsp;搜索缓冲区：a（已经编码的部分）<br>&emsp;操作：在搜索缓冲区中查找b的匹配。搜索缓冲区中没有b。<br>&emsp;输出：(0, 0, b)（表示没有找到匹配，输出字符b）<br>&emsp;窗口滑动：窗口向右滑动1个字符。<br>&emsp;结果：ab已经被编码，剩下ababc。<br><strong>第三步</strong>：<br>&emsp;待编码区：ababc<br>&emsp;搜索缓冲区：ab（已经编码的部分）<br>&emsp;操作：在搜索缓冲区中查找ab的匹配。搜索缓冲区中存在ab，匹配长度为2。<br>&emsp;输出：(2, 2)（表示匹配长度为2，偏移值为2）<br>&emsp;窗口滑动：窗口向右滑动2个字符。<br>&emsp;结果：abab已经被编码，剩下abc。<br><strong>第四步</strong>：<br>&emsp;待编码区：abc<br>&emsp;搜索缓冲区：abab（已经编码的部分）<br>&emsp;操作：在搜索缓冲区中查找ab的匹配。搜索缓冲区中存在ab，匹配长度为2。<br>&emsp;输出：(4, 2)（表示匹配长度为2，偏移值为4）<br>&emsp;窗口滑动：窗口向右滑动2个字符。<br>&emsp;结果：ababab已经被编码，剩下c。<br><strong>第五步</strong>：<br>&emsp;待编码区：c<br>&emsp;搜索缓冲区：ababab（已经编码的部分）<br>&emsp;操作：在搜索缓冲区中查找c的匹配。搜索缓冲区中没有c。<br>&emsp;输出：(0, 0, c)（表示没有找到匹配，输出字符c）<br>&emsp;窗口滑动：窗口向右滑动1个字符。<br>&emsp;结果：整个字符串已经编码完成。</p><p><strong>最终编码结果</strong><br>&emsp;经过上述步骤，字符串abababc的LZ77编码结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">0</span>, a) (<span class="number">0</span>, <span class="number">0</span>, b) (<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>) (<span class="number">0</span>, <span class="number">0</span>, c)</span><br></pre></td></tr></table></figure><p>使用<a class="link"   href="https://www.cnblogs.com/junyuhuang/p/4138376.html" >LZ77压缩算法编码原理详解(结合图片和简单代码)<i class="fas fa-external-link-alt"></i></a>给定的代码的编码结果是<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/fec766beb7344418952a7b715d53c1ea.png"                        alt="在这里插入图片描述"                 ><br>说明上述编码过程分析正确！！！</p><p>上面的如(0, 0, a)这个其实根本不用写偏移和匹配长度，保留为原字符‘a’，占的编码长度还更短一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">0</span>, a) (<span class="number">0</span>, <span class="number">0</span>, b) (<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>) (<span class="number">0</span>, <span class="number">0</span>, c)</span><br></pre></td></tr></table></figure><p>变为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ab</span>(<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>)c</span><br></pre></td></tr></table></figure><h3 id="霍夫曼编码算法"><a href="#霍夫曼编码算法" class="headerlink" title="霍夫曼编码算法"></a>霍夫曼编码算法</h3><p>霍夫曼编码是一种基于字符频率的变长编码方法，通过构建霍夫曼树来为每个字符分配一个唯一的二进制编码。霍夫曼树的构建过程依赖于字符的频率，频率越高的字符通常会被分配较短的编码。<br>首先我们统计”<code>abababc</code>“中每一个字符出现的频率，如下所示</p><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">c</th></tr></thead><tbody><tr><td align="center">3</td><td align="center">3</td><td align="center">1</td></tr></tbody></table><p>根据霍夫曼编码的规则，我们需要按照字符频率从低到高构建霍夫曼树。以下是构建过程：</p><ol><li>将字符串出现的频率视为优先级，放入一个最小优先队列中：</li></ol><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/66beb0047e2b4dcc946eab5d59ab0559.png"                        alt="在这里插入图片描述"                 ></p><ol start="2"><li>然后弹出两个优先级最低的字符作为子节点, 构造出第一个二叉树; 父节点的优先级视为两个字节优先级之和, 然后把父节点插入队列中:<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/9488cb0dd1ed4da19e59aa5f48a6253d.png"                        alt="在这里插入图片描述"                 ></li><li>重复这个操作, 最后我们会得到一颗二叉树. 这便是 Huffman编码 树.</li></ol><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/55978a3216824675b8365a88eade715c.png"                        alt="在这里插入图片描述"                 ><br>4.  我们把这棵树的左支编码为 0, 右支编码为 1, 那么从根节点向下遍历到叶子节点, 即可得出相应字符的 Huffman 编码. 因此我们得到上面例子的 Huffman 编码表为:<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/9b87beeda7f94b32b341d27d9c89286e.png"                        alt="在这里插入图片描述"                 ></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">01</span></span><br><span class="line">c:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>现在对字符串中出现的频率都做了一个统计，只需要解决偏移量和匹配长度的编码就可以了。</p><p> DEFLATE 算法对偏移距离和匹配长度已经做了一个统计，见下表：<br> <strong>偏移距离</strong>：<br> 它有 0 至 29 一共 30 个编码. 距离编码的含义如下表所示:<br> <img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/3b80d2f91e264311a064a808f2b952ae.png"                        alt="在这里插入图片描述"                 ></p><ul><li>code表示基本的编码表示，比如编码9对应的基准距离是25</li><li>extra表示距离基准距离偏移了多少，编码9对应的extra为3位，最大为111（7），即25+7，最大可以表示32。</li><li>distance，可以表示的距离范围<br><code>总结</code>：code+extra可以灵活表示distance的任何数字</li></ul><p> <strong>匹配长度</strong>：<br>对于长度, 它与普通字符共用同一编码空间. 这个编码空间一共有 286 个编码, 范围是从 0 至 285. 其中 0 至 255 为普通字符编码, 256 表示压缩块的结束; 而 257 至 285 则表示长度. 长度编码的含义如下表所示:<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/cbc0b2d8ccf74078ac743dd0dfead6e0.png"                        alt="在这里插入图片描述"                 ></p><p>与距离编码类似, 每个编码都表示一个或多个长度, 表示多个长度时后面会有 extra 位指示具体的长度. 长度编码能表示的长度范围为 3 至 258.<br>注意：所以在 DEFLATE 中，长度 1<del>2 的重复<strong>不会用匹配项表示</strong>（直接把这 1</del>2 个字节原样输出（即用字面值编码）通常比引用匹配（还要额外编码长度和距离）更短！）；只有长度 ≥ 3 时才会用匹配项 (length, distance) 来引用重复块。<br>解压时, 当读到编码小于等于 255, 则认为这是个普通字符, 原样输出即可; 若在 257 至 285 之间, 则说明遇到了一个重复标记, 这意味着当前编码表示的是长度, 且下一个编码表示的是距离. 解码得到长度和距离, 再在解压缓冲区中找到相应的部分输出即可; 若为 256, 则说明压缩块结束了.</p><p>从LZ777编码到霍夫曼编码<br>上一步的LZ777编码结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ab</span>(<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>)c</span><br></pre></td></tr></table></figure><p>字符串统计频率为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">01</span></span><br><span class="line">c:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>字符编码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101</span>(<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>)<span class="number">00</span></span><br></pre></td></tr></table></figure><p>然后对偏移距离和匹配长度进行编码<br>但是这里发现匹配字符长度是从3开始的，那么这个2怎么编码呢？原来这里的deflate算法是使用了改进型的LZ777算法<br>参考文章：<a class="link"   href="https://luyuhuang.tech/2020/04/28/gzip-and-deflate.html" >Gzip 格式和 DEFLATE 压缩算法<i class="fas fa-external-link-alt"></i></a></p><h3 id="改进型的LZ777算法"><a href="#改进型的LZ777算法" class="headerlink" title="改进型的LZ777算法"></a>改进型的LZ777算法</h3><blockquote><p>LZ77压缩算法将所有数据都处理成为一个三元组串，每个三元组至少需要3个字节表示，如果在动态字典中未找到匹配字符串，会将1个字节输出为3个字节，这就导致了字节浪费。因此在DEFLATE算法中对其使用的LZ77算法进行了以下改进：</p><p>对匹配字符串长度小于3的字符串不压缩。因为长度小于3的字符串，使用三元组表示，对原始数据不能起到压缩的作用。<br>对字符串的匹配长度进行了限制，范围为（-128~127），用8bit表示，滑动窗口大小为32KB，用15bit表示，将压缩数据构造为标识+数据的形式，具体如表3所示。该存储方式，降低了压缩数据的存储空间。<br>由于只查找匹配长度大于3的字符串，为提高算法速度，在查找匹配字符串时，使用了哈希链结构搜索算法，其中哈希算法将3字节压缩到2字节，虽然哈希链结构存在搜索到错误结果的可能，但还是大幅提高了搜索速度。</p></blockquote><p>所以最终的编码结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">01</span></span><br><span class="line">c:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>这里的字符串“abababc”，连续匹配都没有超过三个字符，直接按照这个字符串常量进行编码即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10110110100</span></span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="压缩对象"><a href="#压缩对象" class="headerlink" title="压缩对象"></a>压缩对象</h3><p>在开始编写代码前，我们需要弄清楚，需要压缩的对象是什么？</p><ol><li>视频、音频、图片等文件本身就是压缩格式<br>mp4、jpg、png、avi、mp3 这些格 已经过复杂压缩算法处理（如 H.264、H.265、JPEG、LZ77 等）。<br>👉 所以再次使用 GZIP 压缩不会有太大效果，反而可能略微增加体积。</li><li>GZIP 对二进制内容的压缩效率很低<br>GZIP 是为文本内容设计的压缩算法（如 HTML、JSON、JavaScript 等）。<br>它依赖数据的可预测性和重复性（如文本中的重复词、空格等）来压缩。<br>视频文件的数据模式看起来是“随机的”，压缩器无法从中找到有效的模式。</li></ol><h3 id="gzip实现"><a href="#gzip实现" class="headerlink" title="gzip实现"></a>gzip实现</h3><p><code>GzipMiddleware.h</code>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">GzipMiddleware</span>():<span class="built_in">clientSupportGzip_</span>(<span class="literal">true</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">before</span><span class="params">(HttpRequest&amp; request)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">after</span><span class="params">(HttpResponse&amp; response)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setClientSupportGzip</span><span class="params">(<span class="type">bool</span> flag)</span></span>&#123;clientSupportGzip_=flag;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isClinetSupportGzip</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> clientSupportGzip_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getGzipEnableRate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">uint64_t</span> total = totalRequests_.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">return</span> total == <span class="number">0</span> ? <span class="number">0.0</span> : (<span class="type">double</span>)gzipAppliedCount_.<span class="built_in">load</span>() / total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getAverageCompressionRatio</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">uint64_t</span> original = originalSizeSum_.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">return</span> original == <span class="number">0</span> ? <span class="number">0.0</span> : (<span class="type">double</span>)compressedSizeSum_.<span class="built_in">load</span>() / original;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compressGzip</span><span class="params">(<span class="type">const</span> std::string&amp; input, std::string&amp; output)</span></span>;</span><br><span class="line">    <span class="type">bool</span> clientSupportGzip_;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// gzip统计信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkArchive</span><span class="params">()</span></span>;  <span class="comment">// 检查是否需要归档</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetStats</span><span class="params">()</span></span>;    <span class="comment">// 重置统计信息</span></span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; totalRequests_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; gzipAppliedCount_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; originalSizeSum_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; compressedSizeSum_&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::function&lt;void(uint64_t, uint64_t, uint64_t, uint64_t)&gt; archiveCallback_;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> MAX_REQUESTS_BEFORE_ARCHIVE = <span class="number">1e9</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> MAX_ORIGINAL_SIZE_BEFORE_ARCHIVE = <span class="number">1ULL</span> &lt;&lt; <span class="number">40</span>; <span class="comment">// 1 TB</span></span><br></pre></td></tr></table></figure><p><code>GzipMiddleware.cpp</code>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GzipMiddleware::before</span><span class="params">(HttpRequest&amp; request)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 从客户端请求头中获取 Accept-Encoding 字段</span></span><br><span class="line">    std::string acceptEncoding=request.<span class="built_in">getHeader</span>(<span class="string">&quot;Accept-Encoding&quot;</span>);</span><br><span class="line">     <span class="comment">// 判断是否包含 &quot;gzip&quot; 关键字</span></span><br><span class="line">    <span class="comment">// 如果包含，说明客户端支持 gzip 压缩</span></span><br><span class="line">    <span class="comment">// 否则，不支持 gzip 压缩，如果不支持，就不进行gzip压缩</span></span><br><span class="line">    acceptEncoding.<span class="built_in">find</span>(<span class="string">&quot;gzip&quot;</span>) != std::string::npos?<span class="built_in">setClientSupportGzip</span>(<span class="literal">true</span>):<span class="built_in">setClientSupportGzip</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">// GzipMiddleware::after</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GzipMiddleware::after</span><span class="params">(HttpResponse&amp; response)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 统计总请求数（用于后续压缩统计归档）</span></span><br><span class="line">    totalRequests_++;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isClinetSupportGzip</span>())     <span class="comment">// 如果客户端不支持 gzip，则直接跳过压缩</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否应该压缩，消息体大于256字节并且消息类型是文本、html等类型才可以</span></span><br><span class="line">    <span class="comment">//对于视频、图片等已经使用了其他压缩算法进行压缩了的，就不再使用gzip进行压缩了</span></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="built_in">isShouldGzipCompress</span>()) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始响应体内容</span></span><br><span class="line">    <span class="type">const</span> std::string&amp; rawBody = response.<span class="built_in">getBody</span>();</span><br><span class="line">    std::string compressed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用实际压缩方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">compressGzip</span>(rawBody, compressed)) &#123;</span><br><span class="line">        <span class="comment">// LOG_INFO&lt;&lt;&quot;gzipAppliedCount_:&quot;&lt;&lt;gzipAppliedCount_.load()&lt;&lt;&quot;originalSizeSum_&quot;&lt;&lt;originalSizeSum_.load()&lt;&lt;&quot;compressedSizeSum_&quot;&lt;&lt;compressedSizeSum_.load();</span></span><br><span class="line">        gzipAppliedCount_++;</span><br><span class="line">        originalSizeSum_ += rawBody.<span class="built_in">size</span>();</span><br><span class="line">        compressedSizeSum_ +=compressed.<span class="built_in">size</span>();</span><br><span class="line">        response.<span class="built_in">addHeader</span>(<span class="string">&quot;Content-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>);  <span class="comment">// 添加响应头标识压缩格式为 gzip</span></span><br><span class="line">        response.<span class="built_in">setContentLength</span>(compressed.<span class="built_in">size</span>());    <span class="comment">// 更新 Content-Length 为压缩后大小</span></span><br><span class="line">        response.<span class="built_in">setBody</span>(compressed);                    <span class="comment">// 设置压缩后的响应体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否需要归档统计信息</span></span><br><span class="line">    <span class="built_in">checkArchive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">// GzipMiddleware::compressGzip实际的压缩处理算法</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GzipMiddleware::compressGzip</span><span class="params">(<span class="type">const</span> std::string&amp; input, std::string&amp; output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> CHUNK = <span class="number">16384</span>; </span><br><span class="line">    z_stream strm&#123;&#125;;    <span class="comment">//zlib 用于压缩的状态结构体，记录输入、输出缓冲区状态等</span></span><br><span class="line">    <span class="type">char</span> out[CHUNK];    <span class="comment">//输出缓冲区，用来暂存压缩后的数据块</span></span><br><span class="line"></span><br><span class="line">    strm.zalloc = Z_NULL;</span><br><span class="line">    strm.zfree = Z_NULL;</span><br><span class="line">    strm.opaque = Z_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deflateInit2</span>(&amp;strm,             <span class="comment">//压缩状态</span></span><br><span class="line">                     Z_BEST_COMPRESSION, <span class="comment">//压缩等级（0~9），9 表示最高压缩比，牺牲性能</span></span><br><span class="line">                     Z_DEFLATED,         <span class="comment">//使用 DEFLATE 算法</span></span><br><span class="line">                     <span class="number">15</span> + <span class="number">16</span>,           <span class="comment">//15位窗口大小(32KB), +16启用 GZIP 格式输出（否则是 zlib）</span></span><br><span class="line">                     <span class="number">8</span>,                 <span class="comment">//内部压缩缓冲区大小参数，一般为 8</span></span><br><span class="line">                     Z_DEFAULT_STRATEGY) != Z_OK) <span class="comment">//默认压缩策略</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strm.avail_in = input.<span class="built_in">size</span>();          <span class="comment">// 待压缩数据长度</span></span><br><span class="line">    strm.next_in = (Bytef*)input.<span class="built_in">data</span>();   <span class="comment">// 待压缩数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        strm.avail_out = CHUNK;            <span class="comment">//待压缩数据存储buffer 的长度，如果多次写，会覆盖之前的写的数据</span></span><br><span class="line">                                            <span class="comment">//当然，之前的数据已经被读走了</span></span><br><span class="line">        strm.next_out = <span class="built_in">reinterpret_cast</span>&lt;Bytef*&gt;(out); <span class="comment">//待压缩数据存储的buffer</span></span><br><span class="line">        <span class="built_in">deflate</span>(&amp;strm, Z_FINISH);            <span class="comment">//如果输入和待输出的数据都被处理完，则返回 Z_STREAM_END</span></span><br><span class="line">        <span class="type">size_t</span> have = CHUNK - strm.avail_out;<span class="comment">//总长度-当前可写=已经写的数据长度</span></span><br><span class="line">        output.<span class="built_in">append</span>(out, have);</span><br><span class="line">    &#125; <span class="keyword">while</span> (strm.avail_out == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deflateEnd</span>(&amp;strm);                       <span class="comment">//释放deflateInit2申请的空间</span></span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;原始的数据大小为:&quot;</span>&lt;&lt; input.<span class="built_in">size</span>();</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;GZIP压缩完成,压缩比例为:&quot;</span>&lt;&lt;(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(output.<span class="built_in">size</span>()) / input.<span class="built_in">size</span>());;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GzipMiddleware::checkArchive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果压缩的总请求数或原始数据累计大小超过阈值</span></span><br><span class="line">    <span class="comment">// 就清理统计数据（可用于后续监控、日志）</span></span><br><span class="line">    <span class="keyword">if</span> (totalRequests_ &gt;= MAX_REQUESTS_BEFORE_ARCHIVE ||</span><br><span class="line">        originalSizeSum_ &gt;= MAX_ORIGINAL_SIZE_BEFORE_ARCHIVE) &#123;</span><br><span class="line"></span><br><span class="line">        totalRequests_ = <span class="number">0</span>;</span><br><span class="line">        gzipAppliedCount_ = <span class="number">0</span>;</span><br><span class="line">        originalSizeSum_ = <span class="number">0</span>;</span><br><span class="line">        compressedSizeSum_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的函数有：</p><ul><li><code>before()</code>函数，判断请求是否支持gzip压缩</li><li><code>after()</code>函数，统计请求，如果客户端不支持gzip压缩就返回；否则对其进行gzip压缩并填充响应体部分</li><li><code>compressGzip()</code>函数，实际的压缩处理核心部分</li><li><code>checkArchive()</code>函数，用于统计压缩的情况，如平均压缩率等</li></ul><p>本代码实现<code>gzip</code>的核心部分就是在<code>compressGzip</code>函数中进行了实际的压缩，<code>compressGzip</code>调用了<code>deflate</code>函数进行实际的压缩。关于<code>deflate</code>函数的介绍，可以参考<br><a class="link"   href="https://blog.csdn.net/m0_61476090/article/details/136592993" >深入理解数据压缩流程及 zlib 库中相关函数<i class="fas fa-external-link-alt"></i></a></p><h2 id="运行分析"><a href="#运行分析" class="headerlink" title="运行分析"></a>运行分析</h2><p>运行服务器，查看gzip压缩是否启用成功，有三个地方可以查看gzip的压缩启用是否成功。分别是日志系统、wireshark抓包分析、LiteHub前端展示。</p><h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/53ab09d1730c4a34a4e47c85840f2ed9.png"                        alt="在这里插入图片描述"                 ><br>这个压缩比例计算方式是：压缩后的数据大小除以压缩前的数据大小。可以看到gzip是有效压缩成功了的。</p><h3 id="wireshark抓包查看"><a href="#wireshark抓包查看" class="headerlink" title="wireshark抓包查看"></a>wireshark抓包查看</h3><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/01844c8007ad426badcf683ae73e916f.png"                        alt="在这里插入图片描述"                 ><br>首先看客户端发起的每一次请求都会携带<code>Accept-Encoding:</code>字段，该字段中携带了 <code>gzip, deflate</code>表示支持<code>gzip</code>压缩方式。</p><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/dede28be630f4f83839cfd4b59dc07a8.png"                        alt="在这里插入图片描述"                 ><br>这个报文是从服务器发回的响应报文，客户端收到压缩后的信息包后自动解压，从2380字节解压到原来的9182字节，这也进一步说明了设计的gzip压缩算法是有效的。</p><h3 id="后台管理界面查看"><a href="#后台管理界面查看" class="headerlink" title="后台管理界面查看"></a>后台管理界面查看</h3><p>此外，在LiteHub前端界面，也是可以通过管理员账户查看具体的gzip的一个压缩信息的。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/83851fc1911e4c46a9cd62699348187a.png"                        alt="在这里插入图片描述"                 ><br>关于gzip的理解就分析到这了，如果有不恰当之前，请您指出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;理论部分&quot;&gt;&lt;a href=&quot;#理论部分&quot; class=&quot;headerlink&quot; title=&quot;理论部分&quot;&gt;&lt;/a&gt;理论部分&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;gz</summary>
      
    
    
    
    <category term="Http后端服务器" scheme="https://localhost/categories/Http%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="后端" scheme="https://localhost/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="中间件" scheme="https://localhost/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>STL迭代器的理解</title>
    <link href="https://localhost/undefined/stl_iterator/"/>
    <id>https://localhost/undefined/stl_iterator/</id>
    <published>2025-07-04T07:12:39.000Z</published>
    <updated>2025-07-12T05:51:07.856Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="迭代器简介绍"><a href="#迭代器简介绍" class="headerlink" title="迭代器简介绍"></a>迭代器简介绍</h2><p>迭代器就像是一个”指针”，指向容器（比如vector、list）中的某个元素。通过迭代器，我们不仅可以访问和修改容器中的元素，还能在容器中自由移动（前进或后退）。<br>简而言之，迭代器充当着容器与算法之间的纽带，让你无需了解容器内部实现细节，就能方便地遍历和操作容器元素。<br>迭代器可以透明地访问容器内部的元素的值。<br>STL中提供的一些迭代器：</p><ul><li><code>const_iterator</code>:常量的正向迭代器，只能读，不能通过该迭代器修改值</li><li><code>iterator</code>:普通的正向迭代器</li><li><code>const_reverse_iterator</code>:常量的反向迭代器，只能读，不能写</li><li><code>reverse_iterator</code>:普通的反向迭代器</li></ul><p>以下是迭代器使用的样例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的正向迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1= vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; it1 != vec.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (*it1 % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*it1 =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//const_iterator是iterator的基类</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it2 = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; it2 != vec.<span class="built_in">end</span>(); ++it2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it2 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::reverse_iterator it3 = vec.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">for</span> (;it3!=vec.<span class="built_in">rend</span>();++it3)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; *it3 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (*it3 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*it3 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//const_reverse_iterator也是reverse_iterator的基类</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_reverse_iterator it4 = vec.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">for</span> (; it4 != vec.<span class="built_in">rend</span>(); ++it4)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it4 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义实现迭代器"><a href="#自定义实现迭代器" class="headerlink" title="自定义实现迭代器"></a>自定义实现迭代器</h2><p>迭代器一般嵌套实现在容器内部，在上一篇实现<a class="link"   href="https://blog.csdn.net/weixin_52288941/article/details/149023407?spm=1011.2415.3001.5331" >容器配置器<i class="fas fa-external-link-alt"></i></a>中我们实现了自定义的vector,本节我们继续在此基础上探索迭代器的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器一般实现在容器的嵌套类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//迭代器的四要素</span></span><br><span class="line"><span class="comment">//1,构造函数</span></span><br><span class="line"><span class="built_in">iterator</span>(T* p=<span class="literal">nullptr</span>) :_p(p) &#123;&#125;</span><br><span class="line"><span class="comment">//2.!=运算符重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> iterator&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _p != it._p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.前置运算符重载</span></span><br><span class="line"><span class="comment">//前置++不会产生临时量，效率相对来说更高</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">++_p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.解引用方法重载</span></span><br><span class="line"><span class="comment">//提供解引用的两个版本，普通方法和常方法</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_p; &#125;</span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123; <span class="keyword">return</span> *_p; &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _p;<span class="comment">//根据容器的变量定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//返回容器底层首元素的迭代器表示</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(_first); &#125;</span><br><span class="line"><span class="comment">//返回容器末尾元素的迭代器表示</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(_last); &#125;</span><br></pre></td></tr></table></figure><p>将上述的iterator添加到自定义的vector内部后 ，就可以通过迭代器遍历自定义的vector内部元素了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[]（中括号运算符重载）方式遍历，针对连续内存使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器方式遍历</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : vec)<span class="comment">//其底层就是通过容器的迭代器来实现遍历的</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h2><p>迭代器为什么会失效？</p><ul><li>当容器调用erase方法后，当前位置到容器末尾的所有迭代器全部失效了</li><li>当调用insert方法后，分为两种情况<ul><li>如果没有扩容操作，当前插入点到末尾的所有迭代器全部失效</li><li>如果有扩容操作，容器全部失效</li></ul></li></ul><p> 迭代器失效部分的代码比较复杂，我这里就使用<code>stl</code>中的<code>vector</code>进行记录</p><p><strong>插入操作导致的迭代器失效</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">//预留10个int元素大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">insert</span>(it, *it - <span class="number">1</span>);<span class="comment">//程序在这执行了一次插入操作后，迭代器就已经失效了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/dcd7be14056e407fa5fad58800c64baf.png"                        alt="在这里插入图片描述"                 ><br>执行这里代码是异常退出的；<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/818ce3730400489ca38015a70f7b3849.png"                        alt="在这里插入图片描述"                 ><br><strong>删除操作导致的迭代器失效</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">//预留10个int元素大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第一次调用erase以后，迭代器it就失效了</span></span><br><span class="line">vec.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/c3d97c93cbbc4742b5956a5f7bc8ecaf.png"                        alt="在这里插入图片描述"                 ></p><p><strong>解决迭代器失效问题的方法</strong><br>当容器（如vector、list、map等）在进行插入或删除操作时，会导致迭代器失效。那如何解决上述提到的迭代器失效问题呢？<br>其实erase函数和insert函数返回了对应的一个迭代器，当进行插入或者删除后，会返回下一个元素的迭代器。以下是详细分析：</p><ol><li><strong>erase函数的正确用法</strong><ul><li>标准库中的erase函数会返回被删除元素的下一个有效迭代器</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">//预留10个int元素大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">//删除容器中的偶数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//返回删除元素的下一个有效迭代器</span></span><br><span class="line">it=vec.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/06443522c170414b952575f8b45d79be.png"                        alt="在这里插入图片描述"                 ></p><ol start="2"><li><strong>insert函数的正确用法</strong><ul><li>insert函数同样会返回新插入元素的迭代器</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">//预留10个int元素大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在5的倍数前插入1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//返回已插入元素的下一个有效迭代器</span></span><br><span class="line">it=vec.<span class="built_in">insert</span>(it,<span class="number">1</span>);<span class="comment">//这里1是插入5的前面,返回插入元素的下一个有效迭代器实际是指向5</span></span><br><span class="line">++it; <span class="comment">//所以这里需要后移一位，移动元素5的下一个位置，即6；</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/4e5adc03952845219c2ceba58cd0dd65.png"                        alt="在这里插入图片描述"                 ></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>迭代器失效看起来很复杂，但只要记住几个简单的规则，就能轻松避开这个坑：</p><p><code>vector:</code> 插入或删除元素后，该位置及其后面的迭代器都会失效；如果重新分配内存，所有迭代器都会失效。<br><code>list/forward_list:</code> 只有被删除元素的迭代器会失效。<br><code>map/set/multimap/multiset:</code> 只有被删除元素的迭代器会失效。<br><code>unordered_map/unordered_set:</code> 插入操作可能导致所有迭代器失效（rehash）；删除操作只会导致被删除元素的迭代器失效。</p><p><a class="link"   href="https://segmentfault.com/a/1190000046526353" >迭代器失效：99%的C++程序员都会踩的坑 !<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">迭代器的理解</summary>
    
    
    
    <category term="STL模板库" scheme="https://localhost/categories/STL%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    
    
    <category term="c++" scheme="https://localhost/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>LiteHub之中间件限流实现</title>
    <link href="https://localhost/undefined/LiteHub_middleware_traffic&amp;&amp;control/"/>
    <id>https://localhost/undefined/LiteHub_middleware_traffic&amp;&amp;control/</id>
    <published>2025-07-04T05:28:22.000Z</published>
    <updated>2025-07-12T05:50:20.294Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><p><strong>为什么要限流？</strong></p><blockquote><p>在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流。<br>其中，限流在很多场景中用来限制并发和请求量，比如说秒杀抢购，保护自身系统和下游系统不被巨型流量冲垮等。</p></blockquote><p>常见的限流方法包括计数器、滑动窗口、漏桶和令牌桶算法。</p><h3 id="计数器算法："><a href="#计数器算法：" class="headerlink" title="计数器算法："></a>计数器算法：</h3><p>在一段时间间隔内（时间窗&#x2F;时间区间，处理请求的最大数量固定，超过部分不做处理。<br>简单粗暴，比如指定线程池大小，指定数据库连接池大小、nginx连接数等，这都属于计数器算法。</p><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。<br>举个例子，比如我们规定对于接口A，我们1分钟的访问次数不能超过100个。</p><p>计数器限流的做法是：<br>我们可以初始化一个计数器<code>counter</code>，每当收到请求时<code>counter</code>加1。若<code>counter</code>值超过100且当前请求与首个请求的时间间隔小于1分钟，则判定为请求过多并拒绝访问；若时间间隔超过1分钟且<code>counter</code>仍在限流范围内，则重置<code>counter</code>。</p><p>但是这个方法存在一个显著的问题，攻击者可以在0:59的时候一次性发100个请求；到1:00就会将计数器清零，然后在1:01的时候再发100个请求；对于0:00-1:00和1:00-2:00这两个一分钟的请求都是100个请求，看起来是满足系统的要求的；但是在0:59-1:01这不足1分钟的时间段内，却发起了200个请求，可能会引起系统奔溃。</p><h3 id="滑动窗口算法："><a href="#滑动窗口算法：" class="headerlink" title="滑动窗口算法："></a>滑动窗口算法：</h3><blockquote><p>滑动窗口<code>（rolling window）</code>是一种时间分段技术。在计数器算法中，如果限制1分钟内的访问次数，这个1分钟就是一个固定时间窗口。而滑动窗口则是将这个固定窗口进一步细分成多个更小的时间单元。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/b1e9da23e98b47348d19c748eae2e173.png"                        alt="在这里插入图片描述"                 ></p></blockquote><p>例如：将1分钟的固定窗口划分为6个10秒的小窗口。整个红色矩形框代表一个大时间窗口，窗口会持续滑动，每10秒向右移动一格。假设在第一分钟的第59秒收到100个请求（落在灰色格子），第二分钟的1:00又收到100个请求（落在橘黄色格子）。此时滑动窗口检测到完整1分钟（红色框）内的总请求量达到200次，超过100次的限流阈值，就能及时触发限流机制。<br>滑动窗口划分得越精细，限流统计的准确性就越高，但过于精细会增加系统负担。</p><h3 id="漏桶算法："><a href="#漏桶算法：" class="headerlink" title="漏桶算法："></a>漏桶算法：</h3><blockquote><p>水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会超过桶可接纳的容量时直接溢出。<br>漏桶算法可以粗略的认为就是注水漏水过程，往桶中以任意速率流入水，以一定速率流出水，当水超过桶容量（capacity）则丢弃，因为桶容量是不变的，保证了整体的速率。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/66a3dbd876f442978e31a8d5cca98ca9.png"                        alt="在这里插入图片描述"                 ><br>总结：漏桶算法通过一个固定容量和固定漏水速率的水桶模型，强制将任意输入流量整形为恒定速率输出，并在流量超过容量时丢弃请求，以此实现速率限制、流量平滑和系统保护。</p></blockquote><h3 id="令牌桶算法："><a href="#令牌桶算法：" class="headerlink" title="令牌桶算法："></a>令牌桶算法：</h3><blockquote><p>令牌桶是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌，填满了就丢弃令牌，请求是否被处理要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求。在流量低峰的时候，令牌桶会出现堆积，因此当出现瞬时高峰的时候，有足够多的令牌可以获取，令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌。令牌桶中装的是令牌。</p><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/ed3860c85b6442608f5311d4a2da95af.png"                        alt="在这里插入图片描述"                 ></p></blockquote><p><strong>特点</strong>：与漏桶算法相比，令牌桶算法允许短时间内的请求量激增（获得令牌后即可访问接口，可能出现瞬间消耗所有累积令牌的情况），但不会像计数算法那样产生过高峰值（因为令牌是匀速生成的）。因此，令牌桶算法在处理突发流量时表现更优。<br>部分内容和图片来源：<br><a class="link"   href="https://zhuanlan.zhihu.com/p/652873702" >常见限流算法：计数器、滑动窗口、漏桶、令牌桶<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/crazymakercircle/article/details/130035504" >限流：计数器、漏桶、令牌桶 三大算法的原理与实战（史上最全）<i class="fas fa-external-link-alt"></i></a></p><h2 id="限流实现"><a href="#限流实现" class="headerlink" title="限流实现"></a>限流实现</h2><p>本项目我是基于令牌桶实现的访问限流，请看以下代码<br><code>LimitMiddleware.h</code>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LimitMiddleware</span>: <span class="keyword">public</span> Middleware </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="comment">// rate：令牌生成速率（个/秒）</span></span><br><span class="line">    <span class="comment">// capacity：桶最大容量（最多存多少个令牌）</span></span><br><span class="line">    <span class="built_in">LimitMiddleware</span>(<span class="type">int</span> rate, <span class="type">int</span> capacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在请求处理前调用，用于限流</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">before</span><span class="params">(HttpRequest&amp; request)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">after</span><span class="params">(HttpResponse&amp; response)</span> <span class="keyword">override</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">gettokens</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> tokens_;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 补充令牌（根据时间推移）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">refillTokens</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> rate_;            <span class="comment">// 令牌生成速率（个/秒）</span></span><br><span class="line">    <span class="type">int</span> capacity_;        <span class="comment">// 桶容量（最大令牌数）</span></span><br><span class="line">    <span class="type">double</span> tokens_;       <span class="comment">// 当前可用令牌数（允许小数，更精确）</span></span><br><span class="line">    std::chrono::steady_clock::time_point lastRefillTime_; <span class="comment">// 上一次补充时间</span></span><br><span class="line">    std::mutex mutex_;    <span class="comment">// 保护多线程访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>LimitMiddleware.cc</code>文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌桶限流中间件</span></span><br><span class="line"><span class="comment">// 构造函数：指定令牌产生速率 rate (个/秒) 和桶容量 capacity (最多可存储多少令牌)</span></span><br><span class="line">LimitMiddleware::<span class="built_in">LimitMiddleware</span>(<span class="type">int</span> rate, <span class="type">int</span> capacity)</span><br><span class="line">    : <span class="built_in">rate_</span>(rate),</span><br><span class="line">      <span class="built_in">capacity_</span>(capacity),</span><br><span class="line">      <span class="built_in">tokens_</span>(capacity),  <span class="comment">// 初始化时桶是满的，令牌数等于容量</span></span><br><span class="line">      <span class="built_in">lastRefillTime_</span>(steady_clock::<span class="built_in">now</span>())  <span class="comment">// 记录上次补充令牌的时间</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌补充逻辑</span></span><br><span class="line"><span class="comment">// 根据距离上次补充的时间，按速率补充新令牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LimitMiddleware::refillTokens</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> elapsedMs = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now - lastRefillTime_).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elapsedMs &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 按照速率计算可以补充的令牌数</span></span><br><span class="line">        <span class="type">double</span> newTokens = (elapsedMs / <span class="number">1000.0</span>) * rate_;</span><br><span class="line">        <span class="comment">// 桶中的令牌数不能超过容量上限</span></span><br><span class="line">        tokens_ = std::<span class="built_in">min</span>((<span class="type">double</span>)capacity_, tokens_ + newTokens);</span><br><span class="line">        <span class="comment">// 更新时间戳</span></span><br><span class="line">        lastRefillTime_ = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求前执行：判断是否有足够的令牌</span></span><br><span class="line"><span class="comment">//如果有足够的令牌，进行下一步操作</span></span><br><span class="line"><span class="comment">//如果没有，拒绝访问，返回状态码429</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LimitMiddleware::before</span><span class="params">(HttpRequest&amp; request)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 加锁保证多线程安全</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先补充令牌</span></span><br><span class="line">    <span class="built_in">refillTokens</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tokens_ &gt;= <span class="number">1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens_ -= <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 有足够令牌，消费 1 个，允许请求通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 没有足够令牌，请求被拒绝，抛出 429 响应</span></span><br><span class="line">        HttpResponse resp;</span><br><span class="line">        resp.<span class="built_in">setStatusLine</span>(request.<span class="built_in">getVersion</span>(), http::HttpResponse::k429TooManyRequests, <span class="string">&quot;Too Many Requests&quot;</span>);</span><br><span class="line">        resp.<span class="built_in">setCloseConnection</span>(<span class="literal">true</span>);</span><br><span class="line">        resp.<span class="built_in">setContentType</span>(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        resp.<span class="built_in">setContentLength</span>(<span class="number">0</span>);</span><br><span class="line">        resp.<span class="built_in">setBody</span>(<span class="string">&quot;Rate limit exceeded. Please try again later.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心逻辑是：</p><ul><li>按固定速率补充令牌（<code>refillTokens</code>）</li><li>请求到来时消费令牌（<code>before</code>）</li><li>没有令牌可用时返回（限流了，返回状态码<code>429 Too Many Requests</code>）</li></ul><h2 id="限流测试"><a href="#限流测试" class="headerlink" title="限流测试"></a>限流测试</h2><p>在<code>WebApps/LiteHubServer/src/LiteHubServer.cpp</code>中的<code>initializeMiddleware</code>函数中，定义了限流中间件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limitMiddleware_ = std::<span class="built_in">make_shared</span>&lt;http::middleware::LimitMiddleware&gt;(<span class="number">1</span>,<span class="number">100</span>); <span class="comment">// 每秒最多100个请求</span></span><br><span class="line">httpServer_.<span class="built_in">addMiddleware</span>(limitMiddleware_);</span><br></pre></td></tr></table></figure><p>这里定义的是一秒不超过100个请求，如果通过手动点击，这个1秒内怎么也到不了100次请求；所以我通过python脚本代码模拟一次大量的访问，python代码如下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="comment"># 压测参数配置</span></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line">TOTAL_REQUESTS = <span class="number">150</span>      <span class="comment"># 总请求数</span></span><br><span class="line">MAX_WORKERS = <span class="number">3</span>           <span class="comment"># 并发线程数</span></span><br><span class="line">REQUEST_INTERVAL = <span class="number">0.02</span>   <span class="comment"># 相邻请求的间隔（秒），避免瞬间爆发</span></span><br><span class="line">TARGET_URL = <span class="string">&quot;http://47.122.77.97/&quot;</span>  <span class="comment"># 目标 URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="comment"># 单次请求任务</span></span><br><span class="line"><span class="comment"># index: 请求编号</span></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_request</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="comment"># 发起 GET 请求</span></span><br><span class="line">        r = requests.get(TARGET_URL, timeout=<span class="number">3</span>)</span><br><span class="line">        elapsed = time.time() - start_time</span><br><span class="line">        <span class="comment"># 打印日志：时间戳 + 请求序号 + 响应码 + 耗时</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[<span class="subst">&#123;time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)&#125;</span>] 请求 <span class="subst">&#123;index + <span class="number">1</span>:02d&#125;</span> --&gt; 状态码: <span class="subst">&#123;r.status_code&#125;</span> (耗时: <span class="subst">&#123;elapsed:<span class="number">.2</span>f&#125;</span>s)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> r.status_code</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 异常时打印错误信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[<span class="subst">&#123;time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)&#125;</span>] 请求 <span class="subst">&#123;index + <span class="number">1</span>:02d&#125;</span> --&gt; 失败: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;开始压测，总请求数：<span class="subst">&#123;TOTAL_REQUESTS&#125;</span>，最大并发数：<span class="subst">&#123;MAX_WORKERS&#125;</span>&quot;</span>)</span><br><span class="line">    results = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录整个压测开始时间</span></span><br><span class="line">    total_start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建线程池</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=MAX_WORKERS) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = []</span><br><span class="line">        <span class="comment"># 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TOTAL_REQUESTS):</span><br><span class="line">            futures.append(executor.submit(send_request, i))</span><br><span class="line">            time.sleep(REQUEST_INTERVAL)  <span class="comment"># 控制相邻请求的间隔</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">            results.append(future.result())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录整个压测结束时间</span></span><br><span class="line">    total_elapsed = time.time() - total_start_time</span><br><span class="line"></span><br><span class="line">    <span class="comment"># -------------------------------</span></span><br><span class="line">    <span class="comment"># 统计与输出结果</span></span><br><span class="line">    <span class="comment"># -------------------------------</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n-----------------------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求状态统计结果:&quot;</span>)</span><br><span class="line">    counts = Counter(results)</span><br><span class="line">    <span class="keyword">for</span> key, count <span class="keyword">in</span> counts.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;count&#125;</span> 次&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n压测总耗时: <span class="subst">&#123;total_elapsed:<span class="number">.2</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行python代码的结果如下：</p><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/6f292cb378614e059d19263d3f2b193a.png"                        alt="在这里插入图片描述"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/1ac4803738774abf83289aa77a6786b0.png"                        alt="在这里插入图片描述"                 ><br>可用看到总共有104次请求成功；46次拒绝访问。证明了设计的令牌桶限流策略有效。<br>我们将REQUEST_INTERVAL 调整的大一些，避免瞬间的大量请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REQUEST_INTERVAL = <span class="number">0.1</span>   </span><br></pre></td></tr></table></figure><p>再执行一次：<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/4deda10211bd47858dac5decd3d12efe.png"                        alt="在这里插入图片描述"                 ><br>拒绝访问的次数也少了一些，从（46—&gt;&gt;&gt;34,即减少了12次）。</p><p>下图为wireshark抓包到的429状态码响应：<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/25690cf01b974d4db59bc45f50b92eb5.png"                        alt="在这里插入图片描述"                 ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;



&lt;h2 id=&quot;相关原理&quot;&gt;&lt;a href=&quot;#相关原理&quot; class=&quot;headerlink&quot; title=&quot;相关原理&quot;&gt;&lt;/a&gt;相关原理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;为什么要限</summary>
      
    
    
    
    <category term="Http后端服务器" scheme="https://localhost/categories/Http%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="后端" scheme="https://localhost/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>STL空间配置器的理解</title>
    <link href="https://localhost/undefined/stl_allocator/"/>
    <id>https://localhost/undefined/stl_allocator/</id>
    <published>2025-07-03T09:06:39.000Z</published>
    <updated>2025-07-12T05:50:59.047Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>这里以自定义的vector类为例，谈谈为什么需要空间配置器。</p><h1 id="自定义实现一个简单的vector"><a href="#自定义实现一个简单的vector" class="headerlink" title="自定义实现一个简单的vector"></a>自定义实现一个简单的vector</h1><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/1772d2557f474a50a4373e0c1b817a8c.png"                        alt="在这里插入图片描述"                 ><br>这里定义了三个成员变量，分别是_first（vector起始地址），_last（vector实际存放的末尾元素地址），_end（vector开辟的空间地址）。<br>使用模板类封装实现了vector，实现了以下函数：</p><ul><li>vector构造函数，使用new开辟内存+构造对象</li><li>析构函数，使用delete删除内存</li><li>拷贝构造函数</li><li>赋值构造函数</li><li>push_back（）函数，从vector最后插入</li><li>pop_back（）函数，从vector最后弹出</li><li>back()，获取末尾元素</li><li>empty（）,判断是否为空</li><li>full（）,判断是否满</li><li>size（）,获取元素大小</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> size = <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">_first = <span class="keyword">new</span> T[size];</span><br><span class="line">_last = _first;</span><br><span class="line">_end = _first + size;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]_first;</span><br><span class="line">_first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; cp)<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size = cp._end - cp._first;</span><br><span class="line">_first = <span class="keyword">new</span> T[size];</span><br><span class="line"><span class="type">int</span> len = cp._last - cp._first;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//这里是深拷贝</span></span><br><span class="line">&#123;</span><br><span class="line">_first[i] = cp._first[i];</span><br><span class="line">&#125;</span><br><span class="line">_last = _first + len;</span><br><span class="line">_end = _first + size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt;&amp; cp) <span class="comment">//赋值构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.防止自赋值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;cp)</span><br><span class="line"><span class="keyword">return</span>*<span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//2.删除原有空间</span></span><br><span class="line"><span class="keyword">delete</span>[]_first;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的空间并执行深拷贝</span></span><br><span class="line"><span class="type">int</span> size = cp._end - cp._first;</span><br><span class="line">_first = <span class="keyword">new</span> T[size];</span><br><span class="line"><span class="type">int</span> len = cp._last - cp._first;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">_first[i] = cp._first[i];</span><br><span class="line">&#125;</span><br><span class="line">_last = _first + len;</span><br><span class="line">_end = _first + size;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果空间满了，则扩容</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line"><span class="built_in">expand</span>();</span><br><span class="line">*_last++ = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//判断是否还有值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">--_last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;stack is empty&quot;</span>; <span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> _first == _last;&#125; <span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _last == _end;&#125;  <span class="comment">//判断是否已满</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _last - _first; &#125;<span class="comment">//计算实际存储的数据大小</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _first; <span class="comment">//指向数组起始的位置</span></span><br><span class="line">T* _last;  <span class="comment">//指向数组中有效元素的后继位置</span></span><br><span class="line">T* _end;  <span class="comment">//指向数组的结尾</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span> <span class="comment">//扩容操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.重新构造</span></span><br><span class="line"><span class="type">int</span> size = _end - _first;</span><br><span class="line">T* ptmp = <span class="keyword">new</span> T[<span class="number">2</span> * size];</span><br><span class="line"><span class="comment">//2.深拷贝</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">ptmp[i] = _first[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.删除原来的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[]_first;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_first = ptmp;</span><br><span class="line">_last = _first + size;</span><br><span class="line">_end = _first + <span class="number">2</span> * size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以实现vector简单的插入、弹出、扩容等操作。<br>运行下面的代码，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">const</span> Test&amp;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Test&amp; cp)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;赋值构造&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test t1, t2, t3; <span class="comment">//调用赋值构造函数，打印Test();</span></span><br><span class="line">vector&lt;Test&gt; vec;<span class="comment">//创建一个大小为size的空间，这里默认为5，并且这里会调用默认vector构造函数构造对象</span></span><br><span class="line">cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//理论上的有效空间为0，但这里已经有数据了；</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(t1);         <span class="comment">//这里调用的是打印的是赋值构造函数，该处原来有值（定义的时候生成的空对象）</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(t2);</span><br><span class="line">vec.<span class="built_in">push_back</span>(t3);</span><br><span class="line">cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//有效空间为3</span></span><br><span class="line">vec.<span class="built_in">pop_back</span>(); <span class="comment">//调用析构函数</span></span><br><span class="line">cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//有效空间为2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/9a488c2381b44609842d4092e6762fc7.png"                        alt="在这里插入图片描述"                 ><br><strong>存在以下问题</strong>：<br>1.在初始化的时候，开辟内存和对象构造是一起执行的；但是有些时候我只是为了声明变量（如<code>vector&lt;Test&gt; vec</code>,在这里只是为了声明定义以<code>Test</code>类的<code>vec</code>数组，但是上图是开辟内存+构造对象），这样就会带来没必要的开销（声明时构造对象，出作用域时析构对象）；<br>2.上述实现的vector的pop_back是采用的指针回退策略，但如果该指针指向的test对象指向了外部资源，单纯的指针回退会导致这一部分资源无法管理，导致空间泄露</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"> &#123;</span><br><span class="line"> _ps=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"> &#125;</span><br><span class="line">~<span class="built_in">Test</span>() </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">delete</span> []_ps;</span><br><span class="line">_ps=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> *_ps;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里定义的Test类中是指向了外部对象的（<code>_ps=new int[5];</code>），如果仅仅是指针回退，而不析构对应的对象的话，会造成管理的内存资源泄露。</p><h1 id="空间配置器实现"><a href="#空间配置器实现" class="headerlink" title="空间配置器实现"></a>空间配置器实现</h1><p>所以很自然的就是想到，将<br>内存的开辟和对象的构造分开；<br>内存的释放和对象的析构分开。<br>而空间配置器就是为了实现这样的功能，具体为，空间配置器实现了几个比较重要的函数：</p><ul><li><code>allocate（）</code>，负责内存的开辟</li><li><code>deallocate（）</code>，负责内存的释放</li><li><code>construct（）</code>，负责对象的构造</li><li><code>destroy（）</code>，负责对象的析构</li></ul><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容器的空间配置其allocator 做四件事情  </span></span><br><span class="line"><span class="comment">//内存开辟/内存释放  对象构造/对象析构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Allocator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span> <span class="comment">//负责内存开辟</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p)</span>  <span class="comment">//负责内存释放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="type">const</span> T&amp; val)</span> <span class="comment">//负责对象构造</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">new</span> (p) <span class="built_in">T</span>(val); <span class="comment">//采用定位new的方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(T* p)</span> <span class="comment">//负责对象析构</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p-&gt;~<span class="built_in">T</span>();    <span class="comment">//~T()代表了T类型的析构函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样做的好处有，在声明对象的时候只是开辟内存空间，而不进行无意义的默认对象构造；并且在删除资源的时候，先执行对象的析构函数，确保对象指向的外部资源被释放后，才清除当前堆内存，步骤如下。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/74b4d38c4aee43588ceab8843e4f6441.png"                        alt="在这里插入图片描述"                 ></p><h1 id="实现空间配置器后的vector"><a href="#实现空间配置器后的vector" class="headerlink" title="实现空间配置器后的vector"></a>实现空间配置器后的vector</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 容器底层的内存开辟、内存释放，对象构造和析构,都通过allocator空间配置器来实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> size = <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只开辟内存空间</span></span><br><span class="line">_first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">_last = _first;</span><br><span class="line">_end = _first + size;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先析构容器有效元素</span></span><br><span class="line"><span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">&#123;</span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p); <span class="comment">//把内存中的有效元素进行析构操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后释放_first指向的堆内存</span></span><br><span class="line">_allocator.<span class="built_in">deallocate</span>(_first); </span><br><span class="line">_first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; cp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size = cp._end - cp._first;</span><br><span class="line"><span class="comment">//分配堆内存</span></span><br><span class="line">_first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"><span class="type">int</span> len = cp._last - cp._first;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//逐个根据cp的值构造对象</span></span><br><span class="line">_allocator.<span class="built_in">construct</span>(_first + i, cp._first[i]);</span><br><span class="line">&#125;</span><br><span class="line">_last = _first + len;</span><br><span class="line">_end = _first + size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt;&amp; cp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;cp)</span><br><span class="line"><span class="keyword">return</span>*<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把内存中的对象进行析构操作</span></span><br><span class="line"><span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">&#123;</span><br><span class="line">_allocator.<span class="built_in">destroy</span>(p); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放原来堆上的内存</span></span><br><span class="line">_allocator.<span class="built_in">deallocate</span>(_first); </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = cp._end - cp._first;</span><br><span class="line"><span class="comment">//申请新的内存空间</span></span><br><span class="line">_first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line"><span class="type">int</span> len = cp._last - cp._first;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//逐个根据cp的值构造对象</span></span><br><span class="line">_allocator.<span class="built_in">construct</span>(_first + i, cp._first[i]);</span><br><span class="line">&#125;</span><br><span class="line">_last = _first + len;</span><br><span class="line">_end = _first + size;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line"><span class="built_in">expand</span>();</span><br><span class="line"><span class="comment">//根据val的值在_last位置上构造对象</span></span><br><span class="line">_allocator.<span class="built_in">construct</span>(_last, val);</span><br><span class="line">_last++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//析构_last位置上的对象</span></span><br><span class="line">--_last;</span><br><span class="line">_allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;stack is empty&quot;</span>; <span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span> [] (<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;index out of range Exception&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> _first[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _first == _last; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _last == _end; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _last - _first; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _first; <span class="comment">//指向数组起始的位置</span></span><br><span class="line">T* _last;  <span class="comment">//指向数组中有效元素的后继位置</span></span><br><span class="line">T* _end;  <span class="comment">//指向数组的结尾</span></span><br><span class="line">Alloc _allocator; <span class="comment">//定义容器的空间配置器对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> size = _end - _first;</span><br><span class="line"><span class="comment">//分配原来2倍大小的内存空间</span></span><br><span class="line">T* ptmp = _allocator.<span class="built_in">allocate</span>(<span class="number">2</span> * size);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//逐个根据_first[i]的值构造对象</span></span><br><span class="line">_allocator.<span class="built_in">construct</span>(ptmp+i, _first[i]);</span><br><span class="line"><span class="comment">//逐个析构_first+i对象</span></span><br><span class="line">_allocator.<span class="built_in">destroy</span>(_first+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除原有堆内存空间</span></span><br><span class="line">_allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">_first = ptmp;</span><br><span class="line">_last = _first + size;</span><br><span class="line">_end = _first + <span class="number">2</span> * size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/bd83960e1adc476c94f47940bf68a17d.png"                        alt="在这里插入图片描述"                 ><br>从上图可以看到，实现了自定义的空间配置器之后，在定义<code>vector&lt;Test&gt; vec;</code> 时就不会出现没必要的对象构造了。</p><p>关于空间配置器的作用就先讲解到这了，空间配置器的实现可以参考。<br><a class="link"   href="https://zhuanlan.zhihu.com/p/331809729" >5 千字长文+ 30 张图解 | 陪你手撕 STL 空间配置器源码<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">空间配置器的理解</summary>
    
    
    
    <category term="STL模板库" scheme="https://localhost/categories/STL%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    
    
    <category term="c++" scheme="https://localhost/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>LiteHub之跨域访问CORS</title>
    <link href="https://localhost/undefined/LiteHub_CORS/"/>
    <id>https://localhost/undefined/LiteHub_CORS/</id>
    <published>2025-07-03T02:39:39.000Z</published>
    <updated>2025-07-12T05:49:59.298Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在浏览器安全模型中，同源策略是最重要的安全基石。<br>一个“域”是由3个要素组成的：</p><ul><li><strong>协议</strong>（如：http 或 https）</li><li><strong>主机</strong>（Host，如 <a class="link"   href="http://www.example.com/" >www.example.com<i class="fas fa-external-link-alt"></i></a> 或 127.0.0.1）</li><li><strong>端口</strong>（Port，如 80 或 8080）</li></ul><p>只要这三个完全一致，就是同源的。<br><strong>例如</strong>：</p><ul><li><a class="link"   href="http://example.com/" >http://example.com:80<i class="fas fa-external-link-alt"></i></a> 和 <a class="link"   href="http://example.com:8080/" >http://example.com:8080<i class="fas fa-external-link-alt"></i></a> 是不同源</li><li><a class="link"   href="http://example.com/" >http://example.com<i class="fas fa-external-link-alt"></i></a> 和 <a class="link"   href="https://example.com/" >https://example.com<i class="fas fa-external-link-alt"></i></a> 是不同源</li></ul><p>下面是官网解释跨域的图解：<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/75cbb0811c0344678ae998ab647cf543.png"                        alt="在这里插入图片描述"                 ></p><p><code>两种请求</code>：浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p> 按照 W3C 的 CORS 规范，只有完全满足「安全要求」的跨域请求，浏览器才会把它直接当成简单请求，直接发送给服务端，不需要先发 OPTIONS。<br> 必须同时满足以下条件</p><ol><li>请求方法必须是（<code>GET/HEAD/POST</code>）三者之一</li><li>请求头不能超出以下几个字段（<code>Accept、Accept-Language、Content-Language、Content-Type</code>）等</li><li><code>Content-Type</code>（如果存在的话），其值只能是<code>application/x-www-form-urlencoded、multipart/form-data、text/plain</code></li></ol><h3 id="非简单请求（预检请求）"><a href="#非简单请求（预检请求）" class="headerlink" title="非简单请求（预检请求）"></a>非简单请求（预检请求）</h3><p>非简单请求是指那些对服务器有特殊要求的请求，例如：</p><ul><li>使用PUT或DELETE方法</li><li>设置Content-Type为application&#x2F;json<br>即不满足简单请求的条件的都是预检请求（非简单请求）。</li></ul><p>对于这类请求，浏览器会在正式通信前额外发送一次HTTP查询请求（即预检请求），这个过程叫做预检<code>（Preflight）</code>。该请求会确认：</p><ol><li>当前网页域名是否在服务器的许可名单中</li><li>允许使用的HTTP方法和头信息字段<br>只有在获得服务器肯定答复后，浏览器才会发出正式的XMLHttpRequest请求，否则将报错。</li></ol><p>“预检请求”用的请求方法是 <code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字是 <code>Origin</code>，表示请求来自哪个源。<br>除了 Origin 字段，“预检请求”的头信息包括两个特殊字段。<br>• <code>Access-Control-Request-Method</code>：必须字段，列出浏览器的 CORS 请求会用到哪些 HTTP 方法；<br>• <code>Access-Control-Request-Headers</code>：这个字段是一个逗号 , 分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上面示例是 X-Custom-Header。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p> <strong>CORS</strong>（Cross-Origin Resource Sharing，跨域资源共享）通过在响应头里加上一组特殊字段来告诉浏览器，这个资源允许被某些源访问。</p><h3 id="服务器端Cors的关键配置"><a href="#服务器端Cors的关键配置" class="headerlink" title="服务器端Cors的关键配置"></a>服务器端Cors的关键配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CorsConfig</span> </span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; allowedOrigins;<span class="comment">//允许哪些域名可以访问</span></span><br><span class="line">    std::vector&lt;std::string&gt; allowedMethods; <span class="comment">//允许哪些方法可以跨域调用</span></span><br><span class="line">    std::vector&lt;std::string&gt; allowedHeaders; <span class="comment">//允许前端请求里带哪些请求头</span></span><br><span class="line">    <span class="type">bool</span> allowCredentials = <span class="literal">false</span>; <span class="comment">//不允许携带Cookie/Authorization header/TLS client cert 这类凭证信息</span></span><br><span class="line">    <span class="type">int</span> maxAge = <span class="number">3600</span>;             <span class="comment">//浏览器缓存预检请求的最大时长, 1 小时内同样的跨域请求只会发送一次 OPTIONS，之后直接用缓存的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> CorsConfig <span class="title">defaultConfig</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CorsConfig config;</span><br><span class="line">        config.allowedOrigins = &#123;<span class="string">&quot;*&quot;</span>&#125;; <span class="comment">//这里允许的是所有域名</span></span><br><span class="line">        config.allowedMethods = &#123;<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>&#125;; <span class="comment">//在预检请求（OPTIONS）的响应里告诉浏览器：后端接受哪些方法</span></span><br><span class="line">        config.allowedHeaders = &#123;<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;Authorization&quot;</span>&#125;; <span class="comment">//允许前端带Content-Type（比如 application/json）和Authorization（携带JWT Token等）</span></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="服务端解析预检请求"><a href="#服务端解析预检请求" class="headerlink" title="服务端解析预检请求"></a>服务端解析预检请求</h3><p>处理客户端发来的请求的流程如下：</p><ol><li>判断是否是预检请求，如果是，进入下一步；否则不做处理（正常的请求，继续后续的处理流程，响应）</li><li>检查当前请求的源是否被允许，如果允许当前请求源则在响应头中添加该源字段，状态码为204 No content,响应体为空，进入下一步</li><li>直接抛出特殊的响应对象（中断后续的处理流程）</li></ol><p><code>总结</code>：如果是预检请求，设置Cors的相关字段，直接返回；否则就进入正常的处理流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief 请求前钩子，所有请求进来时都会先执行</span></span><br><span class="line"><span class="comment"> * 如果是跨域的 OPTIONS 预检请求，直接构造响应并抛出，跳过后续中间件/路由逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CorsMiddleware::before</span><span class="params">(HttpRequest&amp; request)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">&quot;CorsMiddleware::before - Processing request&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是浏览器发起的预检请求（CORS Preflight）</span></span><br><span class="line">    <span class="keyword">if</span> (request.<span class="built_in">method</span>() == HttpRequest::Method::kOptions) </span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;Processing CORS preflight request&quot;</span>;</span><br><span class="line">        HttpResponse response;  <span class="comment">// 创建预检响应</span></span><br><span class="line">        <span class="built_in">handlePreflightRequest</span>(request, response);</span><br><span class="line">        <span class="comment">// 直接中断后续处理流程，抛出特殊的响应对象</span></span><br><span class="line">        <span class="keyword">throw</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理 CORS 预检请求（OPTIONS）</span></span><br><span class="line"><span class="comment"> * 会校验 Origin，并返回允许的跨域头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CorsMiddleware::handlePreflightRequest</span><span class="params">(<span class="type">const</span> HttpRequest&amp; request, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          HttpResponse&amp; response)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">     <span class="comment">// 从请求头获取 Origin</span></span><br><span class="line">    <span class="type">const</span> std::string&amp; origin = request.<span class="built_in">getHeader</span>(<span class="string">&quot;Origin&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验是否允许跨域</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isOriginAllowed</span>(origin)) </span><br><span class="line">    &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">&quot;Origin not allowed: &quot;</span> &lt;&lt; origin;</span><br><span class="line">        response.<span class="built_in">setStatusCode</span>(HttpResponse::k403Forbidden);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加允许的跨域头,对预检请求返回 204 No Content；</span></span><br><span class="line">    <span class="comment">//即响应体为空，对应返回的是options字段的预检请求的响应</span></span><br><span class="line">    <span class="built_in">addCorsHeaders</span>(response, origin);</span><br><span class="line">    response.<span class="built_in">setStatusCode</span>(HttpResponse::k204NoContent);</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;Preflight request processed successfully&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检查给定 Origin 是否在允许列表里</span></span><br><span class="line"><span class="comment"> * @param origin 来自浏览器请求头的 Origin</span></span><br><span class="line"><span class="comment"> * @return true 如果允许跨域，否则 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CorsMiddleware::isOriginAllowed</span><span class="params">(<span class="type">const</span> std::string&amp; origin)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config_.allowedOrigins.<span class="built_in">empty</span>() || </span><br><span class="line">           std::<span class="built_in">find</span>(config_.allowedOrigins.<span class="built_in">begin</span>(), </span><br><span class="line">                    config_.allowedOrigins.<span class="built_in">end</span>(), <span class="string">&quot;*&quot;</span>) != config_.allowedOrigins.<span class="built_in">end</span>() ||</span><br><span class="line">           std::<span class="built_in">find</span>(config_.allowedOrigins.<span class="built_in">begin</span>(), </span><br><span class="line">                    config_.allowedOrigins.<span class="built_in">end</span>(), origin) != config_.allowedOrigins.<span class="built_in">end</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 给响应添加标准的 CORS 头信息</span></span><br><span class="line"><span class="comment"> * @param response 当前响应对象</span></span><br><span class="line"><span class="comment"> * @param origin 本次请求允许的 Origin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CorsMiddleware::addCorsHeaders</span><span class="params">(HttpResponse&amp; response, </span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> std::string&amp; origin)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 设置允许的 Origin</span></span><br><span class="line">        response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, origin);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 是否允许携带 cookie</span></span><br><span class="line">        <span class="keyword">if</span> (config_.allowCredentials) </span><br><span class="line">        &#123;</span><br><span class="line">            response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置允许的方法列表,以，分割</span></span><br><span class="line">        <span class="keyword">if</span> (!config_.allowedMethods.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, </span><br><span class="line">                             <span class="built_in">join</span>(config_.allowedMethods, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置允许的自定义请求头列表</span></span><br><span class="line">        <span class="keyword">if</span> (!config_.allowedHeaders.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, </span><br><span class="line">                             <span class="built_in">join</span>(config_.allowedHeaders, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置预检结果的缓存时间（单位：秒）</span></span><br><span class="line">        response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, </span><br><span class="line">                          std::<span class="built_in">to_string</span>(config_.maxAge));</span><br><span class="line">        </span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">&quot;CORS headers added successfully&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) </span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;Error adding CORS headers: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 工具函数：把字符串数组用指定分隔符拼接起来</span></span><br><span class="line"><span class="comment"> * @param strings 字符串列表</span></span><br><span class="line"><span class="comment"> * @param delimiter 分隔符，如 &quot;, &quot;</span></span><br><span class="line"><span class="comment"> * @return 拼接后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">CorsMiddleware::join</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; strings, <span class="type">const</span> std::string&amp; delimiter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ostringstream result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; strings.<span class="built_in">size</span>(); ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) result &lt;&lt; delimiter;</span><br><span class="line">        result &lt;&lt; strings[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="服务端填充响应"><a href="#服务端填充响应" class="headerlink" title="服务端填充响应"></a>服务端填充响应</h3><p>这里的响应指的是正常处理客户端发来的请求后，在最终的响应头中添加CORS的相关信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 请求后钩子，正常请求处理完毕后执行。</span></span><br><span class="line"><span class="comment"> * 不管是否跨域，都会在最终响应头里加上 CORS 相关头信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CorsMiddleware::after</span><span class="params">(HttpResponse&amp; response)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">&quot;CorsMiddleware::after - Processing response&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接添加CORS头，简化处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (!config_.allowedOrigins.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果允许所有源</span></span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">find</span>(config_.allowedOrigins.<span class="built_in">begin</span>(), config_.allowedOrigins.<span class="built_in">end</span>(), <span class="string">&quot;*&quot;</span>) </span><br><span class="line">            != config_.allowedOrigins.<span class="built_in">end</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">addCorsHeaders</span>(response, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 简单处理：只取第一个允许的来源（可以按需改成匹配实际请求来源）</span></span><br><span class="line">            <span class="built_in">addCorsHeaders</span>(response, config_.allowedOrigins[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/e74a04417e2d40dbb540010d130aeaf4.png"                        alt="在这里插入图片描述"                 ><br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/61a6cca783da4a9887a2a849fe667172.png"                        alt="在这里插入图片描述"                 ><br>上图展示了请求与响应的抓包分析数据：当客户端向服务器请求加载登录页面时，服务器不仅会在响应体中返回HTML文件，还会在响应头中附带CORS配置信息供浏览器解析。<br><a class="link"   href="https://developer.aliyun.com/article/917300" >CORS 详解，终于不用担心跨域问题了<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">处理客户端发来的请求的流程如下： 1. 判断是否是预检请求，如果是，进入下一步；否则不做处理（正常的请求，继续后续的处理流程，响应） 2. 检查当前请求的源是否被允许，如果允许当前请求源则在响应头中添加该源字段，状态码为204 No content,响应体为空，进入下一步 3. 直接抛出特殊的响应对象（中断后续的处理流程）</summary>
    
    
    
    <category term="Http后端服务器" scheme="https://localhost/categories/Http%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="后端" scheme="https://localhost/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>LiteHub之会话管理</title>
    <link href="https://localhost/undefined/LiteHub_session/"/>
    <id>https://localhost/undefined/LiteHub_session/</id>
    <published>2025-06-26T02:29:52.000Z</published>
    <updated>2025-07-12T05:50:26.624Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="会话管理理论"><a href="#会话管理理论" class="headerlink" title="会话管理理论"></a>会话管理理论</h1><h2 id="为什么进行会话管理"><a href="#为什么进行会话管理" class="headerlink" title="为什么进行会话管理"></a>为什么进行会话管理</h2><h3 id="HTTP协议的特性与局限性"><a href="#HTTP协议的特性与局限性" class="headerlink" title="HTTP协议的特性与局限性"></a>HTTP协议的特性与局限性</h3><p>Web应用程序的基础是HTTP（Hypertext Transfer Protocol）协议，该协议在设计时具有以下核心特点：</p><ol><li><p><strong>请求&#x2F;响应模式</strong>：</p><ul><li>每次HTTP交互都遵循”客户端发起请求→服务器返回响应”的固定模式</li><li>例如：用户访问电商网站时，点击商品页、加入购物车、结算等都是独立的请求</li><li>各请求之间没有内在关联，服务器无法自动识别这些请求是否来自同一用户</li></ul></li><li><p><strong>无状态性（Stateless）</strong>：</p><ul><li>协议本身不保存任何历史交互信息</li><li>每个请求都被视为全新的交互，服务器不会”记住”之前的请求</li><li>实际案例：刷新网页后，登录状态、表单填写内容等都将丢失</li></ul></li><li><p><strong>无连接特性</strong>：</p><ul><li>每次TCP连接只处理一个请求&#x2F;响应</li><li>请求完成后立即断开连接以节省资源</li><li>导致的问题：无法维持长期对话，如在线聊天、多步骤表单等场景难以实现</li></ul></li></ol><h3 id="现实应用的需求矛盾"><a href="#现实应用的需求矛盾" class="headerlink" title="现实应用的需求矛盾"></a>现实应用的需求矛盾</h3><p>虽然HTTP的这些特性使其简单高效，但现代Web应用需要：</p><ul><li>用户登录状态保持（如保持7天免登录）</li><li>购物车商品跨页面保存</li><li>多步骤表单数据暂存</li><li>个性化内容推荐（基于历史浏览）</li></ul><p>因此需要引入<strong>会话管理机制</strong>来：</p><ol><li>识别同一用户的连续请求</li><li>在服务器端存储用户特定数据</li><li>维持应用的状态连续性</li></ol><p>常见解决方案包括：</p><ul><li>Cookie技术</li><li>Session会话</li><li>Token令牌（如JWT）</li><li>URL重写技术</li></ul><p>在这个项目中，我们使用的就是Session会话和Cookie技术结合使用来记录用户登录状态。</p><h2 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h2><ul><li>服务器为每个用户浏览器创建一个会话对象（session对象），一个浏览器只能产生一个session</li><li>当新建一个窗口访问服务器时，还是原来的那个session。session中默认保存的是当前用户的信息。因此，在需要保存其他用户数据时，我们可以自己给session添加属性。</li><li>session（会话）可以看为是一种标识，通过带session的请求，可以让服务器知道是谁在请求数据。</li></ul><h2 id="Session与cookie的区别与联系"><a href="#Session与cookie的区别与联系" class="headerlink" title="Session与cookie的区别与联系"></a>Session与cookie的区别与联系</h2><ul><li>session是由服务器创建的，并保存在服务器上的。在session创建好之后，会把sessionId（会话的唯一标识符）放在cookie中返回（response）给客户端。客户端将cookie是保存在客户端的。</li><li>以后的每次请求都携带cookie，cookie中的内容是sessionId值。</li><li>session的过期和超时与cookie的过期无直接联系，都是可以分别进行设置的。当session或cookie中任意一方过期，那么用户就需要重新登录了</li></ul><p>注意：虽然 Cookie 是最主流的方式，但如果用户禁用 Cookie，服务器还可以通过其他方式传递 Session ID：<br><strong>URL 重写</strong>： 将 Session ID 作为查询参数附加到每个 URL 后面 (如 ?sessionid&#x3D;abc123xyz)。这种方式不太安全（容易泄露）且不美观。<br><strong>隐藏表单域</strong>： 将 Session ID 放在 HTML 表单的隐藏字段中。仅适用于表单提交。</p><p>所以sessionid和cookie的更准确描述是：Session 机制通常利用 Cookie 用于在客户端存储和传递标识服务器端 Session 数据的 Session ID。Cookie 是 Session ID 的载体，而非 Session 生成了 Cookie。 服务器端的 Session 管理代码负责生成 Session ID 并指示浏览器（通过 Set-Cookie）存储它。</p><p><a class="link"   href="https://blog.csdn.net/qq_44627608/article/details/106277191" >第六章 会话管理（Session）<i class="fas fa-external-link-alt"></i></a></p><h1 id="会话管理代码实现"><a href="#会话管理代码实现" class="headerlink" title="会话管理代码实现"></a>会话管理代码实现</h1><p>会话管理中共实现了四个类实现：</p><ul><li>Session(会话)：表示一个会话。</li><li>SessionManager(会话管理器)：用于管理多个会话的声明周期。</li><li>SessionStorage(会话存储)：会话存储实现的抽象类。</li><li>MemorySessionStorage(内存会话存储)：继承SessionStorage，具体的会话存储实现类。</li></ul><h2 id="Session类实现"><a href="#Session类实现" class="headerlink" title="Session类实现"></a>Session类实现</h2><ul><li>Session 构造函数，用于初始化会话实例，记录 sessionId、设置最长有效时间（默认值为 1 小时）并关联会话管理器。</li><li>isExpired（），判断当前会话是否过期</li><li>refresh（），刷新过期时间，当前时间加上最长有效时间（默认为一小时）</li><li>setValue（），以键值对形式存储会话数据</li><li>getValue（），根据传入key获取相应的会话数据（value）</li><li>remove(),根据传入key删除相应的会话数据（value）</li><li>clear()，清空所有会话数据</li></ul><p> 总结，session类实现了记录会话唯一标识符，维持会话过期时间，更新会话数据功能。</p><h2 id="SessionManager类实现"><a href="#SessionManager类实现" class="headerlink" title="SessionManager类实现"></a>SessionManager类实现</h2><ul><li>SessionManager 构造函数，用于配置会话存储对象（负责会话存储）和随机数生成器（用于生成随机的会话ID）</li><li>getSession（）函数会从请求中提取cookie字段以获取sessionid，并返回相应的会话；若cookie不存在或者会话已过期，则创建一个新会话。</li><li>generateSessionId（），生成一个唯一的会话标识符</li><li>destroySession（），从存储中移除会话</li><li>getSessionIdFromCookie（），从请求中的cookie字段获取sessionId</li><li>setSessionCookie（），在响应中设置cookie</li></ul><p>这几个函数比较重要，放这里注释一下，便于理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从req请求中解析出sessionId</span></span><br><span class="line"><span class="function">std::string <span class="title">SessionManager::getSessionIdFromCookie</span><span class="params">(<span class="type">const</span> HttpRequest&amp; req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sessionId;</span><br><span class="line">    std::string cookie = req.<span class="built_in">getHeader</span>(<span class="string">&quot;Cookie&quot;</span>);<span class="comment">//找到Cookie字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cookie.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//格式一般为</span></span><br><span class="line">    <span class="comment">//Cookie: sessionId=1dd3ce798f86bf092595840ac8ecadc8\r\n</span></span><br><span class="line">        <span class="type">size_t</span> pos = cookie.<span class="built_in">find</span>(<span class="string">&quot;sessionId=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            pos += <span class="number">10</span>; <span class="comment">// 跳过&quot;sessionId=&quot;</span></span><br><span class="line">            <span class="type">size_t</span> end = cookie.<span class="built_in">find</span>(<span class="string">&#x27;;&#x27;</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (end != std::string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                sessionId = cookie.<span class="built_in">substr</span>(pos, end - pos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//从pos开始截取到字符串结束</span></span><br><span class="line">                sessionId = cookie.<span class="built_in">substr</span>(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sessionId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成唯一的会话标识符，确保会话的唯一性和安全性</span></span><br><span class="line"><span class="function">std::string <span class="title">SessionManager::generateSessionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成32个字符的会话ID，每个字符是一个十六进制数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ss &lt;&lt; std::hex &lt;&lt; <span class="built_in">dist</span>(rng_);<span class="comment">//生成一个0~15之间的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在响应中添加cookie字段</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SessionManager::setSessionCookie</span><span class="params">(<span class="type">const</span> std::string&amp; sessionId, HttpResponse* resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置会话ID到响应头中，作为Cookie</span></span><br><span class="line">    std::string cookie = <span class="string">&quot;sessionId=&quot;</span> + sessionId + <span class="string">&quot;; Path=/; HttpOnly&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Set-Cookie&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Session&gt; <span class="title">SessionManager::getSession</span><span class="params">(<span class="type">const</span> HttpRequest&amp; req, HttpResponse* resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="comment">//从请求中的cookie字段中取出sessionid</span></span><br><span class="line">    std::string sessionId = <span class="built_in">getSessionIdFromCookie</span>(req);</span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;Session&gt; session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sessionId.<span class="built_in">empty</span>())<span class="comment">//如果sessionId存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        session = storage_-&gt;<span class="built_in">load</span>(sessionId); <span class="comment">//根据sessionId获取对应会话</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!session || session-&gt;<span class="built_in">isExpired</span>())<span class="comment">//如果sesseion不存在或者说session过期，重新创建一个</span></span><br><span class="line">    &#123;</span><br><span class="line">        sessionId = <span class="built_in">generateSessionId</span>();<span class="comment">//生成唯一的sessionId</span></span><br><span class="line">        session = std::<span class="built_in">make_shared</span>&lt;Session&gt;(sessionId, <span class="keyword">this</span>);<span class="comment">//传入sessionid和SessionManager构建一个会话</span></span><br><span class="line">        <span class="built_in">setSessionCookie</span>(sessionId, resp);<span class="comment">//在响应resp中setCookie中添加sessionId</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        session-&gt;<span class="built_in">setManager</span>(<span class="keyword">this</span>); <span class="comment">// 为现有会话设置管理器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    session-&gt;<span class="built_in">refresh</span>();<span class="comment">//刷新会话的过期时间，因为当前有新的访问，过期时间需要重新被设置</span></span><br><span class="line">    storage_-&gt;<span class="built_in">save</span>(session);  <span class="comment">// 保存会话</span></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MemorySessionStorage类实现"><a href="#MemorySessionStorage类实现" class="headerlink" title="MemorySessionStorage类实现"></a>MemorySessionStorage类实现</h2><p><code>SessionStorage</code>定义了抽象类提供了<code>save()</code>、<code>load()</code>、<code>remove()</code>接口，而<code>MemorySessionStorage</code>对重写了这些函数。<br><code>MemorySessionStorage</code>是以&lt;<code>std::string, std::shared_ptr&lt;Session&gt;</code>&gt;构造的无序键值对保存的。</p><ul><li>save()函数，保存会话</li><li>load()函数，根据sessionId找到对应的会话，如果会话过期则删除会话；否则返回会话</li><li>remove()函数，通过sessionId删除会话</li></ul><h1 id="会话管理抓包分析"><a href="#会话管理抓包分析" class="headerlink" title="会话管理抓包分析"></a>会话管理抓包分析</h1><h2 id="1-首次访问网页"><a href="#1-首次访问网页" class="headerlink" title="1.首次访问网页"></a>1.首次访问网页</h2><p>此时还没登录（此时还不需要维护用户的登录状态），这时的请求中还没有<code>cookie</code>字段。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/08f8daca559f40ee8c83dd666ec080b5.png"                        alt="在这里插入图片描述"                 ><br>这是发起的请求是为了请求网页，<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/71bba484dc7d4a6d98c6fb723fd6218b.png"                        alt="在这里插入图片描述"                 ><br>服务器返回的响应，可以看到，此时服务器也没有set-cookie字段；此时服务器返回前端渲染需要的网页（响应体中）<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/550ea7ce108843f08c513b47d9b4c3a2.png"                        alt="在这里插入图片描述"                 ></p><h2 id="2-点击登录时"><a href="#2-点击登录时" class="headerlink" title="2.点击登录时"></a>2.点击登录时</h2><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/f6ef959b27ab4bbb8050a51b39312a21.png"                        alt="在这里插入图片描述"                 ><br>这时可以看到请求的报文，是以POST方式将用户登录的<code>username</code>和<code>password</code>上传到服务器（这里是明文传输，这是HTTP的缺点，在网络传输中容易被抓包导致密码和账户泄露；后面这个项目看能不能扩展成HTTPS协议）<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/ac11c9437eb945ce8d031d021ad06438.png"                        alt="在这里插入图片描述"                 ></p><h2 id="3-服务器处理"><a href="#3-服务器处理" class="headerlink" title="3.服务器处理"></a>3.服务器处理</h2><p>此时通过点击登录按钮，将登录请求发送到服务器，服务器根据相应的路由，转发到专门用于登录处理的函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据账号密码，查找数据库是否有该账号密码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LoginHandler::queryUserId</span><span class="params">(<span class="type">const</span> std::string &amp;username, <span class="type">const</span> std::string &amp;password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 前端用户传来账号密码，查找数据库是否有该账号密码</span></span><br><span class="line">    <span class="comment">// 使用预处理语句, 防止sql注入</span></span><br><span class="line">    std::string sql = <span class="string">&quot;SELECT id FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line">    sql::ResultSet* res = mysqlUtil_.<span class="built_in">executeQuery</span>(sql, username, password);</span><br><span class="line">    <span class="keyword">if</span> (res-&gt;<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = res-&gt;<span class="built_in">getInt</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果查询结果为空，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoginHandler::handle</span><span class="params">(<span class="type">const</span> http::HttpRequest &amp;req, http::HttpResponse *resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 解析使用 try catch 捕获异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        json parsed = json::<span class="built_in">parse</span>(req.<span class="built_in">getBody</span>());</span><br><span class="line">        std::string username = parsed[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">        std::string password = parsed[<span class="string">&quot;password&quot;</span>]; <span class="comment">//从请求体中解析得到username 和password </span></span><br><span class="line">        <span class="comment">// 验证用户是否存在，是否注册过</span></span><br><span class="line">        <span class="type">int</span> userId = <span class="built_in">queryUserId</span>(username, password);</span><br><span class="line">        <span class="keyword">if</span> (userId != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取会话</span></span><br><span class="line">            <span class="keyword">auto</span> session = server_-&gt;<span class="built_in">getSessionManager</span>()-&gt;<span class="built_in">getSession</span>(req, resp);</span><br><span class="line">                     </span><br><span class="line">            <span class="comment">// 在会话中存储用户信息</span></span><br><span class="line">            session-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;userId&quot;</span>, std::<span class="built_in">to_string</span>(userId));</span><br><span class="line">            session-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">            session-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;isLoggedIn&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 账号密码错误，请重新登录</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 封装json数据，返回401未认证状态码</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//...其他代码，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 server_-&gt;getSessionManager()-&gt;getSession(req, resp)负责返回会话，或者新建会话，具体为：</p><ol><li>如果当前用户存在会话并且会话有效，则直接返回会话</li><li>否则创建新的会话（这里是首次登录，所以默认就是这种情况）</li></ol><p> 并在会话中存储如<code>&quot;userId&quot;</code>，<code>&quot;username&quot;</code>，<code>&quot;isLoggedIn&quot;</code>字段。</p><h2 id="4-服务器返回响应"><a href="#4-服务器返回响应" class="headerlink" title="4.服务器返回响应"></a>4.服务器返回响应</h2><p>在getSession(req, resp)—&gt;&gt;&gt;setSessionCookie(sessionId, resp);设置响应报文</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SessionManager::setSessionCookie</span><span class="params">(<span class="type">const</span> std::string&amp; sessionId, HttpResponse* resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置会话ID到响应头中，作为Cookie</span></span><br><span class="line">    std::string cookie = <span class="string">&quot;sessionId=&quot;</span> + sessionId + <span class="string">&quot;; Path=/; HttpOnly&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Set-Cookie&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/0ee73f6b2f5446bb8e45afc64683d174.png"                        alt="在这里插入图片描述"                 ><br>服务器响应设置了cookie字段，以后的客户端的每次请求都将携带这个字段。</p><h2 id="5-客户端的下一次请求"><a href="#5-客户端的下一次请求" class="headerlink" title="5.客户端的下一次请求"></a>5.客户端的下一次请求</h2><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/c604bf7fb5cb42809931475c02591467.png"                        alt="在这里插入图片描述"                 ><br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/40fc672056244281a431b3f46fb052a4.png"                        alt="在这里插入图片描述"                 ><br>从上图可知，设置cookie之后的每一次请求，都会带上cookie这个字段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;



&lt;h1 id=&quot;会话管理理论&quot;&gt;&lt;a href=&quot;#会话管理理论&quot; class=&quot;headerlink&quot; title=&quot;会话管理理论&quot;&gt;&lt;/a&gt;会话管理理论&lt;/h1&gt;&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Http后端服务器" scheme="https://localhost/categories/Http%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="后端" scheme="https://localhost/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>LiteHub之请求与响应报文分析</title>
    <link href="https://localhost/undefined/LiteHub_req_res/"/>
    <id>https://localhost/undefined/LiteHub_req_res/</id>
    <published>2025-06-25T02:30:38.000Z</published>
    <updated>2025-07-12T05:50:23.131Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>这一篇文章是基于项目LITEHUB分析的关于HTTP的请求和响应篇章，后续将仔细分析这个项目所涉及到的知识点。<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/49c726370aa54794af9a8023297f7a72.png"                        alt="在这里插入图片描述"                 ><br>上图是使用wireshark抓包分析的HTTP刷新网页的请求以及返回的响应报文格式。接下来我们就详细分析：</p><h1 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h1><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>请求报文主要由请求行、请求头、空行、请求头构成。<br>  <img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/29d71662fbe745d689994e83ac0a9858.png"                        alt="在这里插入图片描述"                 ><br>请求行包括一下字段：常见的方法包括GET（请求信息）、POST（提交数据，表单）方法等，资源路径（请求资源的URI路径）、HTTP的版本（HTTP1.1&#x2F;HTTP2.0）<br>请求头的字段较多，常使用的包含以下几个：<br>● Host：请求的服务器的域名。<br>● Accept：客户端能够处理的媒体类型。<br>● Accept-Encoding：客户端能够解码的内容编码。<br>● Authorization：用于认证的凭证信息，比如token数据。<br>● Content-Length：请求体的长度。<br>● Content-Type：请求体的媒体类型。<br>● Cookie：存储在客户端的cookie数据，在我的项目中，也是通过存在cookie字段来区别不同用户。</p><p>空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。<br>而请求体通常用于 POST 和 PUT 请求，包含发送给服务器的数据。</p><h2 id="wireshark抓包分析"><a href="#wireshark抓包分析" class="headerlink" title="wireshark抓包分析"></a>wireshark抓包分析</h2><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/54936fec86004e329ee8fb88432d460b.png"                        alt="在这里插入图片描述"                 ></p><ul><li>请求行：这里使用请求方法为<code>GET</code>,请求的路径为<code>/resource/list</code>（服务器通过路由转发确定其实际请求的路径资源，后面会分析），并且使用的版本号是<code>HTTP/1.1</code>.</li><li>请求头：是以一系列的键值对组成的。如上图包括<code>Host:192.168.83.128</code>(表示请求的服务器的域名，这个字段是为了区分在一个服务器上存在多个地址的问题，如百度和edge都在一台服务器的不同网卡上服务，通过这个字段可以区分)；<code>Cookie: sessionId=ef4130be9ef3c2b7264455b2a201a1b1</code>（保持访问的一个状态），其余字段感兴趣的话可以自己去了解</li><li>空行： <code>\r\n</code>，用于分割请求头和请求体；</li><li>请求体：这里为空；</li></ul><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>上面我们已经分析了请求体的格式，接下来我们就根据格式，通过代码解析请求报文。</p><p>在<code>HttpContext.h</code>中定义解析的状态，只有当前状态成功解析完成后，才可以转到下一个状态；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpRequestParseState</span></span><br><span class="line">&#123;</span><br><span class="line">    kExpectRequestLine, <span class="comment">// 解析请求行</span></span><br><span class="line">    kExpectHeaders, <span class="comment">// 解析请求头</span></span><br><span class="line">    kExpectBody, <span class="comment">// 解析请求体</span></span><br><span class="line">    kGotAll, <span class="comment">// 解析完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>HttpContext.c</code>中定义两个标志，用于标志每个状态解析是否出错以及是否解析完成（如果请求体有值，就需要解析到请求体；如果请求体为空，则解析到空行就行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> ok = <span class="literal">true</span>; <span class="comment">// 解析每行请求格式是否正确</span></span><br><span class="line"><span class="type">bool</span> hasMore = <span class="literal">true</span>; <span class="comment">//是否还需要解析</span></span><br></pre></td></tr></table></figure><h3 id="1-请求行解析"><a href="#1-请求行解析" class="headerlink" title="1.请求行解析"></a>1.请求行解析</h3><p>当前的请求行是这样：<code>GET /resource/list HTTP/1.1\r\n</code><br>请看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (state_ == kExpectRequestLine)</span><br><span class="line">        &#123;   </span><br><span class="line">        <span class="comment">//找到\r\n</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *crlf = buf-&gt;<span class="built_in">findCRLF</span>(); <span class="comment">// 注意这个返回值边界可能有错</span></span><br><span class="line">            <span class="keyword">if</span> (crlf)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//(buf-&gt;peek(), crlf)区间;其实就对应GET /resource/list HTTP/1.1</span></span><br><span class="line">                ok = <span class="built_in">processRequestLine</span>(buf-&gt;<span class="built_in">peek</span>(), crlf);</span><br><span class="line">                <span class="keyword">if</span> (ok)</span><br><span class="line">                &#123;</span><br><span class="line">                    request_.<span class="built_in">setReceiveTime</span>(receiveTime);</span><br><span class="line">                    <span class="comment">//向后移动两个字符，跳过\r\n</span></span><br><span class="line">                    buf-&gt;<span class="built_in">retrieveUntil</span>(crlf + <span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//并设置状态为kExpectHeaders，用于解析请求头</span></span><br><span class="line">                    state_ = kExpectHeaders;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">//如果解析出错，停止解析</span></span><br><span class="line">                    hasMore = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//如果请求行没有找到\r\n，说明请求行格式错误，停止解析</span></span><br><span class="line">                hasMore = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义专门用来解析请求行的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpContext::processRequestLine</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *begin, <span class="type">const</span> <span class="type">char</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> succeed = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *start = begin;</span><br><span class="line">    <span class="comment">//以这个为例，GET /resource/list HTTP/1.1</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *space = std::<span class="built_in">find</span>(start, end, <span class="string">&#x27; &#x27;</span>);<span class="comment">//找到第一个空格</span></span><br><span class="line">    <span class="keyword">if</span> (space != end &amp;&amp; request_.<span class="built_in">setMethod</span>(start, space))<span class="comment">//将GET截取出来并存储到request_的请求方法字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        start = space + <span class="number">1</span>;</span><br><span class="line">        space = std::<span class="built_in">find</span>(start, end, <span class="string">&#x27; &#x27;</span>);<span class="comment">//继续找下一个空格</span></span><br><span class="line">        <span class="keyword">if</span> (space != end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *argumentStart = std::<span class="built_in">find</span>(start, space, <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (argumentStart != space) <span class="comment">// 请求带参数</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//GET /search?q=example HTTP/1.1,类似这种会被解析为路径和对应参数</span></span><br><span class="line">                request_.<span class="built_in">setPath</span>(start, argumentStart); <span class="comment">// 注意这些返回值边界</span></span><br><span class="line">                request_.<span class="built_in">setQueryParameters</span>(argumentStart + <span class="number">1</span>, space);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 请求不带参数</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//将/resource/list添加到请求路径中</span></span><br><span class="line">                request_.<span class="built_in">setPath</span>(start, space);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            start = space + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//&quot;HTTP/1.1&quot;或者&quot;HTTP/1.0&quot;都是8个字节</span></span><br><span class="line">            succeed = ((end - start == <span class="number">8</span>) &amp;&amp; std::<span class="built_in">equal</span>(start, end - <span class="number">1</span>, <span class="string">&quot;HTTP/1.&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (succeed)</span><br><span class="line">            &#123;<span class="comment">//设置HTTP版本协议号</span></span><br><span class="line">                <span class="keyword">if</span> (*(end - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    request_.<span class="built_in">setVersion</span>(<span class="string">&quot;HTTP/1.1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (*(end - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    request_.<span class="built_in">setVersion</span>(<span class="string">&quot;HTTP/1.0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    succeed = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> succeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是从问号后面分割参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::setQueryParameters</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *start, <span class="type">const</span> <span class="type">char</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">argumentStr</span><span class="params">(start, end)</span></span>;</span><br><span class="line">    std::string::size_type pos = <span class="number">0</span>;</span><br><span class="line">    std::string::size_type prev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按 &amp; 分割多个参数</span></span><br><span class="line">    <span class="keyword">while</span> ((pos = argumentStr.<span class="built_in">find</span>(<span class="string">&#x27;&amp;&#x27;</span>, prev)) != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string pair = argumentStr.<span class="built_in">substr</span>(prev, pos - prev);</span><br><span class="line">        std::string::size_type equalPos = pair.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (equalPos != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string key = pair.<span class="built_in">substr</span>(<span class="number">0</span>, equalPos);</span><br><span class="line">            std::string value = pair.<span class="built_in">substr</span>(equalPos + <span class="number">1</span>);</span><br><span class="line">            queryParameters_[key] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后一个参数</span></span><br><span class="line">    std::string lastPair = argumentStr.<span class="built_in">substr</span>(prev);</span><br><span class="line">    std::string::size_type equalPos = lastPair.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (equalPos != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string key = lastPair.<span class="built_in">substr</span>(<span class="number">0</span>, equalPos);</span><br><span class="line">        std::string value = lastPair.<span class="built_in">substr</span>(equalPos + <span class="number">1</span>);</span><br><span class="line">        queryParameters_[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据上述函数，我们就解析出来了请求行的三个字段，请求方法、url路径、以及Http的版本号。接下来就开始解析请求头了。</p><h3 id="2-请求头解析"><a href="#2-请求头解析" class="headerlink" title="2.请求头解析"></a>2.请求头解析</h3><p>根据上述分析，请求头是以键值对形式存储的（每一行存储一个键值对），并且键和值的分割是以“：”分割，基于这个分析，请求头就比较好解析了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (state_ == kExpectHeaders)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//找到&#x27;:&#x27;</span></span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">char</span> *colon = std::find(buf-&gt;peek(), crlf, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (colon &lt; crlf)</span><br><span class="line">                &#123;</span><br><span class="line">                    request_.addHeader(buf-&gt;peek(), colon, crlf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (buf-&gt;peek() == crlf)</span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">// 如果找到空行，则结束Header</span></span><br><span class="line">                    <span class="comment">// 根据请求方法和Content-Length判断是否需要继续读取body</span></span><br><span class="line">                    <span class="keyword">if</span> (request_.method() == HttpRequest::kPost || </span><br><span class="line">                        request_.method() == HttpRequest::kPut)</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::<span class="built_in">string</span> contentLength = request_.getHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (!contentLength.empty())</span><br><span class="line">                        &#123;</span><br><span class="line">                            request_.setContentLength(std::stoi(contentLength));</span><br><span class="line">                            <span class="keyword">if</span> (request_.contentLength() &gt; <span class="number">0</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                state_ = kExpectBody;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                            <span class="comment">//如果不用解析请求体，则直接结束</span></span><br><span class="line">                                state_ = kGotAll;</span><br><span class="line">                                hasMore = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// POST/PUT 请求没有 Content-Length，是HTTP语法错误</span></span><br><span class="line">                            ok = <span class="literal">false</span>;</span><br><span class="line">                            hasMore = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// GET/HEAD/DELETE 等方法直接完成（没有请求体）</span></span><br><span class="line">                        state_ = kGotAll; </span><br><span class="line">                        hasMore = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ok = <span class="literal">false</span>; <span class="comment">// Header行格式错误</span></span><br><span class="line">                    hasMore = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//跳过\r\n</span></span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>); <span class="comment">// 开始读指针指向下一行数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hasMore = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HttpRequest::addHeader(<span class="keyword">const</span> <span class="built_in">char</span> *start, <span class="keyword">const</span> <span class="built_in">char</span> *colon, <span class="keyword">const</span> <span class="built_in">char</span> *end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//&#x27;:&#x27;前的值作为key</span></span><br><span class="line">    std::<span class="function"><span class="built_in">string</span> <span class="title">key</span>(<span class="params">start, colon</span>)</span>;</span><br><span class="line">    ++colon;</span><br><span class="line">    <span class="keyword">while</span> (colon &lt; end &amp;&amp; isspace(*colon))</span><br><span class="line">    &#123;</span><br><span class="line">        ++colon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#x27;:&#x27;后的值作为value</span></span><br><span class="line">    std::<span class="function"><span class="built_in">string</span> <span class="title">value</span>(<span class="params">colon, end</span>)</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">value</span>.empty() &amp;&amp; isspace(<span class="keyword">value</span>[<span class="keyword">value</span>.size() - <span class="number">1</span>])) <span class="comment">// 消除尾部空格</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">value</span>.resize(<span class="keyword">value</span>.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储key-valua键值对</span></span><br><span class="line">    headers_[key] = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在找到空行后，需要根据请求方法(判断是否是POST或者PUT方法)和Content-Length判断是否需要继续读取body；如果不需要，则直接退出解析；如果请求体有数据，开始解析请求体。</p><h3 id="3-请求体的解析"><a href="#3-请求体的解析" class="headerlink" title="3.请求体的解析"></a>3.请求体的解析</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state_ == kExpectBody)</span><br><span class="line">        &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 检查缓冲区中是否有足够的数据</span></span><br><span class="line">            <span class="keyword">if</span> (buf-&gt;readableBytes() &lt; request_.contentLength())</span><br><span class="line">            &#123;</span><br><span class="line">                hasMore = <span class="literal">false</span>; <span class="comment">// 数据不完整，等待更多数据</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> std::<span class="built_in">string</span> &amp;contentType = request_.getHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (contentType.find(<span class="string">&quot;multipart/form-data&quot;</span>) != std::<span class="built_in">string</span>::npos) <span class="comment">//multipart/form-data表示支持多种复制格式的数据上传，如txt文件，mp4,rar等；这也是实现各种数据格式上传文件的解析</span></span><br><span class="line">            &#123;</span><br><span class="line">               </span><br><span class="line">                ok=parseMultipartData(buf);</span><br><span class="line">                request_.set_parseMultipartData_state(ok);</span><br><span class="line">                LOG_INFO&lt;&lt;<span class="string">&quot;multipart/form-data解析&quot;</span>&lt;&lt;((ok)?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">                state_ = kGotAll;</span><br><span class="line">                hasMore = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//如果只是普通的数据，直接根据contentLength读入到body中即可。</span></span><br><span class="line">                <span class="comment">// 只读取 Content-Length 指定的长度</span></span><br><span class="line">                std::<span class="function"><span class="built_in">string</span> <span class="title">body</span>(<span class="params">buf-&gt;peek(</span>), buf-&gt;<span class="title">peek</span>() + request_.<span class="title">contentLength</span>())</span>;</span><br><span class="line">                request_.setBody(body);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 准确移动读指针</span></span><br><span class="line">                buf-&gt;retrieve(request_.contentLength());</span><br><span class="line"></span><br><span class="line">                state_ = kGotAll;</span><br><span class="line">                hasMore = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> HttpContext::parseMultipartData(Buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 找到并跳过第一个 boundary（如 ------WebKitFormBoundaryxxxx）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>* crlf = buf-&gt;findCRLF();</span><br><span class="line">    <span class="keyword">if</span> (!crlf) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不完整</span></span><br><span class="line">    std::<span class="function"><span class="built_in">string</span> <span class="title">boundary</span>(<span class="params">buf-&gt;peek(</span>),crlf)</span>;</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;boundary:&quot;</span>&lt;&lt;boundary;</span><br><span class="line">    buf-&gt;retrieveUntil(crlf + <span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 2. 解析 Content-Disposition 行</span></span><br><span class="line">    crlf = buf-&gt;findCRLF();</span><br><span class="line">    <span class="keyword">if</span> (!crlf) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不完整</span></span><br><span class="line">    std::<span class="function"><span class="built_in">string</span> <span class="title">dispositionLine</span>(<span class="params">buf-&gt;peek(</span>), crlf)</span>;</span><br><span class="line">    buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">string</span> Content_Disposition;</span><br><span class="line">    std::<span class="built_in">string</span> name;</span><br><span class="line">    std::<span class="built_in">string</span> filename;</span><br><span class="line">     </span><br><span class="line">    size_t Content_Pos = dispositionLine.find(<span class="string">&quot;Content-Disposition:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Content_Pos != std::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        Content_Pos += <span class="number">20</span>;</span><br><span class="line">        size_t ContentEnd = dispositionLine.find(<span class="string">&#x27;&quot;&#x27;</span>, Content_Pos);</span><br><span class="line">        <span class="keyword">if</span> (ContentEnd != std::<span class="built_in">string</span>::npos)</span><br><span class="line">            Content_Disposition.assign(dispositionLine.data() + Content_Pos, ContentEnd - Content_Pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;Content_Disposition:&quot;</span>&lt;&lt;Content_Disposition;</span><br><span class="line">    size_t namePos = dispositionLine.find(<span class="string">&quot;name=\&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namePos != std::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        namePos += <span class="number">6</span>;</span><br><span class="line">        size_t nameEnd = dispositionLine.find(<span class="string">&#x27;&quot;&#x27;</span>, namePos);</span><br><span class="line">        <span class="keyword">if</span> (nameEnd != std::<span class="built_in">string</span>::npos)</span><br><span class="line">            name.assign(dispositionLine.data() + namePos, nameEnd - namePos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;name;</span><br><span class="line">    size_t filePos = dispositionLine.find(<span class="string">&quot;filename=\&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (filePos != std::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        filePos += <span class="number">10</span>;</span><br><span class="line">        size_t fileEnd = dispositionLine.find(<span class="string">&#x27;&quot;&#x27;</span>, filePos);</span><br><span class="line">        <span class="keyword">if</span> (fileEnd != std::<span class="built_in">string</span>::npos)</span><br><span class="line">            filename.assign(dispositionLine.data() + filePos, fileEnd - filePos);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;filename:&quot;</span>&lt;&lt;filename;</span><br><span class="line">     <span class="comment">// 3. 跳过 Content-Type 行</span></span><br><span class="line">    crlf = buf-&gt;findCRLF();</span><br><span class="line">    <span class="keyword">if</span> (!crlf) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 跳过空行（说明下一个就是正文）</span></span><br><span class="line">    crlf = buf-&gt;findCRLF();</span><br><span class="line">    <span class="keyword">if</span> (!crlf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 写入文件，直到遇到下一次 boundary</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>* fileStart = buf-&gt;peek(); <span class="comment">// 文件内容起点</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>* fileEnd = std::search(</span><br><span class="line">        fileStart, buf-&gt;peek()+ buf-&gt;readableBytes(),</span><br><span class="line">        boundary.c_str(), boundary.c_str() + boundary.size()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileEnd == buf-&gt;beginWrite()) &#123;</span><br><span class="line">    <span class="comment">// 未找到结束 boundary，暂时数据不足</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;开始创建文件咯&quot;</span>; </span><br><span class="line">    request_.set_filename(filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filename.find(<span class="string">&quot;.avi&quot;</span>)!= std::<span class="built_in">string</span>::npos ||filename.find(<span class="string">&quot;.mp4&quot;</span>)!= std::<span class="built_in">string</span>::npos||filename.find(<span class="string">&quot;.mkv&quot;</span>)!= std::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">FileUtil <span class="title">writer</span>(<span class="params"><span class="string">&quot;/root/uploads/videos/&quot;</span> + filename</span>)</span>;</span><br><span class="line">        writer.writeBinary(fileStart, fileEnd - fileStart);</span><br><span class="line">        LOG_INFO&lt;&lt;<span class="string">&quot;这是一个视频&quot;</span>&lt;&lt;filename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">FileUtil <span class="title">writer</span>(<span class="params"><span class="string">&quot;/root/uploads/&quot;</span> + filename</span>)</span>;</span><br><span class="line">        writer.writeBinary(fileStart, fileEnd - fileStart);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;创建完成&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 移动 buffer 指针，跳过文件数据和 boundary和\r\n</span></span><br><span class="line">    buf-&gt;retrieveUntil(fileEnd+<span class="number">2</span>); <span class="comment">// 跳过文件数据</span></span><br><span class="line">    <span class="comment">//这里移动了，但是貌似还剩下一点东西，我测试了并没有发现问题，就不管啦！！！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的抓包过程中没有文件上传的解析，这里我上传了一个txt文件，并抓包分析。</p><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/6b502683b4b6436988f5ddc1b2a7af64.png"                        alt="在这里插入图片描述"                 ><br>上图的红框部分就是我此次上传的txt文件的请求体部分的抓包。以下是分析：</p><ol><li>边界值：——WebKitFormBoundaryLkDgzlyaqa0LgduN（细心的同学看到了，在请求体中的最开始部分和结尾部分都是以这个值作为分界线的，而在这直接的就是具体的内容）</li><li>Content-Disposition: form-data; name&#x3D;”file”; filename&#x3D;”test.txt”；form-data表示是一个表单数据；name字段对应表单中的字段名；filename是客户端上传的一个原始文件名。这个字段是用于告知服务器如何处理这部分数据。</li><li>Content-Type: text&#x2F;plain\r\n\r\n。这个是声明这部分数据的媒体类型。（text&#x2F;plain表示内容是无格式的纯文本）<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/a0cc64898b4e4e03bddfd2d99992ea22.png"                        alt="在这里插入图片描述"                 ><br>这部分就是实际的传输内容。<br>传输如视频或者压缩文件为01二进制流。所以对于上传不同媒体数据的思想是，通过Content-Disposition中的filename字段，获取原数据的文件名，保存为相应的文件类型，并将实际的内容放到对应的文件中。</li></ol><p>视频上传的抓包截图：<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/1313fde68bcd4e3a81d1965c957cf539.png"                        alt="在这里插入图片描述"                 ></p><h1 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h1><h2 id="理论部分-1"><a href="#理论部分-1" class="headerlink" title="理论部分"></a>理论部分</h2><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/deb4587859e6471ab9b0383ef7d2d985.png"                        alt="在这里插入图片描述"                 ><br>HTTP响应报文是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关的数据。一个标准的HTTP响应报文通常包含状态行、响应头、空行、响应体。<br>状态行包含HTTP版本、状态码和状态消息。例如：HTTP&#x2F;1.1 200 OK，404表示没有找到，429表示请求连接过多，我的羡慕中使用令牌桶进行限流的时候，如果某一时候请求连接过多，就返回429状态码<br>响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：<br>● Content-Type：指定响应主体的媒体类型。<br>● Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。<br>● Content-Length：指定响应主体的长度（字节数）。<br>● Expires: 响应的过期时间。<br>● ETag: 响应体的实体标签，用于缓存和条件请求。<br>● Last-Modified： 资源最后被修改的日期和时间。<br>● Location：在重定向时指定新的资源位置。<br>● Set-Cookie：在响应中设置Cookie。</p><p>空行（Empty Line）在响应头和响应体之间，表示响应头的结束。而响应体是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可能为空。</p><h2 id="wireshark抓包分析-1"><a href="#wireshark抓包分析-1" class="headerlink" title="wireshark抓包分析"></a>wireshark抓包分析</h2><p><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/3fde8e82358c45669324345c88902475.png"                        alt="在这里插入图片描述"                 ></p><ol><li>状态行返回 HTTP&#x2F;1.1(协议版本)，200（状态码），ok(状态码对于的短语)</li><li>响应头部，也是以键值对形式保存值的。<code>Connection: Keep-Alive</code>（表示这是一个长连接，即可以在这个连接上多次请求与响应）；<code>Access-Control-Allow-Origin: *</code>（支持跨域访问源，这里的‘*’表示所有源都可访问）；<code>Content-Encoding: gzip</code>（表示使用了gzip编码）；Content-Length: 325（这个字段表示响应体的数据大小为325字节）；Content-Type: application&#x2F;json（表示响应体的格式为json）</li><li>响应体可以是多种格式，在这里是json格式，见下图<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/47ddc71bd9864f408025ab5973071fcb.png"                        alt="在这里插入图片描述"                 ><br>这里的一个json文件中有3个值，filename,uploadtime,username；多个json文件构成了一个Array。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>响应字段是由浏览器解析的，这里我们不需要实现解析的部分。响应是由服务器生成并返回的，所以在这里需要实现HTTP响应报文的生成。<br>请看代码：</p><h3 id="1-设置状态行"><a href="#1-设置状态行" class="headerlink" title="1.设置状态行"></a>1.设置状态行</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HttpResponse::setStatusLine(<span class="keyword">const</span> std::<span class="built_in">string</span>&amp; version,</span><br><span class="line">                                 HttpStatusCode statusCode,</span><br><span class="line">                                 <span class="keyword">const</span> std::<span class="built_in">string</span>&amp; statusMessage)</span><br><span class="line">&#123;</span><br><span class="line">    httpVersion_ = version; <span class="comment">//设置HTTP的版本号</span></span><br><span class="line">    statusCode_ = statusCode;<span class="comment">//设置响应状态码</span></span><br><span class="line">    statusMessage_ = statusMessage;<span class="comment">//设置响应消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-生成响应体"><a href="#2-生成响应体" class="headerlink" title="2.生成响应体"></a>2.生成响应体</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HttpResponse::appendToBuffer(muduo::net::Buffer* outputBuf) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// HttpResponse封装的信息格式化输出</span></span><br><span class="line">    <span class="built_in">char</span> buf[<span class="number">32</span>]; </span><br><span class="line">    <span class="comment">// 为什么不把状态信息放入格式化字符串中，因为状态信息有长有短，不方便定义一个固定大小的内存存储</span></span><br><span class="line">    snprintf(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;%s %d &quot;</span>, httpVersion_.c_str(), statusCode_);</span><br><span class="line">    </span><br><span class="line">    outputBuf-&gt;append(buf);</span><br><span class="line">    outputBuf-&gt;append(statusMessage_);</span><br><span class="line">    outputBuf-&gt;append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否设置长连接</span></span><br><span class="line">    <span class="keyword">if</span> (closeConnection_) </span><br><span class="line">    &#123;</span><br><span class="line">        outputBuf-&gt;append(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        outputBuf-&gt;append(<span class="string">&quot;Connection: Keep-Alive\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> auto&amp; header : headers_)</span><br><span class="line">    &#123; <span class="comment">// 为什么这里不用格式化字符串？因为key和value的长度不定</span></span><br><span class="line">        outputBuf-&gt;append(header.first);</span><br><span class="line">        outputBuf-&gt;append(<span class="string">&quot;: &quot;</span>); </span><br><span class="line">        outputBuf-&gt;append(header.second);</span><br><span class="line">        outputBuf-&gt;append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    outputBuf-&gt;append(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">//添加空行</span></span><br><span class="line">    </span><br><span class="line">    outputBuf-&gt;append(body_); <span class="comment">//添加响应体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化响应之后，通过网络发送响应消息，浏览器解析响应并渲染，一次HTTP请求就完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;


&lt;p&gt;这一篇文章是基于项目LITEHUB分析的关于HTTP的请求和响应篇章，后续将仔细分析这个项目所涉及到的知识点。&lt;br&gt;&lt;img  
                       </summary>
      
    
    
    
    <category term="Http后端服务器" scheme="https://localhost/categories/Http%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="后端" scheme="https://localhost/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>C++指针的深入解析</title>
    <link href="https://localhost/undefined/cpp_pointer/"/>
    <id>https://localhost/undefined/cpp_pointer/</id>
    <published>2025-06-08T09:05:19.000Z</published>
    <updated>2025-07-12T05:51:31.280Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>指针的概念</p><p>指针是一种特殊的数据类型，用于存储变量的内存地址而非直接存储值。通过指针可以间接访问或操作内存中的数据，常用于动态内存分配、数组操作和函数参数传递等场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;     <span class="comment">// 定义整型变量</span></span><br><span class="line"><span class="type">int</span> *ptr = &amp;var;  <span class="comment">// 指针ptr存储var的地址</span></span><br></pre></td></tr></table></figure><p>动态内存管理：通过指针可以在程序运行时动态分配或释放内存（如<code>malloc</code>和<code>free</code>）。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配数组</span></span><br><span class="line"><span class="built_in">free</span>(arr);                                <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure><p>高效数据传递：函数参数传递指针可避免数据复制，提升性能。如下面代码所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> *x)</span> </span>&#123; *x = <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modify</span>(&amp;a); <span class="comment">// a的值被改为20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Tips:</code>未初始化的指针可能指向非法内存，导致崩溃。指针的字节固定为4字节或者8字节（根据操作系统确定）。如int是4字节，char 是1字节，double是8字节；但是对于指针来说char *，和int *，double *都是4字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ma_;</span><br><span class="line"><span class="type">int</span> mb_;</span><br><span class="line"><span class="type">int</span> mc_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(char)   :&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(int)    :&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(double) :&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(class A):&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(char *) :&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(int *)  :&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(double*):&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>*) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(class A *) :&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A *) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果为：<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/56de266682c74db4820f6e689ec1ac4d.png"                        alt="在这里插入图片描述"                 ><br>其实也很好理解，指针本质是内存的地址，对于32位系统来说，指针的长度为4字节；对于64位系统来说，指针的长度为8字节。</p><h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><p><code>const</code>是C&#x2F;C++语言中的一个重要关键字，用于定义常量，表示该变量的值在程序运行期间不能被修改。<code>const</code>关键字可以应用于变量、函数参数、函数返回值以及成员函数。</p><p>const特点：</p><ul><li><strong>不可变性</strong>：<code>const</code>变量的值一旦初始化后就不能再被修改(定义时初始化)</li><li><strong>编译期检查</strong>：编译器会在编译时检查对<code>const</code>变量的修改操作，并报错</li><li><strong>类型安全</strong>：<code>const</code>提供了额外的类型安全保证</li></ul><p>以下是const使用过程中可能出现的错误：<br>1.const常量不能再作为左值,（不然会直接修改常量的值）,如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">a=<span class="number">20</span>;<span class="comment">//尝试直接修改常量，错误</span></span><br></pre></td></tr></table></figure><p>2.不能把常量的地址泄露给一个普通的指针或者引用变量（不然会间接的修改常量的值）,只能传给const类型的指针或变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="comment">//这样可以间接通过指针解引用方法修改内存a的值。</span></span><br><span class="line">*p=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的定义方式为</span></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> *p=&amp;a;</span><br></pre></td></tr></table></figure><h2 id="判断const修改的类型"><a href="#判断const修改的类型" class="headerlink" title="判断const修改的类型"></a>判断const修改的类型</h2><p><code>C++中const修饰符的规则如下</code>：const修饰的是与其最近的表达式（需先去除类型说明符如int、int*）并且遵循最少原则：在int*和int之间优先选择int。去除类型说明符后的表达式即表示该部分不可修改。</p><h2 id="const和一级指针"><a href="#const和一级指针" class="headerlink" title="const和一级指针"></a>const和一级指针</h2><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p=&amp;a; <span class="comment">//与上一行等效，const与int的位置互换不影响含义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里去掉最近的类型，即 int ,const修饰的是*p，表示*p不能被修改。</span></span><br><span class="line">*p=<span class="number">20</span>; <span class="comment">//错误：试图修改常量指针指向的内容</span></span><br><span class="line">p=&amp;b; <span class="comment">//正确：可以改变指针的指向</span></span><br></pre></td></tr></table></figure><p>该指针可以指向不同的int类型的内存地址，但不能通过指针间接修改所指向内存的值。</p><h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p=&amp;a; <span class="comment">//const最近且满足最少原则的类型应该是int *,则其修饰的表达是为 p,表示p不能被修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针p是常量，不能再指向其他内存，但是可以通过指针解引用修改指向内存的值</span></span><br><span class="line">p=&amp;b； <span class="comment">//错误</span></span><br><span class="line">*p=<span class="number">20</span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h3 id="const修饰失效"><a href="#const修饰失效" class="headerlink" title="const修饰失效"></a>const修饰失效</h3><p><strong><code>注意</code></strong>：当const 右边没有指针符号*时，const不参与类型定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * q1=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> q2=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *q3=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//这里q1和q2的类型都是 int *; q3的类型是int const *;</span></span><br></pre></td></tr></table></figure><h2 id="const和二级指针的组合"><a href="#const和二级指针的组合" class="headerlink" title="const和二级指针的组合"></a>const和二级指针的组合</h2><h3 id="指向常量的二级指针"><a href="#指向常量的二级指针" class="headerlink" title="指向常量的二级指针"></a>指向常量的二级指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>** pp = &amp;p;</span><br><span class="line"><span class="comment">// *pp = &amp;y; // 合法</span></span><br><span class="line"><span class="comment">// **pp = 20; // 非法，x是常量</span></span><br></pre></td></tr></table></figure><ul><li>表示指向一个指向常量的指针的指针</li><li>可以通过二级指针修改一级指针的指向,可以修改二级指针</li><li>但不能修改最终指向的值<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/46480c70092c42b09b2246692b7054af.png"                        alt="在这里插入图片描述"                 ></li></ul><h3 id="指向指针常量的二级指针"><a href="#指向指针常量的二级指针" class="headerlink" title="指向指针常量的二级指针"></a>指向指针常量的二级指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;x;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span>* pp = &amp;p;</span><br><span class="line"><span class="comment">// *pp = &amp;y; // 非法，p是常量指针</span></span><br><span class="line"><span class="comment">// **pp = 20; // 合法，x可以被修改</span></span><br></pre></td></tr></table></figure><ul><li>表示指向一个指针常量的指针</li><li>不能通过二级指针修改一级指针的指向</li><li>但可以修改一级指针指向的值，可以修改二级指针<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/645e18417565443bb99ad9b10b3a6961.png"                        alt="在这里插入图片描述"                 ></li></ul><h3 id="二级指针常量"><a href="#二级指针常量" class="headerlink" title="二级指针常量"></a>二级指针常量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;x;</span><br><span class="line"><span class="type">int</span>** <span class="type">const</span> pp = &amp;p;</span><br><span class="line"><span class="comment">// pp = &amp;q; // 非法，pp是常量</span></span><br><span class="line"><span class="comment">// *pp = &amp;y; // 合法，修改p的指向</span></span><br><span class="line"><span class="comment">// **pp = 20; // 合法，修改x的值</span></span><br></pre></td></tr></table></figure><ul><li>表示二级指针本身是常量</li><li>不能修改二级指针的指向</li><li>但可以修改一级指针的指向及其指向的值<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/0ccf72a34ac14e63a3386e7ebb6b81ad.png"                        alt="在这里插入图片描述"                 ></li></ul><h3 id="完全常量二级指针"><a href="#完全常量二级指针" class="headerlink" title="完全常量二级指针"></a>完全常量二级指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span>* pp;</span><br></pre></td></tr></table></figure><ul><li>表示指向一个指向常量的指针常量的指针</li><li>既不能修改一级指针的指向，也不能修改最终指向的值<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/d05fc92aaadb46bdb361b2d8efb9d59b.png"                        alt="在这里插入图片描述"                 ></li></ul><h2 id="总结-const-和-指针的类型转换公式"><a href="#总结-const-和-指针的类型转换公式" class="headerlink" title="总结 const 和 指针的类型转换公式"></a>总结 const 和 指针的类型转换公式</h2><p>在C++中，指针和const的组合使用需要注意类型转换的规则。以下是总结的一些转换方式：</p><h3 id="一级指针转换"><a href="#一级指针转换" class="headerlink" title="一级指针转换"></a>一级指针转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * &lt;&lt;&lt;=== <span class="type">const</span> <span class="type">int</span> *  ;<span class="comment">//是错误的!!!</span></span><br><span class="line"><span class="comment">// 不能将const指针赋值给非const指针，这会导致const保护失效</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * &lt;&lt;&lt;=== <span class="type">int</span> *;  <span class="comment">//是正确的!!!</span></span><br><span class="line"><span class="comment">// 可以将非const指针赋值给const指针，这是安全的类型降级</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *pa = &amp;a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cpa = pa; <span class="comment">// 合法转换</span></span><br></pre></td></tr></table></figure><h3 id="二级指针转换"><a href="#二级指针转换" class="headerlink" title="二级指针转换"></a>二级指针转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ** &lt;&lt;&lt;=== <span class="type">const</span> <span class="type">int</span> **; <span class="comment">//是错误的!!!</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> **&lt;&lt;&lt;=== <span class="type">int</span> **; <span class="comment">//是错误的!!!</span></span><br><span class="line"><span class="comment">//在二级指针甚至多级指针中，两边都要有const 才算正确；</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ** &lt;&lt;&lt;===<span class="type">int</span> * <span class="type">const</span> *;<span class="comment">//是错误的!!!</span></span><br><span class="line"><span class="comment">//前面说到，const只负责其右边的类型构造，上面可以简化为</span></span><br><span class="line"><span class="type">int</span> * &lt;&lt;&lt;===<span class="type">int</span>  <span class="type">const</span> *; <span class="comment">//判断为错误</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> *&lt;&lt;&lt;=== <span class="type">int</span> **;  <span class="comment">//是正确的!!!</span></span><br><span class="line"><span class="comment">//简化为 </span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *&lt;&lt;&lt;=== <span class="type">int</span> *; </span><br></pre></td></tr></table></figure><p>以下是一些转换的错误样例</p><h3 id="错误样例"><a href="#错误样例" class="headerlink" title="错误样例"></a>错误样例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="type">int</span> *q=p;<span class="comment">//这里 int *&lt;&lt;&lt;===const int *,不匹配</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> **q=&amp;p; <span class="comment">//const int ** &lt;&lt;&lt;=== int  **,不匹配，&amp;p取地址加一个*</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p=&amp;a;  <span class="comment">//p为int *,const 只在其右边有指针时起作用；</span></span><br><span class="line"><span class="type">int</span> **q=&amp;p;<span class="comment">//因为这有一个取地址操作，则 int ** &lt;&lt;&lt;===int *const *,不匹配</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span>*q =&amp;p; <span class="comment">//int *const *&lt;&lt;&lt;===const int **,左边是const 与一级指针结合，右边是const 与二级指针结合，不匹配（我是这么理解的，不知道有没有更好的解释）</span></span><br></pre></td></tr></table></figure><h2 id="指针与数组结合"><a href="#指针与数组结合" class="headerlink" title="指针与数组结合"></a>指针与数组结合</h2><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针有各种类型 ，int *,float *</span></span><br><span class="line"><span class="comment">//将数组当作一种数据类型，定义一个指向数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *pa=&amp;pa;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*pa) []=&amp;arr;</span><br><span class="line"><span class="comment">//表明这是一个指针，并且指向一个数组，这个数组中的类型是int 类型</span></span><br></pre></td></tr></table></figure><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,c=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> *arr[]=&#123;&amp;a,&amp;b,&amp;c&#125;;</span><br><span class="line"><span class="comment">//arr先与[]结合，表示这是一个数组，并且这个数组的类型是int *</span></span><br></pre></td></tr></table></figure><h2 id="指针与函数结合"><a href="#指针与函数结合" class="headerlink" title="指针与函数结合"></a>指针与函数结合</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是一个指针，指向一个函数，函数返回类型是int 型</span></span><br><span class="line"><span class="built_in">int</span> (*fun) (<span class="type">int</span> x);</span><br></pre></td></tr></table></figure><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">fun</span> <span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//fun先与()结合，表示这是一个函数，返回类型为int *;</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">迭代器的理解</summary>
    
    
    
    <category term="cppr容器" scheme="https://localhost/categories/cppr%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="c++" scheme="https://localhost/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>LiteHub之环境配置</title>
    <link href="https://localhost/undefined/LiteHub_env_conf/"/>
    <id>https://localhost/undefined/LiteHub_env_conf/</id>
    <published>2025-05-28T06:13:21.000Z</published>
    <updated>2025-07-12T05:50:09.528Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a class="link"   href="https://github.com/qingyh6/HttpsWebServer.git" >仓库地址<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.bilibili.com/video/BV1WVjozZEpt/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=bf00238027d3802fdec7c73822b31dde" >演示地址<i class="fas fa-external-link-alt"></i></a></p><h2 id="禁用自动更新"><a href="#禁用自动更新" class="headerlink" title="禁用自动更新"></a>禁用自动更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop apt-daily.timer</span><br><span class="line"><span class="built_in">sudo</span> systemctl stop apt-daily-upgrade.timer</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> apt-daily.timer</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> apt-daily-upgrade.timer</span><br></pre></td></tr></table></figure><h2 id="安装boost"><a href="#安装boost" class="headerlink" title="安装boost"></a>安装boost</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libbz2-dev</span><br><span class="line"><span class="built_in">sudo</span> apt-get install libicu-dev</span><br><span class="line">//下载地址</span><br><span class="line">https://sourceforge.net/projects/boost/files/boost/1.69.0/</span><br><span class="line">tar -xvf 压缩包</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./b2</span><br><span class="line"><span class="built_in">sudo</span> ./b2 --prefix=/usr/local/boost install</span><br><span class="line">//添加环境变量</span><br><span class="line">vim /etc/environment</span><br><span class="line"></span><br><span class="line">CPLUS_INCLUDE_PATH=/usr/local/boost/include</span><br><span class="line">LIBRARY_PATH=/usr/local/boost/lib</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://blog.csdn.net/u014389734/article/details/88963578" >Linux：编译安装boost 1.69库<i class="fas fa-external-link-alt"></i></a></p><h2 id="安装muduo库"><a href="#安装muduo库" class="headerlink" title="安装muduo库"></a>安装muduo库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install g++ cmake make libboost-dev</span><br><span class="line">//下载并解压文件</span><br><span class="line">./build.sh</span><br><span class="line">./build.sh install</span><br><span class="line"><span class="built_in">cd</span> ../build/</span><br><span class="line"><span class="built_in">cd</span> release-install-cpp11</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> include/</span><br><span class="line"><span class="built_in">mv</span> muduo/ /usr/include/</span><br><span class="line"><span class="built_in">cd</span> ../lib</span><br><span class="line"><span class="built_in">mv</span> * /usr/local/lib/</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://blog.csdn.net/qq_55882840/article/details/145346115" >muduo网络库下载安装教程<i class="fas fa-external-link-alt"></i></a></p><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wget https://downloads.mysql.com/archives/get/p/23/file/mysql-server_5.7.29-1ubuntu18.04_amd64.deb-bundle.tar</span><br><span class="line"><span class="built_in">sudo</span> tar -xvf mysql-server_5.7.29-1ubuntu18.04_amd64.deb-bundle.tar</span><br><span class="line">//更新依赖源</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line">//安装依赖包</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./libmysql*</span><br><span class="line"><span class="built_in">sudo</span> apt-get install libtinfo5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./mysql-community-client_5.7.29-1ubuntu18.04_amd64.deb</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./mysql-client_5.7.29-1ubuntu18.04_amd64.deb</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./mysql-community-server_5.7.29-1ubuntu18.04_amd64.deb </span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./mysql-server_5.7.29-1ubuntu18.04_amd64.deb</span><br><span class="line"></span><br><span class="line">//连接数据库</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">//开启远程访问</span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> User,Host from user;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;root&#x27;</span> WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf </span><br><span class="line">将Bindaddres 从127.0.0.1 改为0.0.0.0</span><br><span class="line">systemctl restart mysql</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://blog.csdn.net/weixin_44842318/article/details/136200647" >Ubuntu22部署MySQL5.7详细教程<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.jianshu.com/p/93513aa6d71f" >Ubuntu22部署MySQL5.7详细教程<i class="fas fa-external-link-alt"></i></a></p><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//安装nlohmann/json</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br><span class="line"><span class="built_in">sudo</span> apt install nlohmann-json3-dev</span><br><span class="line"></span><br><span class="line">//c++ mysql 库</span><br><span class="line"><span class="built_in">sudo</span> apt install libmysqlcppconn-dev</span><br><span class="line"></span><br><span class="line">//安装openssl开发库</span><br><span class="line"><span class="built_in">sudo</span> apt install libssl-dev</span><br><span class="line"></span><br><span class="line">//安装ffmpeg库</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ffmpeg</span><br><span class="line">ffmpeg -version</span><br><span class="line"></span><br><span class="line">//安装gzip</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gzip</span><br><span class="line">gzip --version</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt install zlib</span><br><span class="line"><span class="built_in">sudo</span> apt install zlib1g-dev</span><br></pre></td></tr></table></figure><h2 id="创建表操作"><a href="#创建表操作" class="headerlink" title="创建表操作"></a>创建表操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建web数据库</span><br><span class="line"><span class="keyword">create</span> database webdb;</span><br><span class="line">use webdb;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建用户表</span><br><span class="line"><span class="keyword">create table</span> users (</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> auto_increment,</span><br><span class="line">username <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not null</span>,</span><br><span class="line">password <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not null</span>,</span><br><span class="line"><span class="keyword">primary key</span>(id));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建文件信息表</span><br><span class="line"><span class="keyword">CREATE TABLE</span> fileinfo (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    filename <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    uploadtime DATETIME <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    duration <span class="type">FLOAT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    isvideo   TINYINT(<span class="number">1</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建评论表</span><br><span class="line"><span class="keyword">CREATE TABLE</span> comments (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  video_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  user_id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  parent_id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  content TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">  created_at DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> video_likes (</span><br><span class="line">    user_id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    video_name <span class="type">VARCHAR</span>(<span class="number">255</span>)  <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (user_id, video_name)</span><br><span class="line">)<span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> video_stats (</span><br><span class="line">    video_name <span class="type">VARCHAR</span>(<span class="number">255</span>)  <span class="keyword">NOT NULL</span>,</span><br><span class="line">    view_count <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    like_count <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (video_name)</span><br><span class="line">) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>或者直接设置整个数据库使用这个字符集</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE mydatabase <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>共创建如下几个表<br><img                         lazyload                       alt="image"                       data-src="https://i-blog.csdnimg.cn/direct/d695fdabfde14d0491be5af325344ea8.png"                        alt="在这里插入图片描述"                 ></p>]]></content>
    
    
    <summary type="html">这是LiteHub的环境配置系列命令。</summary>
    
    
    
    <category term="Http后端服务器" scheme="https://localhost/categories/Http%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="后端" scheme="https://localhost/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
</feed>
