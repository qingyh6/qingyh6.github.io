<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/11/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-07-11T02:08:31.050Z" itemprop="datePublished">2025-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/11/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/11/hello-world/" data-id="cmcy6sjn60000rkvb0hzabf0f" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="litehub/_posts-LiteHub之文件下载与视频播放" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/10/LiteHub%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%B8%8E%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/" class="article-date">
  <time class="dt-published" datetime="2025-07-10T02:25:32.000Z" itemprop="datePublished">2025-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/10/LiteHub%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%B8%8E%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/">LiteHub之文件下载与视频播放.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><h2 id="前端请求"><a href="#前端请求" class="headerlink" title="前端请求"></a>前端请求</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个箭头函数可以形象理解为，x流入（=&gt;）x*x,</span></span><br><span class="line"><span class="comment">//自然而然=&gt;前面的就是传入参数,=&gt;表示函数体</span></span><br><span class="line">x =&gt; x * x</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果参数不是一个，就需要用括号()括起来：</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br></pre></td></tr></table></figure>

<p>本项目的请求下载前端代码为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">downloadFile</span>(<span class="params">resourceId, filename, progressBar, statusText</span>) &#123;</span><br><span class="line">        <span class="title function_">fetch</span>(<span class="string">&#x27;/resource/download&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;,</span><br><span class="line">            <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; resourceId &#125;) <span class="comment">//通过post方式将要下载的文件路径发送给后端</span></span><br><span class="line">        &#125;)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;下载失败&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> contentLength = response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;Content-Length&#x27;</span>);</span><br><span class="line">            <span class="keyword">const</span> total = contentLength ? <span class="built_in">parseInt</span>(contentLength, <span class="number">10</span>) : <span class="number">0</span>;<span class="comment">//返回内容长度</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>(); <span class="comment">//这个可以逐块提供body</span></span><br><span class="line">            <span class="keyword">const</span> chunks = [];</span><br><span class="line">            <span class="keyword">let</span> received = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">pump</span> = (<span class="params"></span>) =&gt; reader.<span class="title function_">read</span>()</span><br><span class="line">              .<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; done, value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;<span class="comment">//如果读取完成，整个文件已下载</span></span><br><span class="line">                <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>(chunks);<span class="comment">//将所有小段chunks转换成一个完成的blob(binary large object)</span></span><br><span class="line">                <span class="keyword">const</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(blob);<span class="comment">//浏览器创建一个临时的URL地址来获取这个数据</span></span><br><span class="line">                <span class="comment">//如blob:http://localhost/17dfc4b1-df34-4a93-a6a7-6df9f1e85e0c</span></span><br><span class="line">                <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                a.<span class="property">href</span> = url;</span><br><span class="line">                a.<span class="property">download</span> = filename;</span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(a);</span><br><span class="line">                a.<span class="title function_">click</span>();<span class="comment">//模拟点击浏览器的下载行为</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">                <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(url);<span class="comment">//避免内存泄露</span></span><br><span class="line"></span><br><span class="line">                progressBar.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line">                statusText.<span class="property">textContent</span> = <span class="string">&#x27;下载完成&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                chunks.<span class="title function_">push</span>(value);</span><br><span class="line">                received += value.<span class="property">length</span>;</span><br><span class="line">                <span class="comment">//更新下载进度</span></span><br><span class="line">                <span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> percent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((received / total) * <span class="number">100</span>);</span><br><span class="line">                progressBar.<span class="property">style</span>.<span class="property">width</span> = percent + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                progressBar.<span class="property">textContent</span> = percent + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                statusText.<span class="property">textContent</span> = <span class="string">`下载中 <span class="subst">$&#123;percent&#125;</span>%`</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                statusText.<span class="property">textContent</span> = <span class="string">`下载中（未知大小）`</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//递归调用 pump（继续读取下一段）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">pump</span>();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">pump</span>();</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;下载出错：&#x27;</span>, error);</span><br><span class="line">            progressBar.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">            statusText.<span class="property">textContent</span> = <span class="string">&#x27;下载失败&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类比</span></span><br><span class="line"><span class="comment">// 后端：用水龙头一点点把水流出来</span></span><br><span class="line"><span class="comment">// 前端：接水并灌到瓶子里（Blob）</span></span><br><span class="line"><span class="comment">// createObjectURL：给这瓶水贴个标签（blob URL）</span></span><br><span class="line"><span class="comment">// 点击下载：把瓶子交给你下载</span></span><br><span class="line"><span class="comment">// revokeObjectURL：把标签撕掉，清理内存</span></span><br></pre></td></tr></table></figure>
<p>对于<code>pump</code>函数的理解，结合箭头函数和<code>promise</code></p>
<ol>
<li>reader.read()<br>  ○ 返回一个 Promise&lt;{ done: boolean, value: Uint8Array }&gt;。<br>  ○ done: true 表示读取完了；<br>  ○ value 是当前读取的一段数据（Uint8Array 格式）。</li>
<li>箭头函数 () &#x3D;&gt; reader.read().then(…)<br>  ○  这是一个返回 Promise 的函数。<br>  ○ done: true 表示读取完了；<br>  ○ value 是当前读取的一段数据（Uint8Array 格式）。</li>
<li>箭头函数 () &#x3D;&gt; reader.read().then(({ done, value }) &#x3D;&gt; { return dump()}<br> ■ ()&#x3D;&gt;reader.read(),无参数传入，执行reader.read()，返回reader.read()执行的结果{done,value}。<br> ■ .then({ done, value })通过上一步接收这两个数据，然后通过这两个执行相应内容；<br> ■ 如果done为false，表示还没执行完成，chunks.push(value)：把这一段加入缓存  ，更新进度条， 递归调用自身，继续下一段读取  （return pump()）。</li>
</ol>
<h3 id="后端响应"><a href="#后端响应" class="headerlink" title="后端响应"></a>后端响应</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">FileUtil <span class="title">file</span><span class="params">(filePath)</span></span>; </span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">isValid</span>()) <span class="comment">//判断请求的文件是否有效</span></span><br><span class="line">&#123;</span><br><span class="line">    LOG_WARN &lt;&lt; filePath &lt;&lt; <span class="string">&quot;not exist.&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k404NotFound, <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    resp-&gt;<span class="built_in">setContentType</span>(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">    std::string resp_info=<span class="string">&quot;File not found&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">setContentLength</span>(resp_info.<span class="built_in">size</span>());</span><br><span class="line">    resp-&gt;<span class="built_in">setBody</span>(resp_info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置相应头</span></span><br><span class="line">resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k200Ok, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">resp-&gt;<span class="built_in">setCloseConnection</span>(<span class="literal">false</span>);</span><br><span class="line">resp-&gt;<span class="built_in">setContentType</span>(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::string filename = std::filesystem::<span class="built_in">path</span>(filePath).<span class="built_in">filename</span>().<span class="built_in">string</span>();</span><br><span class="line">LOG_INFO&lt;&lt;<span class="string">&quot;filename:&quot;</span>&lt;&lt;filename;</span><br><span class="line">resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + filename + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//设置响应格式为文件类型，并添加文件的路径</span></span><br><span class="line">resp-&gt;<span class="built_in">setContentLength</span>(file.<span class="built_in">size</span>());</span><br><span class="line">resp-&gt;<span class="built_in">setisFileResponse</span>(filePath);</span><br></pre></td></tr></table></figure>
<h3 id="设计亮点"><a href="#设计亮点" class="headerlink" title="设计亮点"></a>设计亮点</h3><p>在<code>HttpResponse.h</code>头文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFileResponse</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> isFileResponse_;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getFilePath</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> filePath_;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setisFileResponse</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         isFileResponse_ = <span class="literal">true</span>;</span><br><span class="line">         filePath_ = path;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span>                               isFileResponse_; <span class="comment">//判断是否是文件，如果是，采用流式发送</span></span><br><span class="line">std::string                        filePath_;</span><br></pre></td></tr></table></figure>
<p>在httpserver的请求函数中判断，如果是文件类型，就调用tcpconnection先将响应头发送出去，然后将消息体分小块发送，这里设置的是8kb；如果不是文件类型，直接将整个响应发送出去<br>在<code>HttpServer::onRequest</code>函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给response设置一个成员，判断是否请求的是文件，如果是文件设置为true，并且存在文件位置在这里send出去。</span></span><br><span class="line"><span class="keyword">if</span> (!response.<span class="built_in">isFileResponse</span>())</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//不是文件类型</span></span><br><span class="line">    muduo::net::Buffer buf;</span><br><span class="line">    response.<span class="built_in">appendToBuffer</span>(&amp;buf);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(&amp;buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 1. 构造响应头</span></span><br><span class="line">    muduo::net::Buffer headerBuf;</span><br><span class="line">    response.<span class="built_in">appendToBuffer</span>(&amp;headerBuf);  <span class="comment">// 只添加状态行和头部，不包含 body</span></span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(&amp;headerBuf);  <span class="comment">// 先发 header</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 发送文件内容（分块）</span></span><br><span class="line">    <span class="type">const</span> std::string filePath = response.<span class="built_in">getFilePath</span>();</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filePath, std::ios::binary)</span></span>;<span class="comment">// 以二进制模式打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> bufferSize = <span class="number">8192</span>; 			<span class="comment">// 8KB 缓冲区</span></span><br><span class="line">        <span class="type">char</span> buffer[bufferSize];                  <span class="comment">// 栈上分配缓冲区</span></span><br><span class="line">        <span class="keyword">while</span> (file) &#123;                            <span class="comment">// 循环直到文件读取结束或出错</span></span><br><span class="line">            file.<span class="built_in">read</span>(buffer, bufferSize);        <span class="comment">// 读取最多 bufferSize 字节到 buffer</span></span><br><span class="line">            std::streamsize bytesRead = file.<span class="built_in">gcount</span>(); <span class="comment">// 实际读取的字节数</span></span><br><span class="line">            <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                conn-&gt;<span class="built_in">send</span>(muduo::<span class="built_in">StringPiece</span>(buffer, bytesRead));<span class="comment">// 发送数据块</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件打不开，补偿错误提示</span></span><br><span class="line">        muduo::net::Buffer errBuf;</span><br><span class="line">        errBuf.<span class="built_in">append</span>(<span class="string">&quot;HTTP/1.1 500 Internal Server Error\r\n\r\nFile open failed&quot;</span>);</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(&amp;errBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以是在httpserver上分块发送数据流，是为了保证代码较好的层次性，httpserver负责管理多个tcp连接，包括发送消息和接收消息等。</p>
<h1 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 从请求中获取 Range 头，例如 &quot;bytes=1000-2000&quot;</span></span><br><span class="line">    std::string rangeHeader = req.<span class="built_in">getHeader</span>(<span class="string">&quot;Range&quot;</span>);</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;Range Header: &quot;</span> &lt;&lt; rangeHeader;</span><br><span class="line">    <span class="comment">// 默认起始字节 start=0，结束字节 end=文件大小-1，表示完整文件</span></span><br><span class="line">    std::streamsize start = <span class="number">0</span>, end = fileSize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标记是否是分块响应</span></span><br><span class="line">    <span class="type">bool</span> isPartial = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!rangeHeader.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果客户端带了 Range，则标记为分块传输</span></span><br><span class="line">        isPartial = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> s = <span class="number">0</span>, e = <span class="number">-1</span>;</span><br><span class="line">         <span class="comment">// 使用 sscanf 解析格式 bytes=&lt;start&gt;-&lt;end&gt;</span></span><br><span class="line">        <span class="comment">// 注意：用户可能只写了起始，没有写结束，所以要判断 sscanf 返回值</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">sscanf</span>(rangeHeader.<span class="built_in">c_str</span>(), <span class="string">&quot;bytes=%ld-%ld&quot;</span>, &amp;s, &amp;e);</span><br><span class="line">        start = s;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || e == <span class="number">-1</span>) &#123;<span class="comment">// 如果只解析到 1 个数，或者结束为 -1，则表示读到文件末尾</span></span><br><span class="line">            end = fileSize - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解析到两个数，且结束不能超过文件大小</span></span><br><span class="line">            end = std::<span class="built_in">min</span>((std::streamsize)e, fileSize - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 合法性检查：start 必须小于等于 end 且小于文件大小</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end || start &gt;= fileSize) &#123;</span><br><span class="line">            <span class="comment">// 如果不合法，返回 416 状态码（Requested Range Not Satisfiable）</span></span><br><span class="line">            resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k416RequestedRangeNotSatisfiable, <span class="string">&quot;Requested Range Not Satisfiable&quot;</span>);</span><br><span class="line">            <span class="type">char</span> rangeValue[<span class="number">64</span>];</span><br><span class="line">            <span class="comment">// Content-Range 必须带 &quot;*/总大小&quot;</span></span><br><span class="line">            <span class="built_in">snprintf</span>(rangeValue, <span class="built_in">sizeof</span>(rangeValue), <span class="string">&quot;bytes */%ld&quot;</span>, fileSize);</span><br><span class="line">            resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Content-Range&quot;</span>, rangeValue);</span><br><span class="line">            resp-&gt;<span class="built_in">setCloseConnection</span>(<span class="literal">true</span>);</span><br><span class="line">            resp-&gt;<span class="built_in">setContentType</span>(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            resp-&gt;<span class="built_in">setBody</span>(<span class="string">&quot;Invalid Range&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算需要读取的 chunkSize</span></span><br><span class="line">    std::streamsize chunkSize = end - start + <span class="number">1</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(chunkSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要分块，最好这里限制一下 chunkSize，防止内存过大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到要读的起始位置</span></span><br><span class="line">    file.<span class="built_in">seekg</span>(start, std::ios::beg);</span><br><span class="line">    <span class="comment">// 从文件读出 chunkSize 大小的数据到 buffer</span></span><br><span class="line">    file.<span class="built_in">read</span>(buffer.<span class="built_in">data</span>(), chunkSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 构造响应 ===</span></span><br><span class="line">    <span class="keyword">if</span> (isPartial) &#123;</span><br><span class="line">        resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k206PartialContent, <span class="string">&quot;Partial Content&quot;</span>);</span><br><span class="line">        <span class="type">char</span> rangeHeaderValue[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(rangeHeaderValue, <span class="built_in">sizeof</span>(rangeHeaderValue),</span><br><span class="line">                <span class="string">&quot;bytes %ld-%ld/%ld&quot;</span>, start, end, fileSize);</span><br><span class="line">        resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Content-Range&quot;</span>, rangeHeaderValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resp-&gt;<span class="built_in">setStatusLine</span>(req.<span class="built_in">getVersion</span>(), http::HttpResponse::k200Ok, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Accept-Ranges&quot;</span>, <span class="string">&quot;bytes&quot;</span>);<span class="comment">// 无论是否分块，都要告知支持分块</span></span><br><span class="line">    resp-&gt;<span class="built_in">setContentType</span>(<span class="string">&quot;video/mp4&quot;</span>);         <span class="comment">// 设置内容类型为 mp4 视频</span></span><br><span class="line">    resp-&gt;<span class="built_in">setContentLength</span>(buffer.<span class="built_in">size</span>());     <span class="comment">// 设置 Content-Length</span></span><br><span class="line">    resp-&gt;<span class="built_in">setBody</span>(std::<span class="built_in">string</span>(buffer.<span class="built_in">begin</span>(), buffer.<span class="built_in">end</span>()));  <span class="comment">// 把读取的文件块设置到响应体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后端涉及对请求体中的range字段进行解析，判断range字段的合法性，随后根据range字段请求内容决定是返回部分内容还是全部内容。<br><strong>请求所有内容：</strong><br><img src="https://i-blog.csdnimg.cn/direct/ee7976fbdf5f41038547b48512e08171.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/7df5f3d2072d4f6aa8130d09a8d2e533.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/83a40f17377044c5a56c3d1d9dbcaaf4.png" alt="在这里插入图片描述"><br>依次拖动播放进度条，range字段发生改变，格式为<start>–<end>字段，这里是请求从某一时刻到视频结束。<br><strong>请求部分内容：</strong><br><img src="https://i-blog.csdnimg.cn/direct/4f0a75336d8b4506af21d2252f8401e1.png" alt="在这里插入图片描述"><br>这里请求的是从字节6000-18000大小的数据，返回的响应为<br><img src="https://i-blog.csdnimg.cn/direct/15b86b0e768f43098a4f93fe16619642.png" alt="在这里插入图片描述"><br>这里的响应头字段为<code>206 partial content</code>,表示响应返回的只是视频的一部分数据。</p>
<hr>
<p><strong>range的合法性校验</strong><br>这里我手动指定range的范围为<code>6000-18000000000000</code>，实际是超出了请求视频的最大范围，看看最后返回的什么。使用curl（这里因为是测试，所以去掉了权限的判定，实际上运行的时候使用curl是不可行的）<br><img src="https://i-blog.csdnimg.cn/direct/57982f440f6c48c88d496051ce9a7004.png" alt="在这里插入图片描述"><br>可以看到这里返回的是文件的最大大小。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/10/LiteHub%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%B8%8E%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/" data-id="cmcy7r5uj0003ysvbaf0zex4e" data-title="LiteHub之文件下载与视频播放.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="litehub/_posts-LiteHub之数据库连接池" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/09/LiteHub%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" class="article-date">
  <time class="dt-published" datetime="2025-07-09T02:27:52.000Z" itemprop="datePublished">2025-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/09/LiteHub%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">LiteHub之数据库连接池</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@<a href="%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8">TOC</a></p>
<h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><h3 id="不使用数据库连接池"><a href="#不使用数据库连接池" class="headerlink" title="不使用数据库连接池"></a>不使用数据库连接池</h3><p>我们先来看看普通的Mysql的连接过程，下图是我抓包分析的在端口3306的数据包：<br><img src="https://i-blog.csdnimg.cn/direct/00ccb843634f426f8d9e626e21862ef5.png" alt="在这里插入图片描述"><br>在执行Mysql命令之前，需要先经过Tcp的三次握手、Mysql的认证服务，TLS加密服务等操作；<br>下图来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/CrankZ/article/details/82874158">数据库连接池学习笔记（一）：原理介绍+常用连接池介绍</a><br><img src="https://i-blog.csdnimg.cn/direct/89e3aedfb8d74ed0a7c3df83cd79c296.png" alt="在这里插入图片描述"><br>经过上述分析，我们知道，如果不使用数据库连接池，执行单条Mysql命令会多了非常多我们不关心的网络交互。<br>如果执行的Mysql查询命令比较多，就会严重影响性能。</p>
<blockquote>
<p>不使用数据库连接池：<br> <strong>优点</strong>： 实现简单<br> <strong>缺点</strong>： 网络IO较多<br> 数据库的负载较高<br> 响应时间较长及QPS较低<br>应用频繁的创建连接和关闭连接，导致临时对象较多<br> 在关闭连接后，会出现大量TIME_WAIT 的TCP状态（在2个MSL之后关闭）</p>
</blockquote>
<h3 id="使用数据库连接池"><a href="#使用数据库连接池" class="headerlink" title="使用数据库连接池"></a>使用数据库连接池</h3><p><img src="https://i-blog.csdnimg.cn/direct/0e89367c1d894d8bb9f18c93dfb68773.png" alt="在这里插入图片描述"></p>
<p><strong>初始连接建立</strong><br>当应用程序第一次访问数据库时，需要完成以下步骤：</p>
<ol>
<li>系统会创建一个新的数据库连接</li>
<li>这个连接需要经过身份验证(用户名&#x2F;密码验证)</li>
<li>建立TCP&#x2F;IP网络连接</li>
<li>初始化会话参数和设置</li>
</ol>
<p><strong>连接复用机制</strong><br>在后续访问中：</p>
<ol>
<li>系统会从连接池中获取先前建立的可用连接</li>
<li>直接使用该连接执行SQL语句(如SELECT, INSERT, UPDATE等)</li>
<li>执行过程中无需重新进行身份验证和连接建立</li>
<li>典型的复用场景包括：<ul>
<li>用户多次查询同一数据表</li>
<li>处理事务中的多个SQL操作</li>
<li>执行批量数据处理任务</li>
</ul>
</li>
</ol>
<p><strong>连接回收过程</strong></p>
<p>每次查询完成后：</p>
<ol>
<li>系统会将连接标记为”空闲”状态</li>
<li>连接会被归还到连接池中</li>
<li>连接保持开启状态，等待下次请求</li>
<li>如果连接空闲时间超过配置的阈值(如30分钟)，可能会被自动关闭</li>
</ol>
<p>这种机制显著提高了性能，减少了频繁创建和销毁连接的开销。</p>
<h3 id="常见的几种资源池"><a href="#常见的几种资源池" class="headerlink" title="常见的几种资源池"></a>常见的几种资源池</h3><p>在实际应用中，由于创建和销毁系统资源（如连接、内存块、线程等）的成本往往远高于使用资源的成本，因此通常会引入资源池的概念来提高系统性能。这种技术通过预先创建并维护一组可重用资源，避免了频繁的资源初始化和销毁操作，从而显著提升系统效率。</p>
<p>常见的资源池包括以下几种类型：</p>
<ol>
<li><p><strong>内存池</strong>：</p>
<ul>
<li>在C++程序开发中，malloc通过brk()系统调用向操作系统申请内存时，会一次性申请较大的内存块（只是通过brk方式申请的内存会维护内存池，小块内存；通过nmap方式申请的大块内存（默认是大于128k）没有内存池，是直接归还给操作系统了）</li>
<li>当使用free释放内存时，这些内存并不会立即归还给操作系统，而是被缓存在malloc维护的内存池中</li>
<li>当下次程序再次申请内存时，malloc会优先从内存池中分配可用内存块</li>
<li>例如：当程序频繁进行小内存块的分配和释放时，内存池可以避免频繁的系统调用，提高内存分配效率</li>
</ul>
</li>
<li><p><strong>线程池</strong>：</p>
<ul>
<li>传统的线程创建和销毁涉及操作系统层面的资源分配和回收，开销较大</li>
<li>线程池通过预先创建一组线程并保持活跃状态，等待任务分配</li>
<li>主要优势包括：<ul>
<li>线程复用：避免频繁创建销毁线程的开销</li>
<li>任务解耦：将任务提交与执行分离，提高系统灵活性</li>
<li>资源管理：可以限制并发线程数量，防止系统过载</li>
</ul>
</li>
<li>应用场景：Web服务器处理请求、批量数据处理等需要高并发的场景</li>
</ul>
</li>
<li><p><strong>数据库连接池</strong>：</p>
<ul>
<li>建立数据库连接涉及网络通信、身份验证等耗时操作</li>
<li>连接池维护一组已建立的数据库连接，应用程序使用时直接从池中获取</li>
<li>使用完毕后连接归还池中而非关闭，供其他请求复用</li>
<li>典型配置参数包括：最小连接数、最大连接数、连接超时时间等</li>
<li>优势：显著降低连接建立开销，提高数据库访问效率</li>
</ul>
</li>
</ol>
<p>这些资源池技术在现代软件系统中被广泛应用，特别是在高并发、高性能要求的场景下，合理配置资源池可以大幅提升系统整体性能。在实际应用中，由于创建和销毁系统资源（如连接、内存块、线程等）的成本往往远高于使用资源的成本，因此通常会引入资源池的概念来提高系统性能。这种技术通过预先创建并维护一组可重用资源，避免了频繁的资源初始化和销毁操作，从而显著提升系统效率。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>本项目数据库连接池实现了三个核心类：</p>
<ul>
<li><code>DbConnection</code>：管理单个数据库连接</li>
<li><code>DbConnectionPool</code>：管理数据库连接池</li>
<li><code>MysqlUtil</code>：提供便捷的数据库操作接口</li>
</ul>
<p>以下就分别来了解一下这几个类的实现。</p>
<h3 id="DbConnection类实现"><a href="#DbConnection类实现" class="headerlink" title="DbConnection类实现"></a>DbConnection类实现</h3><p><strong>成员变量</strong>：</p>
<ul>
<li><code>std::shared_ptr&lt;sql::Connection&gt; conn_</code> 数据库连接</li>
<li><code>std::string    host_</code>   数据库主机地址，如tcp:&#x2F;&#x2F;127.0.0.1:3306</li>
<li><code>std::string    user_</code>    用户名</li>
<li><code>std::string  password_</code>  密码</li>
<li><code>std::string database_</code>  使用数据库</li>
<li><code>std::mutex  mutex_</code>    互斥锁</li>
</ul>
<p><strong>成员方法</strong>：</p>
<ul>
<li><code>DbConnection()</code>构造函数, 创建并初始化数据库连接，设置连接属性（这里是设置的单语句执行，防止SQL的注入）</li>
<li><code>~DbConnection()</code>析构函数，自动清理连接资源，调用cleanup()函数</li>
<li><code>ping()</code>函数，使用简单的<code>SELECT 1</code>语句检测与数据库的通信是否正常</li>
<li><code>isValid()</code>函数，与ping函数类似，区别在于不在意查询结果，遇到异常返回false</li>
<li><code>reconnect()</code> 函数，尝试重新建立数据库连接</li>
<li><code>cleanup()</code>函数，清理连接状态，需要确保所有事务以及完成，并且消费完所有查询结果</li>
<li><code>bindParams()</code>,绑定参数</li>
<li><code>executeQuery()</code>函数，执行sql语句的查询，并返回查询结果</li>
<li><code>executeUpdate()</code>函数，执行sql语句的更新操作</li>
</ul>
<p>在上述函数中比较重要的就是<code>executeQuery()</code>和<code>executeUpdate()</code>函数，以下是其代码定义与注释</p>
<p><strong>executeQuery()函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="comment">//可变参数模板，接受任意数量、任意类型的参数</span></span><br><span class="line"><span class="function">sql::ResultSet* <span class="title">executeQuery</span><span class="params">(<span class="type">const</span> std::string&amp; sql, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;  <span class="comment">// 确保线程安全</span></span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接创建新的预处理语句，不使用缓存</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;sql::PreparedStatement&gt; <span class="title">stmt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            conn_-&gt;prepareStatement(sql)</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="built_in">bindParams</span>(stmt.<span class="built_in">get</span>(), <span class="number">1</span>, std::forward&lt;Args&gt;(args)...); <span class="comment">// 绑定参数,std::forward 确保完美转发</span></span><br><span class="line">        <span class="keyword">return</span> stmt-&gt;<span class="built_in">executeQuery</span>(); <span class="comment">//执行后返回 sql::ResultSet*</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> sql::SQLException&amp; e) </span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;Query failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;, SQL: &quot;</span> &lt;&lt; sql;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DbException</span>(e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是执行Sql查询的操作，在上层，通过代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string sql = <span class="string">&quot;SELECT id FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line">sql::ResultSet* res = mysqlUtil_.<span class="built_in">executeQuery</span>(sql, username, password);</span><br></pre></td></tr></table></figure>
<p>传入了sql语句：”SELECT id FROM users WHERE username &#x3D; ? AND password &#x3D; ?”<br>以及两个参数：username&#x3D;”<code>user1</code>“和password&#x3D;”<code>123456</code>“；<br>通过参数绑定后，完整的sql语句就是<br>“SELECT id FROM users WHERE username &#x3D; user1 AND password &#x3D;123456”<br>随后执行Mysql的语句查询，返回查询到的结果。</p>
<p><strong>executeUpdate函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="type">const</span> std::string&amp; sql, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 直接创建新的预处理语句，不使用缓存</span></span><br><span class="line">            <span class="function">std::unique_ptr&lt;sql::PreparedStatement&gt; <span class="title">stmt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                conn_-&gt;prepareStatement(sql)</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>;</span><br><span class="line">            <span class="built_in">bindParams</span>(stmt.<span class="built_in">get</span>(), <span class="number">1</span>, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            <span class="keyword">return</span> stmt-&gt;<span class="built_in">executeUpdate</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> sql::SQLException&amp; e) </span><br><span class="line">        &#123;</span><br><span class="line">            LOG_ERROR &lt;&lt; <span class="string">&quot;Update failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;, SQL: &quot;</span> &lt;&lt; sql;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">DbException</span>(e.<span class="built_in">what</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>示例语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::string sql = <span class="string">&quot;INSERT INTO video_stats (video_name, view_count, like_count) VALUES (?, 0, 0) ON DUPLICATE KEY UPDATE video_name=video_name&quot;</span>;</span><br><span class="line"><span class="type">int</span> affected = mysqlUtil_.<span class="built_in">executeUpdate</span>(sql, video_name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>SQL注入的理解</strong>：<br>当用户登录网站时，通常会输入用户名和密码。<br>以下是一段正常的 SQL 查询代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = <span class="string">&#x27;user1&#x27;</span> AND password = <span class="string">&#x27;password1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果攻击者输入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名： admin<span class="string">&#x27; --</span></span><br><span class="line"><span class="string">密码： anything</span></span><br></pre></td></tr></table></figure>

<p>SQL查询变成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = <span class="string">&#x27;admin&#x27;</span> --<span class="string">&#x27; AND password = &#x27;</span>anything<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>
<p>其中 – 是 SQL 的注释符号，忽略了密码条件，直接绕过了身份验证。<br>更多可以参考<br><a target="_blank" rel="noopener" href="https://www.runoob.com/sql/sql-injection.html">SQL 注入</a></p>
<h3 id="DbConnectionPool类实现"><a href="#DbConnectionPool类实现" class="headerlink" title="DbConnectionPool类实现"></a>DbConnectionPool类实现</h3><p>成员变量：</p>
<ul>
<li><code>std::string     host_</code>; 连接数据库的主机名</li>
<li><code>std::string     user_;</code> 用户名</li>
<li><code>std::string     password_;</code> 密码</li>
<li><code>std::string    database_;</code> 指定使用的数据库</li>
<li><code>std::queue&lt;std::shared_ptr&lt;DbConnection&gt;&gt; connections_;</code> 数据库连接池</li>
<li><code>std::mutex    mutex_;</code> 互斥锁</li>
<li><code>std::condition_variable   cv_;</code> 条件变量</li>
<li><code>bool       initialized_ = false;</code>   初始化标识,确保仅初始化一次</li>
<li><code>std::thread    checkThread_;</code> &#x2F;&#x2F; 添加检查线程，检测数据库连接池的连接健康状况</li>
</ul>
<p>成员方法：<br>使用单例模式，</p>
<ul>
<li><code>init()</code>函数，初始化线程池，创建 poolSize 个 DbConnection 对象，放入队列</li>
<li><code>DbConnectionPool()</code>构造函数，创建并分离后台线程，定期检查连接可用性</li>
<li><code>~DbConnectionPool()</code>析构函数，清空连接队列，释放所有连接资源</li>
<li><code>getConnection()</code> 函数，从连接池获取一个可用连接</li>
<li><code>createConnection()</code> 函数，创建一个新的数据库连接</li>
<li><code>checkConnections()</code> ，后台线程，定期检查所有连接是否可用。</li>
</ul>
<p>这里比较重要的就是<code>getConnection()</code> 函数，我贴出来代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;DbConnection&gt; <span class="title">DbConnectionPool::getConnection</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;DbConnection&gt; conn;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="comment">// 如果连接池为空，则阻塞等待其他线程释放连接</span></span><br><span class="line">        <span class="keyword">while</span> (connections_.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initialized_) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">DbException</span>(<span class="string">&quot;Connection pool not initialized&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            LOG_INFO &lt;&lt; <span class="string">&quot;Waiting for available connection...&quot;</span>;</span><br><span class="line">            cv_.<span class="built_in">wait</span>(lock);  <span class="comment">// 等待条件变量通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从队列中取一个连接</span></span><br><span class="line">        conn = connections_.<span class="built_in">front</span>();</span><br><span class="line">        connections_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; <span class="comment">// 释放锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在锁外检查连接</span></span><br><span class="line">        <span class="keyword">if</span> (!conn-&gt;<span class="built_in">ping</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">&quot;Connection lost, attempting to reconnect...&quot;</span>;</span><br><span class="line">            conn-&gt;<span class="built_in">reconnect</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用自定义 deleter：</span></span><br><span class="line">        <span class="comment">// 当外部 shared_ptr 被释放时，把连接放回连接池并通知等待线程</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;DbConnection&gt;(conn.<span class="built_in">get</span>(), </span><br><span class="line">            [<span class="keyword">this</span>, conn](DbConnection*) &#123;</span><br><span class="line">                std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex_);</span><br><span class="line">                connections_.<span class="built_in">push</span>(conn);</span><br><span class="line">                cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 如果重连失败，则把连接放回队列并通知等待线程</span></span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;Failed to get connection: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            connections_.<span class="built_in">push</span>(conn);</span><br><span class="line">            cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数的核心逻辑为：</p>
<ul>
<li>如果连接池为空，则阻塞等待（使用条件变量）</li>
<li>连接池始终返回 <code>std::shared_ptr&lt;DbConnection&gt;</code></li>
<li>通过自定义的deleter在用户使用完数据库某条连接后自动归还给池<br>使用lambda表达式，当conn使用完成后，将其归还到connections_池中去。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义 deleter：</span></span><br><span class="line"> <span class="comment">// 当外部 shared_ptr 被释放时，把连接放回连接池并通知等待线程</span></span><br><span class="line"> <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;DbConnection&gt;(conn.<span class="built_in">get</span>(), </span><br><span class="line">     [<span class="keyword">this</span>, conn](DbConnection*) &#123;</span><br><span class="line">         std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex_);</span><br><span class="line">         connections_.<span class="built_in">push</span>(conn);</span><br><span class="line">         cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="MysqlUtil类实现"><a href="#MysqlUtil类实现" class="headerlink" title="MysqlUtil类实现"></a>MysqlUtil类实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> std::string&amp; host, <span class="type">const</span> std::string&amp; user,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> std::string&amp; password, <span class="type">const</span> std::string&amp; database,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> poolSize = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//调用了 DbConnectionPool 的单例模式，保证全局唯一</span></span><br><span class="line">    http::db::DbConnectionPool::<span class="built_in">getInstance</span>().<span class="built_in">init</span>(</span><br><span class="line">        host, user, password, database, poolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">sql::ResultSet* <span class="title">executeQuery</span><span class="params">(<span class="type">const</span> std::string&amp; sql, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//对外提供 执行查询（SELECT） 的接口</span></span><br><span class="line">    <span class="comment">//使用者不需要显式创建 DbConnection，也不用关心 getConnection 和归还连接的逻辑</span></span><br><span class="line">    <span class="keyword">auto</span> conn = http::db::DbConnectionPool::<span class="built_in">getInstance</span>().<span class="built_in">getConnection</span>();</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;<span class="built_in">executeQuery</span>(sql, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="type">const</span> std::string&amp; sql, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//对外提供 执行更新（INSERT / UPDATE / DELETE） 的接口</span></span><br><span class="line">    <span class="keyword">auto</span> conn = http::db::DbConnectionPool::<span class="built_in">getInstance</span>().<span class="built_in">getConnection</span>();</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;<span class="built_in">executeUpdate</span>(sql, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MysqlUtil类的实现比较简单，提供了对数据库的简单接口，隐藏了底层连接池的复杂性。主要是提供了三个方法，分别是数据库连接池的初始化、从连接池中获取连接以执行查询操作和更新（增删改）操作。MysqlUtil作为一个便捷的工具类，简化了调用接口，让业务层可以更轻松的使用连接池进行增删改查的工作。</p>
<p>以上就是我对数据库连接池的一些理解，如有不当之处，敬请指出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/09/LiteHub%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" data-id="cmcy7r5uk0005ysvb117ffvk8" data-title="LiteHub之数据库连接池" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="litehub/_posts-LiteHub之gzip压缩算法" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/05/LiteHub%E4%B9%8Bgzip%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-07-05T02:28:46.000Z" itemprop="datePublished">2025-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/05/LiteHub%E4%B9%8Bgzip%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/">LiteHub之gzip压缩算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@<a href="gzip%E7%AE%97%E6%B3%95">TOC</a></p>
<h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><blockquote>
<p>gzip是一种无损压缩算法，其基础为Deflate，Deflate是LZ77与哈弗曼编码的一个组合体。它的基本原理是：对于要压缩的文件，首先使用LZ77算法的一个变种进行压缩，对得到的结果再使用哈夫曼编码（根据情况，使用静态哈弗曼编码或动态哈夫曼编码）的方法进行压缩。</p>
</blockquote>
<h3 id="LZ777算法"><a href="#LZ777算法" class="headerlink" title="LZ777算法"></a>LZ777算法</h3><p>几个术语</p>
<ul>
<li>等待编码区</li>
<li>搜索缓冲区（已经编码的区域）</li>
<li>滑动窗口（指定大小，包括“搜索缓冲区”和“待编码区”）</li>
</ul>
<p>具体的编码过程：<br>接下来，介绍具体的编码过程：<br>　　为了编码待编码区， 编码器在滑动窗口的搜索缓冲区查找直到找到匹配的字符串。匹配字符串的开始字符串与待编码缓冲区的距离称为“偏移值”，匹配字符串的长度称为“匹配长度”。<br>　　编码器在编码时，会一直在搜索区中搜索，直到找到最大匹配字符串，并输出(o, l )，其中o是偏移值， l是匹配长度。然后窗口滑动l，继续开始编码。<br>　　如果没有找到匹配字符串，则输出(0, 0, c)，c为待编码区下一个等待编码的字符，窗口滑动“1”。</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/junyuhuang/p/4138376.html">LZ77压缩算法编码原理详解(结合图片和简单代码)</a></p>
<p>下面我们以字符串“<code>abababc</code>”为例，来了解其编码过程：</p>
<p>假设滑动窗口的大小足够大(LZ777设置的滑动窗口是32k)，可以覆盖整个字符串。</p>
<p><strong>第一步</strong>：<br>	&emsp;待编码区：abababc<br>	&emsp;搜索缓冲区：（初始为空）<br>	&emsp;操作：搜索缓冲区为空，无法找到匹配字符串。<br>	&emsp;输出：(0, 0, a)（表示没有找到匹配，输出字符a）<br>	&emsp;窗口滑动：窗口向右滑动1个字符。<br>	&emsp;结果：a已经被编码，剩下bababc。<br><strong>第二步</strong>：<br>	&emsp;待编码区：bababc<br>	&emsp;搜索缓冲区：a（已经编码的部分）<br>	&emsp;操作：在搜索缓冲区中查找b的匹配。搜索缓冲区中没有b。<br>	&emsp;输出：(0, 0, b)（表示没有找到匹配，输出字符b）<br>	&emsp;窗口滑动：窗口向右滑动1个字符。<br>	&emsp;结果：ab已经被编码，剩下ababc。<br><strong>第三步</strong>：<br>	&emsp;待编码区：ababc<br>	&emsp;搜索缓冲区：ab（已经编码的部分）<br>	&emsp;操作：在搜索缓冲区中查找ab的匹配。搜索缓冲区中存在ab，匹配长度为2。<br>	&emsp;输出：(2, 2)（表示匹配长度为2，偏移值为2）<br>	&emsp;窗口滑动：窗口向右滑动2个字符。<br>	&emsp;结果：abab已经被编码，剩下abc。<br><strong>第四步</strong>：<br>	&emsp;待编码区：abc<br>	&emsp;搜索缓冲区：abab（已经编码的部分）<br>	&emsp;操作：在搜索缓冲区中查找ab的匹配。搜索缓冲区中存在ab，匹配长度为2。<br>	&emsp;输出：(4, 2)（表示匹配长度为2，偏移值为4）<br>	&emsp;窗口滑动：窗口向右滑动2个字符。<br>	&emsp;结果：ababab已经被编码，剩下c。<br><strong>第五步</strong>：<br>	&emsp;待编码区：c<br>	&emsp;搜索缓冲区：ababab（已经编码的部分）<br>	&emsp;操作：在搜索缓冲区中查找c的匹配。搜索缓冲区中没有c。<br>	&emsp;输出：(0, 0, c)（表示没有找到匹配，输出字符c）<br>	&emsp;窗口滑动：窗口向右滑动1个字符。<br>	&emsp;结果：整个字符串已经编码完成。</p>
<p><strong>最终编码结果</strong><br>&emsp;经过上述步骤，字符串abababc的LZ77编码结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">0</span>, a) (<span class="number">0</span>, <span class="number">0</span>, b) (<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>) (<span class="number">0</span>, <span class="number">0</span>, c)</span><br></pre></td></tr></table></figure>
<p>使用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/junyuhuang/p/4138376.html">LZ77压缩算法编码原理详解(结合图片和简单代码)</a>给定的代码的编码结果是<br><img src="https://i-blog.csdnimg.cn/direct/fec766beb7344418952a7b715d53c1ea.png" alt="在这里插入图片描述"><br>说明上述编码过程分析正确！！！</p>
<p>上面的如(0, 0, a)这个其实根本不用写偏移和匹配长度，保留为原字符‘a’，占的编码长度还更短一些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">0</span>, a) (<span class="number">0</span>, <span class="number">0</span>, b) (<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>) (<span class="number">0</span>, <span class="number">0</span>, c)</span><br></pre></td></tr></table></figure>
<p>变为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ab</span>(<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>)c</span><br></pre></td></tr></table></figure>
<h3 id="霍夫曼编码算法"><a href="#霍夫曼编码算法" class="headerlink" title="霍夫曼编码算法"></a>霍夫曼编码算法</h3><p>霍夫曼编码是一种基于字符频率的变长编码方法，通过构建霍夫曼树来为每个字符分配一个唯一的二进制编码。霍夫曼树的构建过程依赖于字符的频率，频率越高的字符通常会被分配较短的编码。<br>首先我们统计”<code>abababc</code>“中每一个字符出现的频率，如下所示</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>根据霍夫曼编码的规则，我们需要按照字符频率从低到高构建霍夫曼树。以下是构建过程：</p>
<ol>
<li>将字符串出现的频率视为优先级，放入一个最小优先队列中：</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/66beb0047e2b4dcc946eab5d59ab0559.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li>然后弹出两个优先级最低的字符作为子节点, 构造出第一个二叉树; 父节点的优先级视为两个字节优先级之和, 然后把父节点插入队列中:<br><img src="https://i-blog.csdnimg.cn/direct/9488cb0dd1ed4da19e59aa5f48a6253d.png" alt="在这里插入图片描述"></li>
<li>重复这个操作, 最后我们会得到一颗二叉树. 这便是 Huffman编码 树.</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/55978a3216824675b8365a88eade715c.png" alt="在这里插入图片描述"><br>4.  我们把这棵树的左支编码为 0, 右支编码为 1, 那么从根节点向下遍历到叶子节点, 即可得出相应字符的 Huffman 编码. 因此我们得到上面例子的 Huffman 编码表为:<br><img src="https://i-blog.csdnimg.cn/direct/9b87beeda7f94b32b341d27d9c89286e.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">01</span></span><br><span class="line">c:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>现在对字符串中出现的频率都做了一个统计，只需要解决偏移量和匹配长度的编码就可以了。</p>
<p> DEFLATE 算法对偏移距离和匹配长度已经做了一个统计，见下表：<br> <strong>偏移距离</strong>：<br> 它有 0 至 29 一共 30 个编码. 距离编码的含义如下表所示:<br> <img src="https://i-blog.csdnimg.cn/direct/3b80d2f91e264311a064a808f2b952ae.png" alt="在这里插入图片描述"></p>
<ul>
<li>code表示基本的编码表示，比如编码9对应的基准距离是25</li>
<li>extra表示距离基准距离偏移了多少，编码9对应的extra为3位，最大为111（7），即25+7，最大可以表示32。</li>
<li>distance，可以表示的距离范围<br><code>总结</code>：code+extra可以灵活表示distance的任何数字</li>
</ul>
<p> <strong>匹配长度</strong>：<br>对于长度, 它与普通字符共用同一编码空间. 这个编码空间一共有 286 个编码, 范围是从 0 至 285. 其中 0 至 255 为普通字符编码, 256 表示压缩块的结束; 而 257 至 285 则表示长度. 长度编码的含义如下表所示:<br><img src="https://i-blog.csdnimg.cn/direct/cbc0b2d8ccf74078ac743dd0dfead6e0.png" alt="在这里插入图片描述"></p>
<p>与距离编码类似, 每个编码都表示一个或多个长度, 表示多个长度时后面会有 extra 位指示具体的长度. 长度编码能表示的长度范围为 3 至 258.<br>注意：所以在 DEFLATE 中，长度 1<del>2 的重复<strong>不会用匹配项表示</strong>（直接把这 1</del>2 个字节原样输出（即用字面值编码）通常比引用匹配（还要额外编码长度和距离）更短！）；只有长度 ≥ 3 时才会用匹配项 (length, distance) 来引用重复块。<br>解压时, 当读到编码小于等于 255, 则认为这是个普通字符, 原样输出即可; 若在 257 至 285 之间, 则说明遇到了一个重复标记, 这意味着当前编码表示的是长度, 且下一个编码表示的是距离. 解码得到长度和距离, 再在解压缓冲区中找到相应的部分输出即可; 若为 256, 则说明压缩块结束了.</p>
<p>从LZ777编码到霍夫曼编码<br>上一步的LZ777编码结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ab</span>(<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>)c</span><br></pre></td></tr></table></figure>
<p>字符串统计频率为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">01</span></span><br><span class="line">c:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>字符编码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101</span>(<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>)<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>然后对偏移距离和匹配长度进行编码<br>但是这里发现匹配字符长度是从3开始的，那么这个2怎么编码呢？原来这里的deflate算法是使用了改进型的LZ777算法<br>参考文章：<a target="_blank" rel="noopener" href="https://luyuhuang.tech/2020/04/28/gzip-and-deflate.html">Gzip 格式和 DEFLATE 压缩算法</a></p>
<h3 id="改进型的LZ777算法"><a href="#改进型的LZ777算法" class="headerlink" title="改进型的LZ777算法"></a>改进型的LZ777算法</h3><blockquote>
<p>LZ77压缩算法将所有数据都处理成为一个三元组串，每个三元组至少需要3个字节表示，如果在动态字典中未找到匹配字符串，会将1个字节输出为3个字节，这就导致了字节浪费。因此在DEFLATE算法中对其使用的LZ77算法进行了以下改进：</p>
<p>对匹配字符串长度小于3的字符串不压缩。因为长度小于3的字符串，使用三元组表示，对原始数据不能起到压缩的作用。<br>对字符串的匹配长度进行了限制，范围为（-128~127），用8bit表示，滑动窗口大小为32KB，用15bit表示，将压缩数据构造为标识+数据的形式，具体如表3所示。该存储方式，降低了压缩数据的存储空间。<br>由于只查找匹配长度大于3的字符串，为提高算法速度，在查找匹配字符串时，使用了哈希链结构搜索算法，其中哈希算法将3字节压缩到2字节，虽然哈希链结构存在搜索到错误结果的可能，但还是大幅提高了搜索速度。</p>
</blockquote>
<p>所以最终的编码结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">01</span></span><br><span class="line">c:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>这里的字符串“abababc”，连续匹配都没有超过三个字符，直接按照这个字符串常量进行编码即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10110110100</span></span><br></pre></td></tr></table></figure>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="压缩对象"><a href="#压缩对象" class="headerlink" title="压缩对象"></a>压缩对象</h3><p>在开始编写代码前，我们需要弄清楚，需要压缩的对象是什么？</p>
<ol>
<li>视频、音频、图片等文件本身就是压缩格式<br>mp4、jpg、png、avi、mp3 这些格 已经过复杂压缩算法处理（如 H.264、H.265、JPEG、LZ77 等）。<br>👉 所以再次使用 GZIP 压缩不会有太大效果，反而可能略微增加体积。</li>
<li>GZIP 对二进制内容的压缩效率很低<br>GZIP 是为文本内容设计的压缩算法（如 HTML、JSON、JavaScript 等）。<br>它依赖数据的可预测性和重复性（如文本中的重复词、空格等）来压缩。<br>视频文件的数据模式看起来是“随机的”，压缩器无法从中找到有效的模式。</li>
</ol>
<h3 id="gzip实现"><a href="#gzip实现" class="headerlink" title="gzip实现"></a>gzip实现</h3><p><code>GzipMiddleware.h</code>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">GzipMiddleware</span>():<span class="built_in">clientSupportGzip_</span>(<span class="literal">true</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">before</span><span class="params">(HttpRequest&amp; request)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">after</span><span class="params">(HttpResponse&amp; response)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setClientSupportGzip</span><span class="params">(<span class="type">bool</span> flag)</span></span>&#123;clientSupportGzip_=flag;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isClinetSupportGzip</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> clientSupportGzip_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getGzipEnableRate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">uint64_t</span> total = totalRequests_.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">return</span> total == <span class="number">0</span> ? <span class="number">0.0</span> : (<span class="type">double</span>)gzipAppliedCount_.<span class="built_in">load</span>() / total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getAverageCompressionRatio</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">uint64_t</span> original = originalSizeSum_.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">return</span> original == <span class="number">0</span> ? <span class="number">0.0</span> : (<span class="type">double</span>)compressedSizeSum_.<span class="built_in">load</span>() / original;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compressGzip</span><span class="params">(<span class="type">const</span> std::string&amp; input, std::string&amp; output)</span></span>;</span><br><span class="line">    <span class="type">bool</span> clientSupportGzip_;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// gzip统计信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkArchive</span><span class="params">()</span></span>;  <span class="comment">// 检查是否需要归档</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetStats</span><span class="params">()</span></span>;    <span class="comment">// 重置统计信息</span></span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; totalRequests_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; gzipAppliedCount_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; originalSizeSum_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; compressedSizeSum_&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::function&lt;void(uint64_t, uint64_t, uint64_t, uint64_t)&gt; archiveCallback_;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> MAX_REQUESTS_BEFORE_ARCHIVE = <span class="number">1e9</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> MAX_ORIGINAL_SIZE_BEFORE_ARCHIVE = <span class="number">1ULL</span> &lt;&lt; <span class="number">40</span>; <span class="comment">// 1 TB</span></span><br></pre></td></tr></table></figure>

<p><code>GzipMiddleware.cpp</code>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GzipMiddleware::before</span><span class="params">(HttpRequest&amp; request)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 从客户端请求头中获取 Accept-Encoding 字段</span></span><br><span class="line">    std::string acceptEncoding=request.<span class="built_in">getHeader</span>(<span class="string">&quot;Accept-Encoding&quot;</span>);</span><br><span class="line">     <span class="comment">// 判断是否包含 &quot;gzip&quot; 关键字</span></span><br><span class="line">    <span class="comment">// 如果包含，说明客户端支持 gzip 压缩</span></span><br><span class="line">    <span class="comment">// 否则，不支持 gzip 压缩，如果不支持，就不进行gzip压缩</span></span><br><span class="line">    acceptEncoding.<span class="built_in">find</span>(<span class="string">&quot;gzip&quot;</span>) != std::string::npos?<span class="built_in">setClientSupportGzip</span>(<span class="literal">true</span>):<span class="built_in">setClientSupportGzip</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">// GzipMiddleware::after</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GzipMiddleware::after</span><span class="params">(HttpResponse&amp; response)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 统计总请求数（用于后续压缩统计归档）</span></span><br><span class="line">    totalRequests_++;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isClinetSupportGzip</span>())     <span class="comment">// 如果客户端不支持 gzip，则直接跳过压缩</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否应该压缩，消息体大于256字节并且消息类型是文本、html等类型才可以</span></span><br><span class="line">    <span class="comment">//对于视频、图片等已经使用了其他压缩算法进行压缩了的，就不再使用gzip进行压缩了</span></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="built_in">isShouldGzipCompress</span>()) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始响应体内容</span></span><br><span class="line">    <span class="type">const</span> std::string&amp; rawBody = response.<span class="built_in">getBody</span>();</span><br><span class="line">    std::string compressed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用实际压缩方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">compressGzip</span>(rawBody, compressed)) &#123;</span><br><span class="line">        <span class="comment">// LOG_INFO&lt;&lt;&quot;gzipAppliedCount_:&quot;&lt;&lt;gzipAppliedCount_.load()&lt;&lt;&quot;originalSizeSum_&quot;&lt;&lt;originalSizeSum_.load()&lt;&lt;&quot;compressedSizeSum_&quot;&lt;&lt;compressedSizeSum_.load();</span></span><br><span class="line">        gzipAppliedCount_++;</span><br><span class="line">        originalSizeSum_ += rawBody.<span class="built_in">size</span>();</span><br><span class="line">        compressedSizeSum_ +=compressed.<span class="built_in">size</span>();</span><br><span class="line">        response.<span class="built_in">addHeader</span>(<span class="string">&quot;Content-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>);  <span class="comment">// 添加响应头标识压缩格式为 gzip</span></span><br><span class="line">        response.<span class="built_in">setContentLength</span>(compressed.<span class="built_in">size</span>());    <span class="comment">// 更新 Content-Length 为压缩后大小</span></span><br><span class="line">        response.<span class="built_in">setBody</span>(compressed);                    <span class="comment">// 设置压缩后的响应体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否需要归档统计信息</span></span><br><span class="line">    <span class="built_in">checkArchive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">// GzipMiddleware::compressGzip实际的压缩处理算法</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GzipMiddleware::compressGzip</span><span class="params">(<span class="type">const</span> std::string&amp; input, std::string&amp; output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> CHUNK = <span class="number">16384</span>; </span><br><span class="line">    z_stream strm&#123;&#125;;    <span class="comment">//zlib 用于压缩的状态结构体，记录输入、输出缓冲区状态等</span></span><br><span class="line">    <span class="type">char</span> out[CHUNK];    <span class="comment">//输出缓冲区，用来暂存压缩后的数据块</span></span><br><span class="line"></span><br><span class="line">    strm.zalloc = Z_NULL;</span><br><span class="line">    strm.zfree = Z_NULL;</span><br><span class="line">    strm.opaque = Z_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deflateInit2</span>(&amp;strm,             <span class="comment">//压缩状态</span></span><br><span class="line">                     Z_BEST_COMPRESSION, <span class="comment">//压缩等级（0~9），9 表示最高压缩比，牺牲性能</span></span><br><span class="line">                     Z_DEFLATED,         <span class="comment">//使用 DEFLATE 算法</span></span><br><span class="line">                     <span class="number">15</span> + <span class="number">16</span>,           <span class="comment">//15位窗口大小(32KB), +16启用 GZIP 格式输出（否则是 zlib）</span></span><br><span class="line">                     <span class="number">8</span>,                 <span class="comment">//内部压缩缓冲区大小参数，一般为 8</span></span><br><span class="line">                     Z_DEFAULT_STRATEGY) != Z_OK) <span class="comment">//默认压缩策略</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strm.avail_in = input.<span class="built_in">size</span>();          <span class="comment">// 待压缩数据长度</span></span><br><span class="line">    strm.next_in = (Bytef*)input.<span class="built_in">data</span>();   <span class="comment">// 待压缩数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        strm.avail_out = CHUNK;            <span class="comment">//待压缩数据存储buffer 的长度，如果多次写，会覆盖之前的写的数据</span></span><br><span class="line">                                            <span class="comment">//当然，之前的数据已经被读走了</span></span><br><span class="line">        strm.next_out = <span class="built_in">reinterpret_cast</span>&lt;Bytef*&gt;(out); <span class="comment">//待压缩数据存储的buffer</span></span><br><span class="line">        <span class="built_in">deflate</span>(&amp;strm, Z_FINISH);            <span class="comment">//如果输入和待输出的数据都被处理完，则返回 Z_STREAM_END</span></span><br><span class="line">        <span class="type">size_t</span> have = CHUNK - strm.avail_out;<span class="comment">//总长度-当前可写=已经写的数据长度</span></span><br><span class="line">        output.<span class="built_in">append</span>(out, have);</span><br><span class="line">    &#125; <span class="keyword">while</span> (strm.avail_out == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deflateEnd</span>(&amp;strm);                       <span class="comment">//释放deflateInit2申请的空间</span></span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;原始的数据大小为:&quot;</span>&lt;&lt; input.<span class="built_in">size</span>();</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;GZIP压缩完成,压缩比例为:&quot;</span>&lt;&lt;(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(output.<span class="built_in">size</span>()) / input.<span class="built_in">size</span>());;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GzipMiddleware::checkArchive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果压缩的总请求数或原始数据累计大小超过阈值</span></span><br><span class="line">    <span class="comment">// 就清理统计数据（可用于后续监控、日志）</span></span><br><span class="line">    <span class="keyword">if</span> (totalRequests_ &gt;= MAX_REQUESTS_BEFORE_ARCHIVE ||</span><br><span class="line">        originalSizeSum_ &gt;= MAX_ORIGINAL_SIZE_BEFORE_ARCHIVE) &#123;</span><br><span class="line"></span><br><span class="line">        totalRequests_ = <span class="number">0</span>;</span><br><span class="line">        gzipAppliedCount_ = <span class="number">0</span>;</span><br><span class="line">        originalSizeSum_ = <span class="number">0</span>;</span><br><span class="line">        compressedSizeSum_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现的函数有：</p>
<ul>
<li><code>before()</code>函数，判断请求是否支持gzip压缩</li>
<li><code>after()</code>函数，统计请求，如果客户端不支持gzip压缩就返回；否则对其进行gzip压缩并填充响应体部分</li>
<li><code>compressGzip()</code>函数，实际的压缩处理核心部分</li>
<li><code>checkArchive()</code>函数，用于统计压缩的情况，如平均压缩率等</li>
</ul>
<p>本代码实现<code>gzip</code>的核心部分就是在<code>compressGzip</code>函数中进行了实际的压缩，<code>compressGzip</code>调用了<code>deflate</code>函数进行实际的压缩。关于<code>deflate</code>函数的介绍，可以参考<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_61476090/article/details/136592993">深入理解数据压缩流程及 zlib 库中相关函数</a></p>
<h2 id="运行分析"><a href="#运行分析" class="headerlink" title="运行分析"></a>运行分析</h2><p>运行服务器，查看gzip压缩是否启用成功，有三个地方可以查看gzip的压缩启用是否成功。分别是日志系统、wireshark抓包分析、LiteHub前端展示。</p>
<h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p><img src="https://i-blog.csdnimg.cn/direct/53ab09d1730c4a34a4e47c85840f2ed9.png" alt="在这里插入图片描述"><br>这个压缩比例计算方式是：压缩后的数据大小除以压缩前的数据大小。可以看到gzip是有效压缩成功了的。</p>
<h3 id="wireshark抓包查看"><a href="#wireshark抓包查看" class="headerlink" title="wireshark抓包查看"></a>wireshark抓包查看</h3><p><img src="https://i-blog.csdnimg.cn/direct/01844c8007ad426badcf683ae73e916f.png" alt="在这里插入图片描述"><br>首先看客户端发起的每一次请求都会携带<code>Accept-Encoding:</code>字段，该字段中携带了 <code>gzip, deflate</code>表示支持<code>gzip</code>压缩方式。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/dede28be630f4f83839cfd4b59dc07a8.png" alt="在这里插入图片描述"><br>这个报文是从服务器发回的响应报文，客户端收到压缩后的信息包后自动解压，从2380字节解压到原来的9182字节，这也进一步说明了设计的gzip压缩算法是有效的。</p>
<h3 id="后台管理界面查看"><a href="#后台管理界面查看" class="headerlink" title="后台管理界面查看"></a>后台管理界面查看</h3><p>此外，在LiteHub前端界面，也是可以通过管理员账户查看具体的gzip的一个压缩信息的。<br><img src="https://i-blog.csdnimg.cn/direct/83851fc1911e4c46a9cd62699348187a.png" alt="在这里插入图片描述"><br>关于gzip的理解就分析到这了，如果有不恰当之前，请您指出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/05/LiteHub%E4%B9%8Bgzip%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" data-id="cmcy7r5ug0001ysvbarpd0mmc" data-title="LiteHub之gzip压缩算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="litehub/_posts-LiteHub之中间件限流实现" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/04/LiteHub%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2025-07-04T05:28:22.000Z" itemprop="datePublished">2025-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/04/LiteHub%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0/">LiteHub之中间件限流实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@<a href="%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0">TOC</a></p>
<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><p><strong>为什么要限流？</strong></p>
<blockquote>
<p>在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流。<br>其中，限流在很多场景中用来限制并发和请求量，比如说秒杀抢购，保护自身系统和下游系统不被巨型流量冲垮等。</p>
</blockquote>
<p>常见的限流方法包括计数器、滑动窗口、漏桶和令牌桶算法。</p>
<h3 id="计数器算法："><a href="#计数器算法：" class="headerlink" title="计数器算法："></a>计数器算法：</h3><p>在一段时间间隔内（时间窗&#x2F;时间区间，处理请求的最大数量固定，超过部分不做处理。<br>简单粗暴，比如指定线程池大小，指定数据库连接池大小、nginx连接数等，这都属于计数器算法。</p>
<p>计数器算法是限流算法里最简单也是最容易实现的一种算法。<br>举个例子，比如我们规定对于接口A，我们1分钟的访问次数不能超过100个。</p>
<p>计数器限流的做法是：<br>我们可以初始化一个计数器<code>counter</code>，每当收到请求时<code>counter</code>加1。若<code>counter</code>值超过100且当前请求与首个请求的时间间隔小于1分钟，则判定为请求过多并拒绝访问；若时间间隔超过1分钟且<code>counter</code>仍在限流范围内，则重置<code>counter</code>。</p>
<p>但是这个方法存在一个显著的问题，攻击者可以在0:59的时候一次性发100个请求；到1:00就会将计数器清零，然后在1:01的时候再发100个请求；对于0:00-1:00和1:00-2:00这两个一分钟的请求都是100个请求，看起来是满足系统的要求的；但是在0:59-1:01这不足1分钟的时间段内，却发起了200个请求，可能会引起系统奔溃。</p>
<h3 id="滑动窗口算法："><a href="#滑动窗口算法：" class="headerlink" title="滑动窗口算法："></a>滑动窗口算法：</h3><blockquote>
<p>滑动窗口<code>（rolling window）</code>是一种时间分段技术。在计数器算法中，如果限制1分钟内的访问次数，这个1分钟就是一个固定时间窗口。而滑动窗口则是将这个固定窗口进一步细分成多个更小的时间单元。<br><img src="https://i-blog.csdnimg.cn/direct/b1e9da23e98b47348d19c748eae2e173.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>例如：将1分钟的固定窗口划分为6个10秒的小窗口。整个红色矩形框代表一个大时间窗口，窗口会持续滑动，每10秒向右移动一格。假设在第一分钟的第59秒收到100个请求（落在灰色格子），第二分钟的1:00又收到100个请求（落在橘黄色格子）。此时滑动窗口检测到完整1分钟（红色框）内的总请求量达到200次，超过100次的限流阈值，就能及时触发限流机制。<br>滑动窗口划分得越精细，限流统计的准确性就越高，但过于精细会增加系统负担。</p>
<h3 id="漏桶算法："><a href="#漏桶算法：" class="headerlink" title="漏桶算法："></a>漏桶算法：</h3><blockquote>
<p>水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会超过桶可接纳的容量时直接溢出。<br>漏桶算法可以粗略的认为就是注水漏水过程，往桶中以任意速率流入水，以一定速率流出水，当水超过桶容量（capacity）则丢弃，因为桶容量是不变的，保证了整体的速率。<br><img src="https://i-blog.csdnimg.cn/direct/66a3dbd876f442978e31a8d5cca98ca9.png" alt="在这里插入图片描述"><br>总结：漏桶算法通过一个固定容量和固定漏水速率的水桶模型，强制将任意输入流量整形为恒定速率输出，并在流量超过容量时丢弃请求，以此实现速率限制、流量平滑和系统保护。</p>
</blockquote>
<h3 id="令牌桶算法："><a href="#令牌桶算法：" class="headerlink" title="令牌桶算法："></a>令牌桶算法：</h3><blockquote>
<p>令牌桶是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌，填满了就丢弃令牌，请求是否被处理要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求。在流量低峰的时候，令牌桶会出现堆积，因此当出现瞬时高峰的时候，有足够多的令牌可以获取，令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌。令牌桶中装的是令牌。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/ed3860c85b6442608f5311d4a2da95af.png" alt="在这里插入图片描述"></p>
</blockquote>
<p><strong>特点</strong>：与漏桶算法相比，令牌桶算法允许短时间内的请求量激增（获得令牌后即可访问接口，可能出现瞬间消耗所有累积令牌的情况），但不会像计数算法那样产生过高峰值（因为令牌是匀速生成的）。因此，令牌桶算法在处理突发流量时表现更优。<br>部分内容和图片来源：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/652873702">常见限流算法：计数器、滑动窗口、漏桶、令牌桶</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/crazymakercircle/article/details/130035504">限流：计数器、漏桶、令牌桶 三大算法的原理与实战（史上最全）</a></p>
<h2 id="限流实现"><a href="#限流实现" class="headerlink" title="限流实现"></a>限流实现</h2><p>本项目我是基于令牌桶实现的访问限流，请看以下代码<br><code>LimitMiddleware.h</code>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LimitMiddleware</span>: <span class="keyword">public</span> Middleware </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="comment">// rate：令牌生成速率（个/秒）</span></span><br><span class="line">    <span class="comment">// capacity：桶最大容量（最多存多少个令牌）</span></span><br><span class="line">    <span class="built_in">LimitMiddleware</span>(<span class="type">int</span> rate, <span class="type">int</span> capacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在请求处理前调用，用于限流</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">before</span><span class="params">(HttpRequest&amp; request)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">after</span><span class="params">(HttpResponse&amp; response)</span> <span class="keyword">override</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">gettokens</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> tokens_;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 补充令牌（根据时间推移）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">refillTokens</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> rate_;            <span class="comment">// 令牌生成速率（个/秒）</span></span><br><span class="line">    <span class="type">int</span> capacity_;        <span class="comment">// 桶容量（最大令牌数）</span></span><br><span class="line">    <span class="type">double</span> tokens_;       <span class="comment">// 当前可用令牌数（允许小数，更精确）</span></span><br><span class="line">    std::chrono::steady_clock::time_point lastRefillTime_; <span class="comment">// 上一次补充时间</span></span><br><span class="line">    std::mutex mutex_;    <span class="comment">// 保护多线程访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>LimitMiddleware.cc</code>文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌桶限流中间件</span></span><br><span class="line"><span class="comment">// 构造函数：指定令牌产生速率 rate (个/秒) 和桶容量 capacity (最多可存储多少令牌)</span></span><br><span class="line">LimitMiddleware::<span class="built_in">LimitMiddleware</span>(<span class="type">int</span> rate, <span class="type">int</span> capacity)</span><br><span class="line">    : <span class="built_in">rate_</span>(rate),</span><br><span class="line">      <span class="built_in">capacity_</span>(capacity),</span><br><span class="line">      <span class="built_in">tokens_</span>(capacity),  <span class="comment">// 初始化时桶是满的，令牌数等于容量</span></span><br><span class="line">      <span class="built_in">lastRefillTime_</span>(steady_clock::<span class="built_in">now</span>())  <span class="comment">// 记录上次补充令牌的时间</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌补充逻辑</span></span><br><span class="line"><span class="comment">// 根据距离上次补充的时间，按速率补充新令牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LimitMiddleware::refillTokens</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> elapsedMs = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now - lastRefillTime_).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elapsedMs &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 按照速率计算可以补充的令牌数</span></span><br><span class="line">        <span class="type">double</span> newTokens = (elapsedMs / <span class="number">1000.0</span>) * rate_;</span><br><span class="line">        <span class="comment">// 桶中的令牌数不能超过容量上限</span></span><br><span class="line">        tokens_ = std::<span class="built_in">min</span>((<span class="type">double</span>)capacity_, tokens_ + newTokens);</span><br><span class="line">        <span class="comment">// 更新时间戳</span></span><br><span class="line">        lastRefillTime_ = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求前执行：判断是否有足够的令牌</span></span><br><span class="line"><span class="comment">//如果有足够的令牌，进行下一步操作</span></span><br><span class="line"><span class="comment">//如果没有，拒绝访问，返回状态码429</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LimitMiddleware::before</span><span class="params">(HttpRequest&amp; request)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 加锁保证多线程安全</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先补充令牌</span></span><br><span class="line">    <span class="built_in">refillTokens</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tokens_ &gt;= <span class="number">1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tokens_ -= <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 有足够令牌，消费 1 个，允许请求通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 没有足够令牌，请求被拒绝，抛出 429 响应</span></span><br><span class="line">        HttpResponse resp;</span><br><span class="line">        resp.<span class="built_in">setStatusLine</span>(request.<span class="built_in">getVersion</span>(), http::HttpResponse::k429TooManyRequests, <span class="string">&quot;Too Many Requests&quot;</span>);</span><br><span class="line">        resp.<span class="built_in">setCloseConnection</span>(<span class="literal">true</span>);</span><br><span class="line">        resp.<span class="built_in">setContentType</span>(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        resp.<span class="built_in">setContentLength</span>(<span class="number">0</span>);</span><br><span class="line">        resp.<span class="built_in">setBody</span>(<span class="string">&quot;Rate limit exceeded. Please try again later.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>核心逻辑是：</p>
<ul>
<li>按固定速率补充令牌（<code>refillTokens</code>）</li>
<li>请求到来时消费令牌（<code>before</code>）</li>
<li>没有令牌可用时返回（限流了，返回状态码<code>429 Too Many Requests</code>）</li>
</ul>
<h2 id="限流测试"><a href="#限流测试" class="headerlink" title="限流测试"></a>限流测试</h2><p>在<code>WebApps/LiteHubServer/src/LiteHubServer.cpp</code>中的<code>initializeMiddleware</code>函数中，定义了限流中间件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limitMiddleware_ = std::<span class="built_in">make_shared</span>&lt;http::middleware::LimitMiddleware&gt;(<span class="number">1</span>,<span class="number">100</span>); <span class="comment">// 每秒最多100个请求</span></span><br><span class="line">httpServer_.<span class="built_in">addMiddleware</span>(limitMiddleware_);</span><br></pre></td></tr></table></figure>
<p>这里定义的是一秒不超过100个请求，如果通过手动点击，这个1秒内怎么也到不了100次请求；所以我通过python脚本代码模拟一次大量的访问，python代码如下，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="comment"># 压测参数配置</span></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line">TOTAL_REQUESTS = <span class="number">150</span>      <span class="comment"># 总请求数</span></span><br><span class="line">MAX_WORKERS = <span class="number">3</span>           <span class="comment"># 并发线程数</span></span><br><span class="line">REQUEST_INTERVAL = <span class="number">0.02</span>   <span class="comment"># 相邻请求的间隔（秒），避免瞬间爆发</span></span><br><span class="line">TARGET_URL = <span class="string">&quot;http://47.122.77.97/&quot;</span>  <span class="comment"># 目标 URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="comment"># 单次请求任务</span></span><br><span class="line"><span class="comment"># index: 请求编号</span></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_request</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="comment"># 发起 GET 请求</span></span><br><span class="line">        r = requests.get(TARGET_URL, timeout=<span class="number">3</span>)</span><br><span class="line">        elapsed = time.time() - start_time</span><br><span class="line">        <span class="comment"># 打印日志：时间戳 + 请求序号 + 响应码 + 耗时</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[<span class="subst">&#123;time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)&#125;</span>] 请求 <span class="subst">&#123;index + <span class="number">1</span>:02d&#125;</span> --&gt; 状态码: <span class="subst">&#123;r.status_code&#125;</span> (耗时: <span class="subst">&#123;elapsed:<span class="number">.2</span>f&#125;</span>s)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> r.status_code</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 异常时打印错误信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[<span class="subst">&#123;time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)&#125;</span>] 请求 <span class="subst">&#123;index + <span class="number">1</span>:02d&#125;</span> --&gt; 失败: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;开始压测，总请求数：<span class="subst">&#123;TOTAL_REQUESTS&#125;</span>，最大并发数：<span class="subst">&#123;MAX_WORKERS&#125;</span>&quot;</span>)</span><br><span class="line">    results = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录整个压测开始时间</span></span><br><span class="line">    total_start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建线程池</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=MAX_WORKERS) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = []</span><br><span class="line">        <span class="comment"># 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(TOTAL_REQUESTS):</span><br><span class="line">            futures.append(executor.submit(send_request, i))</span><br><span class="line">            time.sleep(REQUEST_INTERVAL)  <span class="comment"># 控制相邻请求的间隔</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">            results.append(future.result())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录整个压测结束时间</span></span><br><span class="line">    total_elapsed = time.time() - total_start_time</span><br><span class="line"></span><br><span class="line">    <span class="comment"># -------------------------------</span></span><br><span class="line">    <span class="comment"># 统计与输出结果</span></span><br><span class="line">    <span class="comment"># -------------------------------</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n-----------------------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求状态统计结果:&quot;</span>)</span><br><span class="line">    counts = Counter(results)</span><br><span class="line">    <span class="keyword">for</span> key, count <span class="keyword">in</span> counts.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;count&#125;</span> 次&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n压测总耗时: <span class="subst">&#123;total_elapsed:<span class="number">.2</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>执行python代码的结果如下：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/6f292cb378614e059d19263d3f2b193a.png" alt="在这里插入图片描述"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/1ac4803738774abf83289aa77a6786b0.png" alt="在这里插入图片描述"><br>可用看到总共有104次请求成功；46次拒绝访问。证明了设计的令牌桶限流策略有效。<br>我们将REQUEST_INTERVAL 调整的大一些，避免瞬间的大量请求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REQUEST_INTERVAL = <span class="number">0.1</span>   </span><br></pre></td></tr></table></figure>
<p>再执行一次：<br><img src="https://i-blog.csdnimg.cn/direct/4deda10211bd47858dac5decd3d12efe.png" alt="在这里插入图片描述"><br>拒绝访问的次数也少了一些，从（46—&gt;&gt;&gt;34,即减少了12次）。</p>
<p>下图为wireshark抓包到的429状态码响应：<br><img src="https://i-blog.csdnimg.cn/direct/25690cf01b974d4db59bc45f50b92eb5.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/04/LiteHub%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0/" data-id="cmcy7r5ui0002ysvb368x09ot" data-title="LiteHub之中间件限流实现" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="litehub/_posts-LiteHub之跨域访问CORS" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/03/LiteHub%E4%B9%8B%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AECORS/" class="article-date">
  <time class="dt-published" datetime="2025-07-03T02:39:39.000Z" itemprop="datePublished">2025-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/03/LiteHub%E4%B9%8B%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AECORS/">LiteHub之跨域访问CORS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@<a href="%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AECORS">TOC</a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在浏览器安全模型中，同源策略是最重要的安全基石。<br>一个“域”是由3个要素组成的：</p>
<ul>
<li><strong>协议</strong>（如：http 或 https）</li>
<li><strong>主机</strong>（Host，如 <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> 或 127.0.0.1）</li>
<li><strong>端口</strong>（Port，如 80 或 8080）</li>
</ul>
<p>只要这三个完全一致，就是同源的。<br><strong>例如</strong>：</p>
<ul>
<li><a href="http://example.com/">http://example.com:80</a> 和 <a href="http://example.com:8080/">http://example.com:8080</a> 是不同源</li>
<li><a href="http://example.com/">http://example.com</a> 和 <a href="https://example.com/">https://example.com</a> 是不同源</li>
</ul>
<p>下面是官网解释跨域的图解：<br><img src="https://i-blog.csdnimg.cn/direct/75cbb0811c0344678ae998ab647cf543.png" alt="在这里插入图片描述"></p>
<p><code>两种请求</code>：浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p> 按照 W3C 的 CORS 规范，只有完全满足「安全要求」的跨域请求，浏览器才会把它直接当成简单请求，直接发送给服务端，不需要先发 OPTIONS。<br> 必须同时满足以下条件</p>
<ol>
<li>请求方法必须是（<code>GET/HEAD/POST</code>）三者之一</li>
<li>请求头不能超出以下几个字段（<code>Accept、Accept-Language、Content-Language、Content-Type</code>）等</li>
<li><code>Content-Type</code>（如果存在的话），其值只能是<code>application/x-www-form-urlencoded、multipart/form-data、text/plain</code></li>
</ol>
<h3 id="非简单请求（预检请求）"><a href="#非简单请求（预检请求）" class="headerlink" title="非简单请求（预检请求）"></a>非简单请求（预检请求）</h3><p>非简单请求是指那些对服务器有特殊要求的请求，例如：</p>
<ul>
<li>使用PUT或DELETE方法</li>
<li>设置Content-Type为application&#x2F;json<br>即不满足简单请求的条件的都是预检请求（非简单请求）。</li>
</ul>
<p>对于这类请求，浏览器会在正式通信前额外发送一次HTTP查询请求（即预检请求），这个过程叫做预检<code>（Preflight）</code>。该请求会确认：</p>
<ol>
<li>当前网页域名是否在服务器的许可名单中</li>
<li>允许使用的HTTP方法和头信息字段<br>只有在获得服务器肯定答复后，浏览器才会发出正式的XMLHttpRequest请求，否则将报错。</li>
</ol>
<p>“预检请求”用的请求方法是 <code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字是 <code>Origin</code>，表示请求来自哪个源。<br>除了 Origin 字段，“预检请求”的头信息包括两个特殊字段。<br>• <code>Access-Control-Request-Method</code>：必须字段，列出浏览器的 CORS 请求会用到哪些 HTTP 方法；<br>• <code>Access-Control-Request-Headers</code>：这个字段是一个逗号 , 分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上面示例是 X-Custom-Header。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p> <strong>CORS</strong>（Cross-Origin Resource Sharing，跨域资源共享）通过在响应头里加上一组特殊字段来告诉浏览器，这个资源允许被某些源访问。</p>
<h3 id="服务器端Cors的关键配置"><a href="#服务器端Cors的关键配置" class="headerlink" title="服务器端Cors的关键配置"></a>服务器端Cors的关键配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CorsConfig</span> </span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; allowedOrigins;<span class="comment">//允许哪些域名可以访问</span></span><br><span class="line">    std::vector&lt;std::string&gt; allowedMethods; <span class="comment">//允许哪些方法可以跨域调用</span></span><br><span class="line">    std::vector&lt;std::string&gt; allowedHeaders; <span class="comment">//允许前端请求里带哪些请求头</span></span><br><span class="line">    <span class="type">bool</span> allowCredentials = <span class="literal">false</span>; <span class="comment">//不允许携带Cookie/Authorization header/TLS client cert 这类凭证信息</span></span><br><span class="line">    <span class="type">int</span> maxAge = <span class="number">3600</span>;             <span class="comment">//浏览器缓存预检请求的最大时长, 1 小时内同样的跨域请求只会发送一次 OPTIONS，之后直接用缓存的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> CorsConfig <span class="title">defaultConfig</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CorsConfig config;</span><br><span class="line">        config.allowedOrigins = &#123;<span class="string">&quot;*&quot;</span>&#125;; <span class="comment">//这里允许的是所有域名</span></span><br><span class="line">        config.allowedMethods = &#123;<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>&#125;; <span class="comment">//在预检请求（OPTIONS）的响应里告诉浏览器：后端接受哪些方法</span></span><br><span class="line">        config.allowedHeaders = &#123;<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;Authorization&quot;</span>&#125;; <span class="comment">//允许前端带Content-Type（比如 application/json）和Authorization（携带JWT Token等）</span></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="服务端解析预检请求"><a href="#服务端解析预检请求" class="headerlink" title="服务端解析预检请求"></a>服务端解析预检请求</h3><p>处理客户端发来的请求的流程如下：</p>
<ol>
<li>判断是否是预检请求，如果是，进入下一步；否则不做处理（正常的请求，继续后续的处理流程，响应）</li>
<li>检查当前请求的源是否被允许，如果允许当前请求源则在响应头中添加该源字段，状态码为204 No content,响应体为空，进入下一步</li>
<li>直接抛出特殊的响应对象（中断后续的处理流程）</li>
</ol>
<p><code>总结</code>：如果是预检请求，设置Cors的相关字段，直接返回；否则就进入正常的处理流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief 请求前钩子，所有请求进来时都会先执行</span></span><br><span class="line"><span class="comment"> * 如果是跨域的 OPTIONS 预检请求，直接构造响应并抛出，跳过后续中间件/路由逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CorsMiddleware::before</span><span class="params">(HttpRequest&amp; request)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">&quot;CorsMiddleware::before - Processing request&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是浏览器发起的预检请求（CORS Preflight）</span></span><br><span class="line">    <span class="keyword">if</span> (request.<span class="built_in">method</span>() == HttpRequest::Method::kOptions) </span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;Processing CORS preflight request&quot;</span>;</span><br><span class="line">        HttpResponse response;  <span class="comment">// 创建预检响应</span></span><br><span class="line">        <span class="built_in">handlePreflightRequest</span>(request, response);</span><br><span class="line">        <span class="comment">// 直接中断后续处理流程，抛出特殊的响应对象</span></span><br><span class="line">        <span class="keyword">throw</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理 CORS 预检请求（OPTIONS）</span></span><br><span class="line"><span class="comment"> * 会校验 Origin，并返回允许的跨域头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CorsMiddleware::handlePreflightRequest</span><span class="params">(<span class="type">const</span> HttpRequest&amp; request, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          HttpResponse&amp; response)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">     <span class="comment">// 从请求头获取 Origin</span></span><br><span class="line">    <span class="type">const</span> std::string&amp; origin = request.<span class="built_in">getHeader</span>(<span class="string">&quot;Origin&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验是否允许跨域</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isOriginAllowed</span>(origin)) </span><br><span class="line">    &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">&quot;Origin not allowed: &quot;</span> &lt;&lt; origin;</span><br><span class="line">        response.<span class="built_in">setStatusCode</span>(HttpResponse::k403Forbidden);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加允许的跨域头,对预检请求返回 204 No Content；</span></span><br><span class="line">    <span class="comment">//即响应体为空，对应返回的是options字段的预检请求的响应</span></span><br><span class="line">    <span class="built_in">addCorsHeaders</span>(response, origin);</span><br><span class="line">    response.<span class="built_in">setStatusCode</span>(HttpResponse::k204NoContent);</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;Preflight request processed successfully&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检查给定 Origin 是否在允许列表里</span></span><br><span class="line"><span class="comment"> * @param origin 来自浏览器请求头的 Origin</span></span><br><span class="line"><span class="comment"> * @return true 如果允许跨域，否则 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CorsMiddleware::isOriginAllowed</span><span class="params">(<span class="type">const</span> std::string&amp; origin)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config_.allowedOrigins.<span class="built_in">empty</span>() || </span><br><span class="line">           std::<span class="built_in">find</span>(config_.allowedOrigins.<span class="built_in">begin</span>(), </span><br><span class="line">                    config_.allowedOrigins.<span class="built_in">end</span>(), <span class="string">&quot;*&quot;</span>) != config_.allowedOrigins.<span class="built_in">end</span>() ||</span><br><span class="line">           std::<span class="built_in">find</span>(config_.allowedOrigins.<span class="built_in">begin</span>(), </span><br><span class="line">                    config_.allowedOrigins.<span class="built_in">end</span>(), origin) != config_.allowedOrigins.<span class="built_in">end</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 给响应添加标准的 CORS 头信息</span></span><br><span class="line"><span class="comment"> * @param response 当前响应对象</span></span><br><span class="line"><span class="comment"> * @param origin 本次请求允许的 Origin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CorsMiddleware::addCorsHeaders</span><span class="params">(HttpResponse&amp; response, </span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> std::string&amp; origin)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 设置允许的 Origin</span></span><br><span class="line">        response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, origin);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 是否允许携带 cookie</span></span><br><span class="line">        <span class="keyword">if</span> (config_.allowCredentials) </span><br><span class="line">        &#123;</span><br><span class="line">            response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置允许的方法列表,以，分割</span></span><br><span class="line">        <span class="keyword">if</span> (!config_.allowedMethods.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, </span><br><span class="line">                             <span class="built_in">join</span>(config_.allowedMethods, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置允许的自定义请求头列表</span></span><br><span class="line">        <span class="keyword">if</span> (!config_.allowedHeaders.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, </span><br><span class="line">                             <span class="built_in">join</span>(config_.allowedHeaders, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置预检结果的缓存时间（单位：秒）</span></span><br><span class="line">        response.<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, </span><br><span class="line">                          std::<span class="built_in">to_string</span>(config_.maxAge));</span><br><span class="line">        </span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">&quot;CORS headers added successfully&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) </span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">&quot;Error adding CORS headers: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 工具函数：把字符串数组用指定分隔符拼接起来</span></span><br><span class="line"><span class="comment"> * @param strings 字符串列表</span></span><br><span class="line"><span class="comment"> * @param delimiter 分隔符，如 &quot;, &quot;</span></span><br><span class="line"><span class="comment"> * @return 拼接后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">CorsMiddleware::join</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; strings, <span class="type">const</span> std::string&amp; delimiter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ostringstream result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; strings.<span class="built_in">size</span>(); ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) result &lt;&lt; delimiter;</span><br><span class="line">        result &lt;&lt; strings[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="服务端填充响应"><a href="#服务端填充响应" class="headerlink" title="服务端填充响应"></a>服务端填充响应</h3><p>这里的响应指的是正常处理客户端发来的请求后，在最终的响应头中添加CORS的相关信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 请求后钩子，正常请求处理完毕后执行。</span></span><br><span class="line"><span class="comment"> * 不管是否跨域，都会在最终响应头里加上 CORS 相关头信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CorsMiddleware::after</span><span class="params">(HttpResponse&amp; response)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">&quot;CorsMiddleware::after - Processing response&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接添加CORS头，简化处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (!config_.allowedOrigins.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果允许所有源</span></span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">find</span>(config_.allowedOrigins.<span class="built_in">begin</span>(), config_.allowedOrigins.<span class="built_in">end</span>(), <span class="string">&quot;*&quot;</span>) </span><br><span class="line">            != config_.allowedOrigins.<span class="built_in">end</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">addCorsHeaders</span>(response, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 简单处理：只取第一个允许的来源（可以按需改成匹配实际请求来源）</span></span><br><span class="line">            <span class="built_in">addCorsHeaders</span>(response, config_.allowedOrigins[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p><img src="https://i-blog.csdnimg.cn/direct/e74a04417e2d40dbb540010d130aeaf4.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/61a6cca783da4a9887a2a849fe667172.png" alt="在这里插入图片描述"><br>上图展示了请求与响应的抓包分析数据：当客户端向服务器请求加载登录页面时，服务器不仅会在响应体中返回HTML文件，还会在响应头中附带CORS配置信息供浏览器解析。<br><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/917300">CORS 详解，终于不用担心跨域问题了</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/03/LiteHub%E4%B9%8B%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AECORS/" data-id="cmcy7r5un0008ysvbg8ig599u" data-title="LiteHub之跨域访问CORS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="litehub/_posts-LiteHub之会话管理" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/26/LiteHub%E4%B9%8B%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-06-26T02:29:52.000Z" itemprop="datePublished">2025-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/26/LiteHub%E4%B9%8B%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/">LiteHub之会话管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="会话管理理论"><a href="#会话管理理论" class="headerlink" title="会话管理理论"></a>会话管理理论</h1><h2 id="为什么进行会话管理"><a href="#为什么进行会话管理" class="headerlink" title="为什么进行会话管理"></a>为什么进行会话管理</h2><h3 id="HTTP协议的特性与局限性"><a href="#HTTP协议的特性与局限性" class="headerlink" title="HTTP协议的特性与局限性"></a>HTTP协议的特性与局限性</h3><p>Web应用程序的基础是HTTP（Hypertext Transfer Protocol）协议，该协议在设计时具有以下核心特点：</p>
<ol>
<li><p><strong>请求&#x2F;响应模式</strong>：</p>
<ul>
<li>每次HTTP交互都遵循”客户端发起请求→服务器返回响应”的固定模式</li>
<li>例如：用户访问电商网站时，点击商品页、加入购物车、结算等都是独立的请求</li>
<li>各请求之间没有内在关联，服务器无法自动识别这些请求是否来自同一用户</li>
</ul>
</li>
<li><p><strong>无状态性（Stateless）</strong>：</p>
<ul>
<li>协议本身不保存任何历史交互信息</li>
<li>每个请求都被视为全新的交互，服务器不会”记住”之前的请求</li>
<li>实际案例：刷新网页后，登录状态、表单填写内容等都将丢失</li>
</ul>
</li>
<li><p><strong>无连接特性</strong>：</p>
<ul>
<li>每次TCP连接只处理一个请求&#x2F;响应</li>
<li>请求完成后立即断开连接以节省资源</li>
<li>导致的问题：无法维持长期对话，如在线聊天、多步骤表单等场景难以实现</li>
</ul>
</li>
</ol>
<h3 id="现实应用的需求矛盾"><a href="#现实应用的需求矛盾" class="headerlink" title="现实应用的需求矛盾"></a>现实应用的需求矛盾</h3><p>虽然HTTP的这些特性使其简单高效，但现代Web应用需要：</p>
<ul>
<li>用户登录状态保持（如保持7天免登录）</li>
<li>购物车商品跨页面保存</li>
<li>多步骤表单数据暂存</li>
<li>个性化内容推荐（基于历史浏览）</li>
</ul>
<p>因此需要引入<strong>会话管理机制</strong>来：</p>
<ol>
<li>识别同一用户的连续请求</li>
<li>在服务器端存储用户特定数据</li>
<li>维持应用的状态连续性</li>
</ol>
<p>常见解决方案包括：</p>
<ul>
<li>Cookie技术</li>
<li>Session会话</li>
<li>Token令牌（如JWT）</li>
<li>URL重写技术</li>
</ul>
<p>在这个项目中，我们使用的就是Session会话和Cookie技术结合使用来记录用户登录状态。</p>
<h2 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h2><ul>
<li>服务器为每个用户浏览器创建一个会话对象（session对象），一个浏览器只能产生一个session</li>
<li>当新建一个窗口访问服务器时，还是原来的那个session。session中默认保存的是当前用户的信息。因此，在需要保存其他用户数据时，我们可以自己给session添加属性。</li>
<li>session（会话）可以看为是一种标识，通过带session的请求，可以让服务器知道是谁在请求数据。</li>
</ul>
<h2 id="Session与cookie的区别与联系"><a href="#Session与cookie的区别与联系" class="headerlink" title="Session与cookie的区别与联系"></a>Session与cookie的区别与联系</h2><ul>
<li>session是由服务器创建的，并保存在服务器上的。在session创建好之后，会把sessionId（会话的唯一标识符）放在cookie中返回（response）给客户端。客户端将cookie是保存在客户端的。</li>
<li>以后的每次请求都携带cookie，cookie中的内容是sessionId值。</li>
<li>session的过期和超时与cookie的过期无直接联系，都是可以分别进行设置的。当session或cookie中任意一方过期，那么用户就需要重新登录了</li>
</ul>
<p>注意：虽然 Cookie 是最主流的方式，但如果用户禁用 Cookie，服务器还可以通过其他方式传递 Session ID：<br><strong>URL 重写</strong>： 将 Session ID 作为查询参数附加到每个 URL 后面 (如 ?sessionid&#x3D;abc123xyz)。这种方式不太安全（容易泄露）且不美观。<br><strong>隐藏表单域</strong>： 将 Session ID 放在 HTML 表单的隐藏字段中。仅适用于表单提交。</p>
<p>所以sessionid和cookie的更准确描述是：Session 机制通常利用 Cookie 用于在客户端存储和传递标识服务器端 Session 数据的 Session ID。Cookie 是 Session ID 的载体，而非 Session 生成了 Cookie。 服务器端的 Session 管理代码负责生成 Session ID 并指示浏览器（通过 Set-Cookie）存储它。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44627608/article/details/106277191">第六章 会话管理（Session）</a></p>
<h1 id="会话管理代码实现"><a href="#会话管理代码实现" class="headerlink" title="会话管理代码实现"></a>会话管理代码实现</h1><p>会话管理中共实现了四个类实现：</p>
<ul>
<li>Session(会话)：表示一个会话。</li>
<li>SessionManager(会话管理器)：用于管理多个会话的声明周期。</li>
<li>SessionStorage(会话存储)：会话存储实现的抽象类。</li>
<li>MemorySessionStorage(内存会话存储)：继承SessionStorage，具体的会话存储实现类。</li>
</ul>
<h2 id="Session类实现"><a href="#Session类实现" class="headerlink" title="Session类实现"></a>Session类实现</h2><ul>
<li>Session 构造函数，用于初始化会话实例，记录 sessionId、设置最长有效时间（默认值为 1 小时）并关联会话管理器。</li>
<li>isExpired（），判断当前会话是否过期</li>
<li>refresh（），刷新过期时间，当前时间加上最长有效时间（默认为一小时）</li>
<li>setValue（），以键值对形式存储会话数据</li>
<li>getValue（），根据传入key获取相应的会话数据（value）</li>
<li>remove(),根据传入key删除相应的会话数据（value）</li>
<li>clear()，清空所有会话数据</li>
</ul>
<p> 总结，session类实现了记录会话唯一标识符，维持会话过期时间，更新会话数据功能。</p>
<h2 id="SessionManager类实现"><a href="#SessionManager类实现" class="headerlink" title="SessionManager类实现"></a>SessionManager类实现</h2><ul>
<li>SessionManager 构造函数，用于配置会话存储对象（负责会话存储）和随机数生成器（用于生成随机的会话ID）</li>
<li>getSession（）函数会从请求中提取cookie字段以获取sessionid，并返回相应的会话；若cookie不存在或者会话已过期，则创建一个新会话。</li>
<li>generateSessionId（），生成一个唯一的会话标识符</li>
<li>destroySession（），从存储中移除会话</li>
<li>getSessionIdFromCookie（），从请求中的cookie字段获取sessionId</li>
<li>setSessionCookie（），在响应中设置cookie</li>
</ul>
<p>这几个函数比较重要，放这里注释一下，便于理解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从req请求中解析出sessionId</span></span><br><span class="line"><span class="function">std::string <span class="title">SessionManager::getSessionIdFromCookie</span><span class="params">(<span class="type">const</span> HttpRequest&amp; req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sessionId;</span><br><span class="line">    std::string cookie = req.<span class="built_in">getHeader</span>(<span class="string">&quot;Cookie&quot;</span>);<span class="comment">//找到Cookie字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cookie.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;	</span><br><span class="line">    	<span class="comment">//格式一般为</span></span><br><span class="line">    	<span class="comment">//Cookie: sessionId=1dd3ce798f86bf092595840ac8ecadc8\r\n</span></span><br><span class="line">        <span class="type">size_t</span> pos = cookie.<span class="built_in">find</span>(<span class="string">&quot;sessionId=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            pos += <span class="number">10</span>; <span class="comment">// 跳过&quot;sessionId=&quot;</span></span><br><span class="line">            <span class="type">size_t</span> end = cookie.<span class="built_in">find</span>(<span class="string">&#x27;;&#x27;</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (end != std::string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                sessionId = cookie.<span class="built_in">substr</span>(pos, end - pos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;	</span><br><span class="line">            	<span class="comment">//从pos开始截取到字符串结束</span></span><br><span class="line">                sessionId = cookie.<span class="built_in">substr</span>(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sessionId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成唯一的会话标识符，确保会话的唯一性和安全性</span></span><br><span class="line"><span class="function">std::string <span class="title">SessionManager::generateSessionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成32个字符的会话ID，每个字符是一个十六进制数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ss &lt;&lt; std::hex &lt;&lt; <span class="built_in">dist</span>(rng_);<span class="comment">//生成一个0~15之间的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在响应中添加cookie字段</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SessionManager::setSessionCookie</span><span class="params">(<span class="type">const</span> std::string&amp; sessionId, HttpResponse* resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置会话ID到响应头中，作为Cookie</span></span><br><span class="line">    std::string cookie = <span class="string">&quot;sessionId=&quot;</span> + sessionId + <span class="string">&quot;; Path=/; HttpOnly&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Set-Cookie&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Session&gt; <span class="title">SessionManager::getSession</span><span class="params">(<span class="type">const</span> HttpRequest&amp; req, HttpResponse* resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="comment">//从请求中的cookie字段中取出sessionid</span></span><br><span class="line">    std::string sessionId = <span class="built_in">getSessionIdFromCookie</span>(req);</span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;Session&gt; session;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (!sessionId.<span class="built_in">empty</span>())<span class="comment">//如果sessionId存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        session = storage_-&gt;<span class="built_in">load</span>(sessionId); <span class="comment">//根据sessionId获取对应会话</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!session || session-&gt;<span class="built_in">isExpired</span>())<span class="comment">//如果sesseion不存在或者说session过期，重新创建一个</span></span><br><span class="line">    &#123;</span><br><span class="line">        sessionId = <span class="built_in">generateSessionId</span>();<span class="comment">//生成唯一的sessionId</span></span><br><span class="line">        session = std::<span class="built_in">make_shared</span>&lt;Session&gt;(sessionId, <span class="keyword">this</span>);<span class="comment">//传入sessionid和SessionManager构建一个会话</span></span><br><span class="line">        <span class="built_in">setSessionCookie</span>(sessionId, resp);<span class="comment">//在响应resp中setCookie中添加sessionId</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        session-&gt;<span class="built_in">setManager</span>(<span class="keyword">this</span>); <span class="comment">// 为现有会话设置管理器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    session-&gt;<span class="built_in">refresh</span>();	<span class="comment">//刷新会话的过期时间，因为当前有新的访问，过期时间需要重新被设置</span></span><br><span class="line">    storage_-&gt;<span class="built_in">save</span>(session);  <span class="comment">// 保存会话</span></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MemorySessionStorage类实现"><a href="#MemorySessionStorage类实现" class="headerlink" title="MemorySessionStorage类实现"></a>MemorySessionStorage类实现</h2><p><code>SessionStorage</code>定义了抽象类提供了<code>save()</code>、<code>load()</code>、<code>remove()</code>接口，而<code>MemorySessionStorage</code>对重写了这些函数。<br><code>MemorySessionStorage</code>是以&lt;<code>std::string, std::shared_ptr&lt;Session&gt;</code>&gt;构造的无序键值对保存的。</p>
<ul>
<li>save()函数，保存会话</li>
<li>load()函数，根据sessionId找到对应的会话，如果会话过期则删除会话；否则返回会话</li>
<li>remove()函数，通过sessionId删除会话</li>
</ul>
<h1 id="会话管理抓包分析"><a href="#会话管理抓包分析" class="headerlink" title="会话管理抓包分析"></a>会话管理抓包分析</h1><h2 id="1-首次访问网页"><a href="#1-首次访问网页" class="headerlink" title="1.首次访问网页"></a>1.首次访问网页</h2><p>此时还没登录（此时还不需要维护用户的登录状态），这时的请求中还没有<code>cookie</code>字段。<br><img src="https://i-blog.csdnimg.cn/direct/08f8daca559f40ee8c83dd666ec080b5.png" alt="在这里插入图片描述"><br>这是发起的请求是为了请求网页，<br><img src="https://i-blog.csdnimg.cn/direct/71bba484dc7d4a6d98c6fb723fd6218b.png" alt="在这里插入图片描述"><br>服务器返回的响应，可以看到，此时服务器也没有set-cookie字段；此时服务器返回前端渲染需要的网页（响应体中）<br><img src="https://i-blog.csdnimg.cn/direct/550ea7ce108843f08c513b47d9b4c3a2.png" alt="在这里插入图片描述"></p>
<h2 id="2-点击登录时"><a href="#2-点击登录时" class="headerlink" title="2.点击登录时"></a>2.点击登录时</h2><p><img src="https://i-blog.csdnimg.cn/direct/f6ef959b27ab4bbb8050a51b39312a21.png" alt="在这里插入图片描述"><br>这时可以看到请求的报文，是以POST方式将用户登录的<code>username</code>和<code>password</code>上传到服务器（这里是明文传输，这是HTTP的缺点，在网络传输中容易被抓包导致密码和账户泄露；后面这个项目看能不能扩展成HTTPS协议）<br><img src="https://i-blog.csdnimg.cn/direct/ac11c9437eb945ce8d031d021ad06438.png" alt="在这里插入图片描述"></p>
<h2 id="3-服务器处理"><a href="#3-服务器处理" class="headerlink" title="3.服务器处理"></a>3.服务器处理</h2><p>此时通过点击登录按钮，将登录请求发送到服务器，服务器根据相应的路由，转发到专门用于登录处理的函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据账号密码，查找数据库是否有该账号密码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LoginHandler::queryUserId</span><span class="params">(<span class="type">const</span> std::string &amp;username, <span class="type">const</span> std::string &amp;password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 前端用户传来账号密码，查找数据库是否有该账号密码</span></span><br><span class="line">    <span class="comment">// 使用预处理语句, 防止sql注入</span></span><br><span class="line">    std::string sql = <span class="string">&quot;SELECT id FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line">    sql::ResultSet* res = mysqlUtil_.<span class="built_in">executeQuery</span>(sql, username, password);</span><br><span class="line">    <span class="keyword">if</span> (res-&gt;<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = res-&gt;<span class="built_in">getInt</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果查询结果为空，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoginHandler::handle</span><span class="params">(<span class="type">const</span> http::HttpRequest &amp;req, http::HttpResponse *resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 解析使用 try catch 捕获异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        json parsed = json::<span class="built_in">parse</span>(req.<span class="built_in">getBody</span>());</span><br><span class="line">        std::string username = parsed[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">        std::string password = parsed[<span class="string">&quot;password&quot;</span>]; <span class="comment">//从请求体中解析得到username 和password </span></span><br><span class="line">        <span class="comment">// 验证用户是否存在，是否注册过</span></span><br><span class="line">        <span class="type">int</span> userId = <span class="built_in">queryUserId</span>(username, password);</span><br><span class="line">        <span class="keyword">if</span> (userId != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取会话</span></span><br><span class="line">            <span class="keyword">auto</span> session = server_-&gt;<span class="built_in">getSessionManager</span>()-&gt;<span class="built_in">getSession</span>(req, resp);</span><br><span class="line">                     </span><br><span class="line">            <span class="comment">// 在会话中存储用户信息</span></span><br><span class="line">            session-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;userId&quot;</span>, std::<span class="built_in">to_string</span>(userId));</span><br><span class="line">            session-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">            session-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;isLoggedIn&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 账号密码错误，请重新登录</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 封装json数据，返回401未认证状态码</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">       	<span class="comment">//...其他代码，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的 server_-&gt;getSessionManager()-&gt;getSession(req, resp)负责返回会话，或者新建会话，具体为：</p>
<ol>
<li>如果当前用户存在会话并且会话有效，则直接返回会话</li>
<li>否则创建新的会话（这里是首次登录，所以默认就是这种情况）</li>
</ol>
<p> 并在会话中存储如<code>&quot;userId&quot;</code>，<code>&quot;username&quot;</code>，<code>&quot;isLoggedIn&quot;</code>字段。</p>
<h2 id="4-服务器返回响应"><a href="#4-服务器返回响应" class="headerlink" title="4.服务器返回响应"></a>4.服务器返回响应</h2><p>在getSession(req, resp)—&gt;&gt;&gt;setSessionCookie(sessionId, resp);设置响应报文</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SessionManager::setSessionCookie</span><span class="params">(<span class="type">const</span> std::string&amp; sessionId, HttpResponse* resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置会话ID到响应头中，作为Cookie</span></span><br><span class="line">    std::string cookie = <span class="string">&quot;sessionId=&quot;</span> + sessionId + <span class="string">&quot;; Path=/; HttpOnly&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Set-Cookie&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/direct/0ee73f6b2f5446bb8e45afc64683d174.png" alt="在这里插入图片描述"><br>服务器响应设置了cookie字段，以后的客户端的每次请求都将携带这个字段。</p>
<h2 id="5-客户端的下一次请求"><a href="#5-客户端的下一次请求" class="headerlink" title="5.客户端的下一次请求"></a>5.客户端的下一次请求</h2><p><img src="https://i-blog.csdnimg.cn/direct/c604bf7fb5cb42809931475c02591467.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/40fc672056244281a431b3f46fb052a4.png" alt="在这里插入图片描述"><br>从上图可知，设置cookie之后的每一次请求，都会带上cookie这个字段。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/26/LiteHub%E4%B9%8B%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/" data-id="cmcy7r5uj0004ysvbd5iz7g00" data-title="LiteHub之会话管理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="litehub/_posts-LiteHub之请求与响应报文分析" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/25/LiteHub%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2025-06-25T02:30:38.000Z" itemprop="datePublished">2025-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/25/LiteHub%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/">LiteHub之请求与响应报文分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@<a href="LiteHub%E4%B9%8BHTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90">TOC</a></p>
<p>这一篇文章是基于项目LITEHUB分析的关于HTTP的请求和响应篇章，后续将仔细分析这个项目所涉及到的知识点。<br><img src="https://i-blog.csdnimg.cn/direct/49c726370aa54794af9a8023297f7a72.png" alt="在这里插入图片描述"><br>上图是使用wireshark抓包分析的HTTP刷新网页的请求以及返回的响应报文格式。接下来我们就详细分析：</p>
<h1 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h1><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>请求报文主要由请求行、请求头、空行、请求头构成。<br>  <img src="https://i-blog.csdnimg.cn/direct/29d71662fbe745d689994e83ac0a9858.png" alt="在这里插入图片描述"><br>请求行包括一下字段：常见的方法包括GET（请求信息）、POST（提交数据，表单）方法等，资源路径（请求资源的URI路径）、HTTP的版本（HTTP1.1&#x2F;HTTP2.0）<br>请求头的字段较多，常使用的包含以下几个：<br>● Host：请求的服务器的域名。<br>● Accept：客户端能够处理的媒体类型。<br>● Accept-Encoding：客户端能够解码的内容编码。<br>● Authorization：用于认证的凭证信息，比如token数据。<br>● Content-Length：请求体的长度。<br>● Content-Type：请求体的媒体类型。<br>● Cookie：存储在客户端的cookie数据，在我的项目中，也是通过存在cookie字段来区别不同用户。</p>
<p>空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。<br>而请求体通常用于 POST 和 PUT 请求，包含发送给服务器的数据。</p>
<h2 id="wireshark抓包分析"><a href="#wireshark抓包分析" class="headerlink" title="wireshark抓包分析"></a>wireshark抓包分析</h2><p><img src="https://i-blog.csdnimg.cn/direct/54936fec86004e329ee8fb88432d460b.png" alt="在这里插入图片描述"></p>
<ul>
<li>请求行：这里使用请求方法为<code>GET</code>,请求的路径为<code>/resource/list</code>（服务器通过路由转发确定其实际请求的路径资源，后面会分析），并且使用的版本号是<code>HTTP/1.1</code>.</li>
<li>请求头：是以一系列的键值对组成的。如上图包括<code>Host:192.168.83.128</code>(表示请求的服务器的域名，这个字段是为了区分在一个服务器上存在多个地址的问题，如百度和edge都在一台服务器的不同网卡上服务，通过这个字段可以区分)；<code>Cookie: sessionId=ef4130be9ef3c2b7264455b2a201a1b1</code>（保持访问的一个状态），其余字段感兴趣的话可以自己去了解</li>
<li>空行： <code>\r\n</code>，用于分割请求头和请求体；</li>
<li>请求体：这里为空；</li>
</ul>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>上面我们已经分析了请求体的格式，接下来我们就根据格式，通过代码解析请求报文。</p>
<p>在<code>HttpContext.h</code>中定义解析的状态，只有当前状态成功解析完成后，才可以转到下一个状态；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpRequestParseState</span></span><br><span class="line">&#123;</span><br><span class="line">    kExpectRequestLine, <span class="comment">// 解析请求行</span></span><br><span class="line">    kExpectHeaders, <span class="comment">// 解析请求头</span></span><br><span class="line">    kExpectBody, <span class="comment">// 解析请求体</span></span><br><span class="line">    kGotAll, <span class="comment">// 解析完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>HttpContext.c</code>中定义两个标志，用于标志每个状态解析是否出错以及是否解析完成（如果请求体有值，就需要解析到请求体；如果请求体为空，则解析到空行就行）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> ok = <span class="literal">true</span>; <span class="comment">// 解析每行请求格式是否正确</span></span><br><span class="line"><span class="type">bool</span> hasMore = <span class="literal">true</span>; <span class="comment">//是否还需要解析</span></span><br></pre></td></tr></table></figure>

<h3 id="1-请求行解析"><a href="#1-请求行解析" class="headerlink" title="1.请求行解析"></a>1.请求行解析</h3><p>当前的请求行是这样：<code>GET /resource/list HTTP/1.1\r\n</code><br>请看代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (state_ == kExpectRequestLine)</span><br><span class="line">        &#123;   </span><br><span class="line">        	<span class="comment">//找到\r\n</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *crlf = buf-&gt;<span class="built_in">findCRLF</span>(); <span class="comment">// 注意这个返回值边界可能有错</span></span><br><span class="line">            <span class="keyword">if</span> (crlf)</span><br><span class="line">            &#123;	</span><br><span class="line">            	<span class="comment">//(buf-&gt;peek(), crlf)区间;其实就对应GET /resource/list HTTP/1.1</span></span><br><span class="line">                ok = <span class="built_in">processRequestLine</span>(buf-&gt;<span class="built_in">peek</span>(), crlf);</span><br><span class="line">                <span class="keyword">if</span> (ok)</span><br><span class="line">                &#123;</span><br><span class="line">                    request_.<span class="built_in">setReceiveTime</span>(receiveTime);</span><br><span class="line">                    <span class="comment">//向后移动两个字符，跳过\r\n</span></span><br><span class="line">                    buf-&gt;<span class="built_in">retrieveUntil</span>(crlf + <span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//并设置状态为kExpectHeaders，用于解析请求头</span></span><br><span class="line">                    state_ = kExpectHeaders;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;	</span><br><span class="line">                	<span class="comment">//如果解析出错，停止解析</span></span><br><span class="line">                    hasMore = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;	</span><br><span class="line">            	<span class="comment">//如果请求行没有找到\r\n，说明请求行格式错误，停止解析</span></span><br><span class="line">                hasMore = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义专门用来解析请求行的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpContext::processRequestLine</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *begin, <span class="type">const</span> <span class="type">char</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> succeed = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *start = begin;</span><br><span class="line">    <span class="comment">//以这个为例，GET /resource/list HTTP/1.1</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *space = std::<span class="built_in">find</span>(start, end, <span class="string">&#x27; &#x27;</span>);<span class="comment">//找到第一个空格</span></span><br><span class="line">    <span class="keyword">if</span> (space != end &amp;&amp; request_.<span class="built_in">setMethod</span>(start, space))<span class="comment">//将GET截取出来并存储到request_的请求方法字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        start = space + <span class="number">1</span>;</span><br><span class="line">        space = std::<span class="built_in">find</span>(start, end, <span class="string">&#x27; &#x27;</span>);<span class="comment">//继续找下一个空格</span></span><br><span class="line">        <span class="keyword">if</span> (space != end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *argumentStart = std::<span class="built_in">find</span>(start, space, <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (argumentStart != space) <span class="comment">// 请求带参数</span></span><br><span class="line">            &#123;	</span><br><span class="line">            	<span class="comment">//GET /search?q=example HTTP/1.1,类似这种会被解析为路径和对应参数</span></span><br><span class="line">                request_.<span class="built_in">setPath</span>(start, argumentStart); <span class="comment">// 注意这些返回值边界</span></span><br><span class="line">                request_.<span class="built_in">setQueryParameters</span>(argumentStart + <span class="number">1</span>, space);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 请求不带参数</span></span><br><span class="line">            &#123;	</span><br><span class="line">            	<span class="comment">//将/resource/list添加到请求路径中</span></span><br><span class="line">                request_.<span class="built_in">setPath</span>(start, space);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            start = space + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//&quot;HTTP/1.1&quot;或者&quot;HTTP/1.0&quot;都是8个字节</span></span><br><span class="line">            succeed = ((end - start == <span class="number">8</span>) &amp;&amp; std::<span class="built_in">equal</span>(start, end - <span class="number">1</span>, <span class="string">&quot;HTTP/1.&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (succeed)</span><br><span class="line">            &#123;	<span class="comment">//设置HTTP版本协议号</span></span><br><span class="line">                <span class="keyword">if</span> (*(end - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    request_.<span class="built_in">setVersion</span>(<span class="string">&quot;HTTP/1.1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (*(end - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    request_.<span class="built_in">setVersion</span>(<span class="string">&quot;HTTP/1.0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;	</span><br><span class="line">                    succeed = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> succeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是从问号后面分割参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::setQueryParameters</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *start, <span class="type">const</span> <span class="type">char</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">argumentStr</span><span class="params">(start, end)</span></span>;</span><br><span class="line">    std::string::size_type pos = <span class="number">0</span>;</span><br><span class="line">    std::string::size_type prev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按 &amp; 分割多个参数</span></span><br><span class="line">    <span class="keyword">while</span> ((pos = argumentStr.<span class="built_in">find</span>(<span class="string">&#x27;&amp;&#x27;</span>, prev)) != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string pair = argumentStr.<span class="built_in">substr</span>(prev, pos - prev);</span><br><span class="line">        std::string::size_type equalPos = pair.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (equalPos != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string key = pair.<span class="built_in">substr</span>(<span class="number">0</span>, equalPos);</span><br><span class="line">            std::string value = pair.<span class="built_in">substr</span>(equalPos + <span class="number">1</span>);</span><br><span class="line">            queryParameters_[key] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后一个参数</span></span><br><span class="line">    std::string lastPair = argumentStr.<span class="built_in">substr</span>(prev);</span><br><span class="line">    std::string::size_type equalPos = lastPair.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (equalPos != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string key = lastPair.<span class="built_in">substr</span>(<span class="number">0</span>, equalPos);</span><br><span class="line">        std::string value = lastPair.<span class="built_in">substr</span>(equalPos + <span class="number">1</span>);</span><br><span class="line">        queryParameters_[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据上述函数，我们就解析出来了请求行的三个字段，请求方法、url路径、以及Http的版本号。接下来就开始解析请求头了。</p>
<h3 id="2-请求头解析"><a href="#2-请求头解析" class="headerlink" title="2.请求头解析"></a>2.请求头解析</h3><p>根据上述分析，请求头是以键值对形式存储的（每一行存储一个键值对），并且键和值的分割是以“：”分割，基于这个分析，请求头就比较好解析了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (state_ == kExpectHeaders)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf)</span><br><span class="line">            &#123;	</span><br><span class="line">            	<span class="comment">//找到&#x27;:&#x27;</span></span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">char</span> *colon = std::find(buf-&gt;peek(), crlf, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (colon &lt; crlf)</span><br><span class="line">                &#123;	</span><br><span class="line">                    request_.addHeader(buf-&gt;peek(), colon, crlf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (buf-&gt;peek() == crlf)</span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">// 如果找到空行，则结束Header</span></span><br><span class="line">                    <span class="comment">// 根据请求方法和Content-Length判断是否需要继续读取body</span></span><br><span class="line">                    <span class="keyword">if</span> (request_.method() == HttpRequest::kPost || </span><br><span class="line">                        request_.method() == HttpRequest::kPut)</span><br><span class="line">                    &#123;	</span><br><span class="line">                        std::<span class="built_in">string</span> contentLength = request_.getHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (!contentLength.empty())</span><br><span class="line">                        &#123;</span><br><span class="line">                            request_.setContentLength(std::stoi(contentLength));</span><br><span class="line">                            <span class="keyword">if</span> (request_.contentLength() &gt; <span class="number">0</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                state_ = kExpectBody;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;	</span><br><span class="line">                            	<span class="comment">//如果不用解析请求体，则直接结束</span></span><br><span class="line">                                state_ = kGotAll;</span><br><span class="line">                                hasMore = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// POST/PUT 请求没有 Content-Length，是HTTP语法错误</span></span><br><span class="line">                            ok = <span class="literal">false</span>;</span><br><span class="line">                            hasMore = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// GET/HEAD/DELETE 等方法直接完成（没有请求体）</span></span><br><span class="line">                        state_ = kGotAll; </span><br><span class="line">                        hasMore = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ok = <span class="literal">false</span>; <span class="comment">// Header行格式错误</span></span><br><span class="line">                    hasMore = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//跳过\r\n</span></span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>); <span class="comment">// 开始读指针指向下一行数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hasMore = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HttpRequest::addHeader(<span class="keyword">const</span> <span class="built_in">char</span> *start, <span class="keyword">const</span> <span class="built_in">char</span> *colon, <span class="keyword">const</span> <span class="built_in">char</span> *end)</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">//&#x27;:&#x27;前的值作为key</span></span><br><span class="line">    std::<span class="function"><span class="built_in">string</span> <span class="title">key</span>(<span class="params">start, colon</span>)</span>;</span><br><span class="line">    ++colon;</span><br><span class="line">    <span class="keyword">while</span> (colon &lt; end &amp;&amp; isspace(*colon))</span><br><span class="line">    &#123;</span><br><span class="line">        ++colon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#x27;:&#x27;后的值作为value</span></span><br><span class="line">    std::<span class="function"><span class="built_in">string</span> <span class="title">value</span>(<span class="params">colon, end</span>)</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">value</span>.empty() &amp;&amp; isspace(<span class="keyword">value</span>[<span class="keyword">value</span>.size() - <span class="number">1</span>])) <span class="comment">// 消除尾部空格</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">value</span>.resize(<span class="keyword">value</span>.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储key-valua键值对</span></span><br><span class="line">    headers_[key] = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在找到空行后，需要根据请求方法(判断是否是POST或者PUT方法)和Content-Length判断是否需要继续读取body；如果不需要，则直接退出解析；如果请求体有数据，开始解析请求体。</p>
<h3 id="3-请求体的解析"><a href="#3-请求体的解析" class="headerlink" title="3.请求体的解析"></a>3.请求体的解析</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state_ == kExpectBody)</span><br><span class="line">        &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 检查缓冲区中是否有足够的数据</span></span><br><span class="line">            <span class="keyword">if</span> (buf-&gt;readableBytes() &lt; request_.contentLength())</span><br><span class="line">            &#123;</span><br><span class="line">                hasMore = <span class="literal">false</span>; <span class="comment">// 数据不完整，等待更多数据</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> std::<span class="built_in">string</span> &amp;contentType = request_.getHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (contentType.find(<span class="string">&quot;multipart/form-data&quot;</span>) != std::<span class="built_in">string</span>::npos) <span class="comment">//multipart/form-data表示支持多种复制格式的数据上传，如txt文件，mp4,rar等；这也是实现各种数据格式上传文件的解析</span></span><br><span class="line">            &#123;</span><br><span class="line">               </span><br><span class="line">                ok=parseMultipartData(buf);</span><br><span class="line">                request_.set_parseMultipartData_state(ok);</span><br><span class="line">                LOG_INFO&lt;&lt;<span class="string">&quot;multipart/form-data解析&quot;</span>&lt;&lt;((ok)?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">                state_ = kGotAll;</span><br><span class="line">                hasMore = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">//如果只是普通的数据，直接根据contentLength读入到body中即可。</span></span><br><span class="line">                <span class="comment">// 只读取 Content-Length 指定的长度</span></span><br><span class="line">                std::<span class="function"><span class="built_in">string</span> <span class="title">body</span>(<span class="params">buf-&gt;peek(</span>), buf-&gt;<span class="title">peek</span>() + request_.<span class="title">contentLength</span>())</span>;</span><br><span class="line">                request_.setBody(body);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 准确移动读指针</span></span><br><span class="line">                buf-&gt;retrieve(request_.contentLength());</span><br><span class="line"></span><br><span class="line">                state_ = kGotAll;</span><br><span class="line">                hasMore = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> HttpContext::parseMultipartData(Buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 找到并跳过第一个 boundary（如 ------WebKitFormBoundaryxxxx）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>* crlf = buf-&gt;findCRLF();</span><br><span class="line">    <span class="keyword">if</span> (!crlf) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不完整</span></span><br><span class="line">    std::<span class="function"><span class="built_in">string</span> <span class="title">boundary</span>(<span class="params">buf-&gt;peek(</span>),crlf)</span>;</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;boundary:&quot;</span>&lt;&lt;boundary;</span><br><span class="line">    buf-&gt;retrieveUntil(crlf + <span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 2. 解析 Content-Disposition 行</span></span><br><span class="line">    crlf = buf-&gt;findCRLF();</span><br><span class="line">    <span class="keyword">if</span> (!crlf) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不完整</span></span><br><span class="line">    std::<span class="function"><span class="built_in">string</span> <span class="title">dispositionLine</span>(<span class="params">buf-&gt;peek(</span>), crlf)</span>;</span><br><span class="line">    buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">string</span> Content_Disposition;</span><br><span class="line">    std::<span class="built_in">string</span> name;</span><br><span class="line">    std::<span class="built_in">string</span> filename;</span><br><span class="line">     </span><br><span class="line">    size_t Content_Pos = dispositionLine.find(<span class="string">&quot;Content-Disposition:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Content_Pos != std::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        Content_Pos += <span class="number">20</span>;</span><br><span class="line">        size_t ContentEnd = dispositionLine.find(<span class="string">&#x27;&quot;&#x27;</span>, Content_Pos);</span><br><span class="line">        <span class="keyword">if</span> (ContentEnd != std::<span class="built_in">string</span>::npos)</span><br><span class="line">            Content_Disposition.assign(dispositionLine.data() + Content_Pos, ContentEnd - Content_Pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;Content_Disposition:&quot;</span>&lt;&lt;Content_Disposition;</span><br><span class="line">    size_t namePos = dispositionLine.find(<span class="string">&quot;name=\&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namePos != std::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        namePos += <span class="number">6</span>;</span><br><span class="line">        size_t nameEnd = dispositionLine.find(<span class="string">&#x27;&quot;&#x27;</span>, namePos);</span><br><span class="line">        <span class="keyword">if</span> (nameEnd != std::<span class="built_in">string</span>::npos)</span><br><span class="line">            name.assign(dispositionLine.data() + namePos, nameEnd - namePos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;name;</span><br><span class="line">    size_t filePos = dispositionLine.find(<span class="string">&quot;filename=\&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (filePos != std::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        filePos += <span class="number">10</span>;</span><br><span class="line">        size_t fileEnd = dispositionLine.find(<span class="string">&#x27;&quot;&#x27;</span>, filePos);</span><br><span class="line">        <span class="keyword">if</span> (fileEnd != std::<span class="built_in">string</span>::npos)</span><br><span class="line">            filename.assign(dispositionLine.data() + filePos, fileEnd - filePos);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;filename:&quot;</span>&lt;&lt;filename;</span><br><span class="line">     <span class="comment">// 3. 跳过 Content-Type 行</span></span><br><span class="line">    crlf = buf-&gt;findCRLF();</span><br><span class="line">    <span class="keyword">if</span> (!crlf) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 跳过空行（说明下一个就是正文）</span></span><br><span class="line">    crlf = buf-&gt;findCRLF();</span><br><span class="line">    <span class="keyword">if</span> (!crlf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 写入文件，直到遇到下一次 boundary</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>* fileStart = buf-&gt;peek(); <span class="comment">// 文件内容起点</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>* fileEnd = std::search(</span><br><span class="line">        fileStart, buf-&gt;peek()+ buf-&gt;readableBytes(),</span><br><span class="line">        boundary.c_str(), boundary.c_str() + boundary.size()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileEnd == buf-&gt;beginWrite()) &#123;</span><br><span class="line">    <span class="comment">// 未找到结束 boundary，暂时数据不足</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;开始创建文件咯&quot;</span>; </span><br><span class="line">    request_.set_filename(filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filename.find(<span class="string">&quot;.avi&quot;</span>)!= std::<span class="built_in">string</span>::npos ||filename.find(<span class="string">&quot;.mp4&quot;</span>)!= std::<span class="built_in">string</span>::npos||filename.find(<span class="string">&quot;.mkv&quot;</span>)!= std::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">FileUtil <span class="title">writer</span>(<span class="params"><span class="string">&quot;/root/uploads/videos/&quot;</span> + filename</span>)</span>;</span><br><span class="line">        writer.writeBinary(fileStart, fileEnd - fileStart);</span><br><span class="line">        LOG_INFO&lt;&lt;<span class="string">&quot;这是一个视频&quot;</span>&lt;&lt;filename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">FileUtil <span class="title">writer</span>(<span class="params"><span class="string">&quot;/root/uploads/&quot;</span> + filename</span>)</span>;</span><br><span class="line">        writer.writeBinary(fileStart, fileEnd - fileStart);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;创建完成&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 移动 buffer 指针，跳过文件数据和 boundary和\r\n</span></span><br><span class="line">    buf-&gt;retrieveUntil(fileEnd+<span class="number">2</span>); <span class="comment">// 跳过文件数据</span></span><br><span class="line">    <span class="comment">//这里移动了，但是貌似还剩下一点东西，我测试了并没有发现问题，就不管啦！！！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的抓包过程中没有文件上传的解析，这里我上传了一个txt文件，并抓包分析。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/6b502683b4b6436988f5ddc1b2a7af64.png" alt="在这里插入图片描述"><br>上图的红框部分就是我此次上传的txt文件的请求体部分的抓包。以下是分析：</p>
<ol>
<li>边界值：——WebKitFormBoundaryLkDgzlyaqa0LgduN（细心的同学看到了，在请求体中的最开始部分和结尾部分都是以这个值作为分界线的，而在这直接的就是具体的内容）</li>
<li>Content-Disposition: form-data; name&#x3D;”file”; filename&#x3D;”test.txt”；form-data表示是一个表单数据；name字段对应表单中的字段名；filename是客户端上传的一个原始文件名。这个字段是用于告知服务器如何处理这部分数据。</li>
<li>Content-Type: text&#x2F;plain\r\n\r\n。这个是声明这部分数据的媒体类型。（text&#x2F;plain表示内容是无格式的纯文本）<br><img src="https://i-blog.csdnimg.cn/direct/a0cc64898b4e4e03bddfd2d99992ea22.png" alt="在这里插入图片描述"><br>这部分就是实际的传输内容。<br>传输如视频或者压缩文件为01二进制流。所以对于上传不同媒体数据的思想是，通过Content-Disposition中的filename字段，获取原数据的文件名，保存为相应的文件类型，并将实际的内容放到对应的文件中。</li>
</ol>
<p>视频上传的抓包截图：<br><img src="https://i-blog.csdnimg.cn/direct/1313fde68bcd4e3a81d1965c957cf539.png" alt="在这里插入图片描述"></p>
<h1 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h1><h2 id="理论部分-1"><a href="#理论部分-1" class="headerlink" title="理论部分"></a>理论部分</h2><p><img src="https://i-blog.csdnimg.cn/direct/deb4587859e6471ab9b0383ef7d2d985.png" alt="在这里插入图片描述"><br>HTTP响应报文是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关的数据。一个标准的HTTP响应报文通常包含状态行、响应头、空行、响应体。<br>状态行包含HTTP版本、状态码和状态消息。例如：HTTP&#x2F;1.1 200 OK，404表示没有找到，429表示请求连接过多，我的羡慕中使用令牌桶进行限流的时候，如果某一时候请求连接过多，就返回429状态码<br>响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：<br>● Content-Type：指定响应主体的媒体类型。<br>● Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。<br>● Content-Length：指定响应主体的长度（字节数）。<br>● Expires: 响应的过期时间。<br>● ETag: 响应体的实体标签，用于缓存和条件请求。<br>● Last-Modified： 资源最后被修改的日期和时间。<br>● Location：在重定向时指定新的资源位置。<br>● Set-Cookie：在响应中设置Cookie。</p>
<p>空行（Empty Line）在响应头和响应体之间，表示响应头的结束。而响应体是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可能为空。</p>
<h2 id="wireshark抓包分析-1"><a href="#wireshark抓包分析-1" class="headerlink" title="wireshark抓包分析"></a>wireshark抓包分析</h2><p><img src="https://i-blog.csdnimg.cn/direct/3fde8e82358c45669324345c88902475.png" alt="在这里插入图片描述"></p>
<ol>
<li>状态行返回 HTTP&#x2F;1.1(协议版本)，200（状态码），ok(状态码对于的短语)</li>
<li>响应头部，也是以键值对形式保存值的。<code>Connection: Keep-Alive</code>（表示这是一个长连接，即可以在这个连接上多次请求与响应）；<code>Access-Control-Allow-Origin: *</code>（支持跨域访问源，这里的‘*’表示所有源都可访问）；<code>Content-Encoding: gzip</code>（表示使用了gzip编码）；Content-Length: 325（这个字段表示响应体的数据大小为325字节）；Content-Type: application&#x2F;json（表示响应体的格式为json）</li>
<li>响应体可以是多种格式，在这里是json格式，见下图<br><img src="https://i-blog.csdnimg.cn/direct/47ddc71bd9864f408025ab5973071fcb.png" alt="在这里插入图片描述"><br>这里的一个json文件中有3个值，filename,uploadtime,username；多个json文件构成了一个Array。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>响应字段是由浏览器解析的，这里我们不需要实现解析的部分。响应是由服务器生成并返回的，所以在这里需要实现HTTP响应报文的生成。<br>请看代码：</p>
<h3 id="1-设置状态行"><a href="#1-设置状态行" class="headerlink" title="1.设置状态行"></a>1.设置状态行</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HttpResponse::setStatusLine(<span class="keyword">const</span> std::<span class="built_in">string</span>&amp; version,</span><br><span class="line">                                 HttpStatusCode statusCode,</span><br><span class="line">                                 <span class="keyword">const</span> std::<span class="built_in">string</span>&amp; statusMessage)</span><br><span class="line">&#123;</span><br><span class="line">    httpVersion_ = version; <span class="comment">//设置HTTP的版本号</span></span><br><span class="line">    statusCode_ = statusCode;<span class="comment">//设置响应状态码</span></span><br><span class="line">    statusMessage_ = statusMessage;<span class="comment">//设置响应消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-生成响应体"><a href="#2-生成响应体" class="headerlink" title="2.生成响应体"></a>2.生成响应体</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HttpResponse::appendToBuffer(muduo::net::Buffer* outputBuf) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// HttpResponse封装的信息格式化输出</span></span><br><span class="line">    <span class="built_in">char</span> buf[<span class="number">32</span>]; </span><br><span class="line">    <span class="comment">// 为什么不把状态信息放入格式化字符串中，因为状态信息有长有短，不方便定义一个固定大小的内存存储</span></span><br><span class="line">    snprintf(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;%s %d &quot;</span>, httpVersion_.c_str(), statusCode_);</span><br><span class="line">    </span><br><span class="line">    outputBuf-&gt;append(buf);</span><br><span class="line">    outputBuf-&gt;append(statusMessage_);</span><br><span class="line">    outputBuf-&gt;append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//是否设置长连接</span></span><br><span class="line">    <span class="keyword">if</span> (closeConnection_) </span><br><span class="line">    &#123;</span><br><span class="line">        outputBuf-&gt;append(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        outputBuf-&gt;append(<span class="string">&quot;Connection: Keep-Alive\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> auto&amp; header : headers_)</span><br><span class="line">    &#123; <span class="comment">// 为什么这里不用格式化字符串？因为key和value的长度不定</span></span><br><span class="line">        outputBuf-&gt;append(header.first);</span><br><span class="line">        outputBuf-&gt;append(<span class="string">&quot;: &quot;</span>); </span><br><span class="line">        outputBuf-&gt;append(header.second);</span><br><span class="line">        outputBuf-&gt;append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    outputBuf-&gt;append(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">//添加空行</span></span><br><span class="line">    </span><br><span class="line">    outputBuf-&gt;append(body_); <span class="comment">//添加响应体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>格式化响应之后，通过网络发送响应消息，浏览器解析响应并渲染，一次HTTP请求就完成了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/25/LiteHub%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/" data-id="cmcy7r5ul0007ysvba1uz0vov" data-title="LiteHub之请求与响应报文分析" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="litehub/_posts-LiteHub之环境配置" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/28/LiteHub%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2025-05-28T06:13:21.000Z" itemprop="datePublished">2025-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/28/LiteHub%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">LiteHub之环境配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://github.com/qingyh6/HttpsWebServer.git">仓库地址</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WVjozZEpt/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=bf00238027d3802fdec7c73822b31dde">演示地址</a></p>
<h2 id="禁用自动更新"><a href="#禁用自动更新" class="headerlink" title="禁用自动更新"></a>禁用自动更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop apt-daily.timer</span><br><span class="line"><span class="built_in">sudo</span> systemctl stop apt-daily-upgrade.timer</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> apt-daily.timer</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> apt-daily-upgrade.timer</span><br></pre></td></tr></table></figure>
<h2 id="安装boost"><a href="#安装boost" class="headerlink" title="安装boost"></a>安装boost</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libbz2-dev</span><br><span class="line"><span class="built_in">sudo</span> apt-get install libicu-dev</span><br><span class="line">//下载地址</span><br><span class="line">https://sourceforge.net/projects/boost/files/boost/1.69.0/</span><br><span class="line">tar -xvf 压缩包</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./b2</span><br><span class="line"><span class="built_in">sudo</span> ./b2 --prefix=/usr/local/boost install</span><br><span class="line">//添加环境变量</span><br><span class="line">vim /etc/environment</span><br><span class="line"></span><br><span class="line">CPLUS_INCLUDE_PATH=/usr/local/boost/include</span><br><span class="line">LIBRARY_PATH=/usr/local/boost/lib</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014389734/article/details/88963578">Linux：编译安装boost 1.69库</a></p>
<h2 id="安装muduo库"><a href="#安装muduo库" class="headerlink" title="安装muduo库"></a>安装muduo库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install g++ cmake make libboost-dev</span><br><span class="line">//下载并解压文件</span><br><span class="line">./build.sh</span><br><span class="line">./build.sh install</span><br><span class="line"><span class="built_in">cd</span> ../build/</span><br><span class="line"><span class="built_in">cd</span> release-install-cpp11</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> include/</span><br><span class="line"><span class="built_in">mv</span> muduo/ /usr/include/</span><br><span class="line"><span class="built_in">cd</span> ../lib</span><br><span class="line"><span class="built_in">mv</span> * /usr/local/lib/</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_55882840/article/details/145346115">muduo网络库下载安装教程</a></p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wget https://downloads.mysql.com/archives/get/p/23/file/mysql-server_5.7.29-1ubuntu18.04_amd64.deb-bundle.tar</span><br><span class="line"><span class="built_in">sudo</span> tar -xvf mysql-server_5.7.29-1ubuntu18.04_amd64.deb-bundle.tar</span><br><span class="line">//更新依赖源</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line">//安装依赖包</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./libmysql*</span><br><span class="line"><span class="built_in">sudo</span> apt-get install libtinfo5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./mysql-community-client_5.7.29-1ubuntu18.04_amd64.deb</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./mysql-client_5.7.29-1ubuntu18.04_amd64.deb</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./mysql-community-server_5.7.29-1ubuntu18.04_amd64.deb </span><br><span class="line"><span class="built_in">sudo</span> apt-get install ./mysql-server_5.7.29-1ubuntu18.04_amd64.deb</span><br><span class="line"></span><br><span class="line">//连接数据库</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">//开启远程访问</span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> User,Host from user;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;root&#x27;</span> WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf </span><br><span class="line">将Bindaddres 从127.0.0.1 改为0.0.0.0</span><br><span class="line">systemctl restart mysql</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44842318/article/details/136200647">Ubuntu22部署MySQL5.7详细教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/93513aa6d71f">Ubuntu22部署MySQL5.7详细教程</a></p>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//安装nlohmann/json</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br><span class="line"><span class="built_in">sudo</span> apt install nlohmann-json3-dev</span><br><span class="line"></span><br><span class="line">//c++ mysql 库</span><br><span class="line"><span class="built_in">sudo</span> apt install libmysqlcppconn-dev</span><br><span class="line"></span><br><span class="line">//安装openssl开发库</span><br><span class="line"><span class="built_in">sudo</span> apt install libssl-dev</span><br><span class="line"></span><br><span class="line">//安装ffmpeg库</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ffmpeg</span><br><span class="line">ffmpeg -version</span><br><span class="line"></span><br><span class="line">//安装gzip</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gzip</span><br><span class="line">gzip --version</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt install zlib</span><br><span class="line"><span class="built_in">sudo</span> apt install zlib1g-dev</span><br></pre></td></tr></table></figure>
<h2 id="创建表操作"><a href="#创建表操作" class="headerlink" title="创建表操作"></a>创建表操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建web数据库</span><br><span class="line"><span class="keyword">create</span> database webdb;</span><br><span class="line">use webdb;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建用户表</span><br><span class="line"><span class="keyword">create table</span> users (</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> auto_increment,</span><br><span class="line">username <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not null</span>,</span><br><span class="line">password <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not null</span>,</span><br><span class="line"><span class="keyword">primary key</span>(id));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建文件信息表</span><br><span class="line"><span class="keyword">CREATE TABLE</span> fileinfo (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    filename <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    uploadtime DATETIME <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    duration <span class="type">FLOAT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    isvideo   TINYINT(<span class="number">1</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建评论表</span><br><span class="line"><span class="keyword">CREATE TABLE</span> comments (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  video_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  user_id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  parent_id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  content TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">  created_at DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> video_likes (</span><br><span class="line">    user_id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    video_name <span class="type">VARCHAR</span>(<span class="number">255</span>)  <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (user_id, video_name)</span><br><span class="line">)<span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> video_stats (</span><br><span class="line">    video_name <span class="type">VARCHAR</span>(<span class="number">255</span>)  <span class="keyword">NOT NULL</span>,</span><br><span class="line">    view_count <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    like_count <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (video_name)</span><br><span class="line">) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>或者直接设置整个数据库使用这个字符集</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE mydatabase <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
<p>共创建如下几个表<br><img src="https://i-blog.csdnimg.cn/direct/d695fdabfde14d0491be5af325344ea8.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/28/LiteHub%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" data-id="cmcy7r5uk0006ysvb4ndmh6kz" data-title="LiteHub之环境配置" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/07/10/LiteHub%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%B8%8E%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/">LiteHub之文件下载与视频播放.md</a>
          </li>
        
          <li>
            <a href="/2025/07/09/LiteHub%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">LiteHub之数据库连接池</a>
          </li>
        
          <li>
            <a href="/2025/07/05/LiteHub%E4%B9%8Bgzip%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/">LiteHub之gzip压缩算法</a>
          </li>
        
          <li>
            <a href="/2025/07/04/LiteHub%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0/">LiteHub之中间件限流实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>