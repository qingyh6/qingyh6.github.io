<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LiteHub之会话管理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="会话管理理论为什么进行会话管理HTTP协议的特性与局限性Web应用程序的基础是HTTP（Hypertext Transfer Protocol）协议，该协议在设计时具有以下核心特点：  请求&#x2F;响应模式：  每次HTTP交互都遵循”客户端发起请求→服务器返回响应”的固定模式 例如：用户访问电商网站时，点击商品页、加入购物车、结算等都是独立的请求 各请求之间没有内在关联，服务器无法自动识别这">
<meta property="og:type" content="article">
<meta property="og:title" content="LiteHub之会话管理">
<meta property="og:url" content="http://example.com/2025/06/26/LiteHub%E4%B9%8B%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="会话管理理论为什么进行会话管理HTTP协议的特性与局限性Web应用程序的基础是HTTP（Hypertext Transfer Protocol）协议，该协议在设计时具有以下核心特点：  请求&#x2F;响应模式：  每次HTTP交互都遵循”客户端发起请求→服务器返回响应”的固定模式 例如：用户访问电商网站时，点击商品页、加入购物车、结算等都是独立的请求 各请求之间没有内在关联，服务器无法自动识别这">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/08f8daca559f40ee8c83dd666ec080b5.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/71bba484dc7d4a6d98c6fb723fd6218b.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/550ea7ce108843f08c513b47d9b4c3a2.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/f6ef959b27ab4bbb8050a51b39312a21.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/ac11c9437eb945ce8d031d021ad06438.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/0ee73f6b2f5446bb8e45afc64683d174.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/c604bf7fb5cb42809931475c02591467.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/40fc672056244281a431b3f46fb052a4.png">
<meta property="article:published_time" content="2025-06-26T02:29:52.000Z">
<meta property="article:modified_time" content="2025-07-11T02:42:23.605Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/direct/08f8daca559f40ee8c83dd666ec080b5.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="litehub/_posts-LiteHub之会话管理" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/26/LiteHub%E4%B9%8B%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-06-26T02:29:52.000Z" itemprop="datePublished">2025-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      LiteHub之会话管理
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="会话管理理论"><a href="#会话管理理论" class="headerlink" title="会话管理理论"></a>会话管理理论</h1><h2 id="为什么进行会话管理"><a href="#为什么进行会话管理" class="headerlink" title="为什么进行会话管理"></a>为什么进行会话管理</h2><h3 id="HTTP协议的特性与局限性"><a href="#HTTP协议的特性与局限性" class="headerlink" title="HTTP协议的特性与局限性"></a>HTTP协议的特性与局限性</h3><p>Web应用程序的基础是HTTP（Hypertext Transfer Protocol）协议，该协议在设计时具有以下核心特点：</p>
<ol>
<li><p><strong>请求&#x2F;响应模式</strong>：</p>
<ul>
<li>每次HTTP交互都遵循”客户端发起请求→服务器返回响应”的固定模式</li>
<li>例如：用户访问电商网站时，点击商品页、加入购物车、结算等都是独立的请求</li>
<li>各请求之间没有内在关联，服务器无法自动识别这些请求是否来自同一用户</li>
</ul>
</li>
<li><p><strong>无状态性（Stateless）</strong>：</p>
<ul>
<li>协议本身不保存任何历史交互信息</li>
<li>每个请求都被视为全新的交互，服务器不会”记住”之前的请求</li>
<li>实际案例：刷新网页后，登录状态、表单填写内容等都将丢失</li>
</ul>
</li>
<li><p><strong>无连接特性</strong>：</p>
<ul>
<li>每次TCP连接只处理一个请求&#x2F;响应</li>
<li>请求完成后立即断开连接以节省资源</li>
<li>导致的问题：无法维持长期对话，如在线聊天、多步骤表单等场景难以实现</li>
</ul>
</li>
</ol>
<h3 id="现实应用的需求矛盾"><a href="#现实应用的需求矛盾" class="headerlink" title="现实应用的需求矛盾"></a>现实应用的需求矛盾</h3><p>虽然HTTP的这些特性使其简单高效，但现代Web应用需要：</p>
<ul>
<li>用户登录状态保持（如保持7天免登录）</li>
<li>购物车商品跨页面保存</li>
<li>多步骤表单数据暂存</li>
<li>个性化内容推荐（基于历史浏览）</li>
</ul>
<p>因此需要引入<strong>会话管理机制</strong>来：</p>
<ol>
<li>识别同一用户的连续请求</li>
<li>在服务器端存储用户特定数据</li>
<li>维持应用的状态连续性</li>
</ol>
<p>常见解决方案包括：</p>
<ul>
<li>Cookie技术</li>
<li>Session会话</li>
<li>Token令牌（如JWT）</li>
<li>URL重写技术</li>
</ul>
<p>在这个项目中，我们使用的就是Session会话和Cookie技术结合使用来记录用户登录状态。</p>
<h2 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h2><ul>
<li>服务器为每个用户浏览器创建一个会话对象（session对象），一个浏览器只能产生一个session</li>
<li>当新建一个窗口访问服务器时，还是原来的那个session。session中默认保存的是当前用户的信息。因此，在需要保存其他用户数据时，我们可以自己给session添加属性。</li>
<li>session（会话）可以看为是一种标识，通过带session的请求，可以让服务器知道是谁在请求数据。</li>
</ul>
<h2 id="Session与cookie的区别与联系"><a href="#Session与cookie的区别与联系" class="headerlink" title="Session与cookie的区别与联系"></a>Session与cookie的区别与联系</h2><ul>
<li>session是由服务器创建的，并保存在服务器上的。在session创建好之后，会把sessionId（会话的唯一标识符）放在cookie中返回（response）给客户端。客户端将cookie是保存在客户端的。</li>
<li>以后的每次请求都携带cookie，cookie中的内容是sessionId值。</li>
<li>session的过期和超时与cookie的过期无直接联系，都是可以分别进行设置的。当session或cookie中任意一方过期，那么用户就需要重新登录了</li>
</ul>
<p>注意：虽然 Cookie 是最主流的方式，但如果用户禁用 Cookie，服务器还可以通过其他方式传递 Session ID：<br><strong>URL 重写</strong>： 将 Session ID 作为查询参数附加到每个 URL 后面 (如 ?sessionid&#x3D;abc123xyz)。这种方式不太安全（容易泄露）且不美观。<br><strong>隐藏表单域</strong>： 将 Session ID 放在 HTML 表单的隐藏字段中。仅适用于表单提交。</p>
<p>所以sessionid和cookie的更准确描述是：Session 机制通常利用 Cookie 用于在客户端存储和传递标识服务器端 Session 数据的 Session ID。Cookie 是 Session ID 的载体，而非 Session 生成了 Cookie。 服务器端的 Session 管理代码负责生成 Session ID 并指示浏览器（通过 Set-Cookie）存储它。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44627608/article/details/106277191">第六章 会话管理（Session）</a></p>
<h1 id="会话管理代码实现"><a href="#会话管理代码实现" class="headerlink" title="会话管理代码实现"></a>会话管理代码实现</h1><p>会话管理中共实现了四个类实现：</p>
<ul>
<li>Session(会话)：表示一个会话。</li>
<li>SessionManager(会话管理器)：用于管理多个会话的声明周期。</li>
<li>SessionStorage(会话存储)：会话存储实现的抽象类。</li>
<li>MemorySessionStorage(内存会话存储)：继承SessionStorage，具体的会话存储实现类。</li>
</ul>
<h2 id="Session类实现"><a href="#Session类实现" class="headerlink" title="Session类实现"></a>Session类实现</h2><ul>
<li>Session 构造函数，用于初始化会话实例，记录 sessionId、设置最长有效时间（默认值为 1 小时）并关联会话管理器。</li>
<li>isExpired（），判断当前会话是否过期</li>
<li>refresh（），刷新过期时间，当前时间加上最长有效时间（默认为一小时）</li>
<li>setValue（），以键值对形式存储会话数据</li>
<li>getValue（），根据传入key获取相应的会话数据（value）</li>
<li>remove(),根据传入key删除相应的会话数据（value）</li>
<li>clear()，清空所有会话数据</li>
</ul>
<p> 总结，session类实现了记录会话唯一标识符，维持会话过期时间，更新会话数据功能。</p>
<h2 id="SessionManager类实现"><a href="#SessionManager类实现" class="headerlink" title="SessionManager类实现"></a>SessionManager类实现</h2><ul>
<li>SessionManager 构造函数，用于配置会话存储对象（负责会话存储）和随机数生成器（用于生成随机的会话ID）</li>
<li>getSession（）函数会从请求中提取cookie字段以获取sessionid，并返回相应的会话；若cookie不存在或者会话已过期，则创建一个新会话。</li>
<li>generateSessionId（），生成一个唯一的会话标识符</li>
<li>destroySession（），从存储中移除会话</li>
<li>getSessionIdFromCookie（），从请求中的cookie字段获取sessionId</li>
<li>setSessionCookie（），在响应中设置cookie</li>
</ul>
<p>这几个函数比较重要，放这里注释一下，便于理解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从req请求中解析出sessionId</span></span><br><span class="line"><span class="function">std::string <span class="title">SessionManager::getSessionIdFromCookie</span><span class="params">(<span class="type">const</span> HttpRequest&amp; req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sessionId;</span><br><span class="line">    std::string cookie = req.<span class="built_in">getHeader</span>(<span class="string">&quot;Cookie&quot;</span>);<span class="comment">//找到Cookie字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cookie.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;	</span><br><span class="line">    	<span class="comment">//格式一般为</span></span><br><span class="line">    	<span class="comment">//Cookie: sessionId=1dd3ce798f86bf092595840ac8ecadc8\r\n</span></span><br><span class="line">        <span class="type">size_t</span> pos = cookie.<span class="built_in">find</span>(<span class="string">&quot;sessionId=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            pos += <span class="number">10</span>; <span class="comment">// 跳过&quot;sessionId=&quot;</span></span><br><span class="line">            <span class="type">size_t</span> end = cookie.<span class="built_in">find</span>(<span class="string">&#x27;;&#x27;</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (end != std::string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                sessionId = cookie.<span class="built_in">substr</span>(pos, end - pos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;	</span><br><span class="line">            	<span class="comment">//从pos开始截取到字符串结束</span></span><br><span class="line">                sessionId = cookie.<span class="built_in">substr</span>(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sessionId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成唯一的会话标识符，确保会话的唯一性和安全性</span></span><br><span class="line"><span class="function">std::string <span class="title">SessionManager::generateSessionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成32个字符的会话ID，每个字符是一个十六进制数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ss &lt;&lt; std::hex &lt;&lt; <span class="built_in">dist</span>(rng_);<span class="comment">//生成一个0~15之间的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在响应中添加cookie字段</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SessionManager::setSessionCookie</span><span class="params">(<span class="type">const</span> std::string&amp; sessionId, HttpResponse* resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置会话ID到响应头中，作为Cookie</span></span><br><span class="line">    std::string cookie = <span class="string">&quot;sessionId=&quot;</span> + sessionId + <span class="string">&quot;; Path=/; HttpOnly&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Set-Cookie&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Session&gt; <span class="title">SessionManager::getSession</span><span class="params">(<span class="type">const</span> HttpRequest&amp; req, HttpResponse* resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="comment">//从请求中的cookie字段中取出sessionid</span></span><br><span class="line">    std::string sessionId = <span class="built_in">getSessionIdFromCookie</span>(req);</span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;Session&gt; session;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (!sessionId.<span class="built_in">empty</span>())<span class="comment">//如果sessionId存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        session = storage_-&gt;<span class="built_in">load</span>(sessionId); <span class="comment">//根据sessionId获取对应会话</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!session || session-&gt;<span class="built_in">isExpired</span>())<span class="comment">//如果sesseion不存在或者说session过期，重新创建一个</span></span><br><span class="line">    &#123;</span><br><span class="line">        sessionId = <span class="built_in">generateSessionId</span>();<span class="comment">//生成唯一的sessionId</span></span><br><span class="line">        session = std::<span class="built_in">make_shared</span>&lt;Session&gt;(sessionId, <span class="keyword">this</span>);<span class="comment">//传入sessionid和SessionManager构建一个会话</span></span><br><span class="line">        <span class="built_in">setSessionCookie</span>(sessionId, resp);<span class="comment">//在响应resp中setCookie中添加sessionId</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        session-&gt;<span class="built_in">setManager</span>(<span class="keyword">this</span>); <span class="comment">// 为现有会话设置管理器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    session-&gt;<span class="built_in">refresh</span>();	<span class="comment">//刷新会话的过期时间，因为当前有新的访问，过期时间需要重新被设置</span></span><br><span class="line">    storage_-&gt;<span class="built_in">save</span>(session);  <span class="comment">// 保存会话</span></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MemorySessionStorage类实现"><a href="#MemorySessionStorage类实现" class="headerlink" title="MemorySessionStorage类实现"></a>MemorySessionStorage类实现</h2><p><code>SessionStorage</code>定义了抽象类提供了<code>save()</code>、<code>load()</code>、<code>remove()</code>接口，而<code>MemorySessionStorage</code>对重写了这些函数。<br><code>MemorySessionStorage</code>是以&lt;<code>std::string, std::shared_ptr&lt;Session&gt;</code>&gt;构造的无序键值对保存的。</p>
<ul>
<li>save()函数，保存会话</li>
<li>load()函数，根据sessionId找到对应的会话，如果会话过期则删除会话；否则返回会话</li>
<li>remove()函数，通过sessionId删除会话</li>
</ul>
<h1 id="会话管理抓包分析"><a href="#会话管理抓包分析" class="headerlink" title="会话管理抓包分析"></a>会话管理抓包分析</h1><h2 id="1-首次访问网页"><a href="#1-首次访问网页" class="headerlink" title="1.首次访问网页"></a>1.首次访问网页</h2><p>此时还没登录（此时还不需要维护用户的登录状态），这时的请求中还没有<code>cookie</code>字段。<br><img src="https://i-blog.csdnimg.cn/direct/08f8daca559f40ee8c83dd666ec080b5.png" alt="在这里插入图片描述"><br>这是发起的请求是为了请求网页，<br><img src="https://i-blog.csdnimg.cn/direct/71bba484dc7d4a6d98c6fb723fd6218b.png" alt="在这里插入图片描述"><br>服务器返回的响应，可以看到，此时服务器也没有set-cookie字段；此时服务器返回前端渲染需要的网页（响应体中）<br><img src="https://i-blog.csdnimg.cn/direct/550ea7ce108843f08c513b47d9b4c3a2.png" alt="在这里插入图片描述"></p>
<h2 id="2-点击登录时"><a href="#2-点击登录时" class="headerlink" title="2.点击登录时"></a>2.点击登录时</h2><p><img src="https://i-blog.csdnimg.cn/direct/f6ef959b27ab4bbb8050a51b39312a21.png" alt="在这里插入图片描述"><br>这时可以看到请求的报文，是以POST方式将用户登录的<code>username</code>和<code>password</code>上传到服务器（这里是明文传输，这是HTTP的缺点，在网络传输中容易被抓包导致密码和账户泄露；后面这个项目看能不能扩展成HTTPS协议）<br><img src="https://i-blog.csdnimg.cn/direct/ac11c9437eb945ce8d031d021ad06438.png" alt="在这里插入图片描述"></p>
<h2 id="3-服务器处理"><a href="#3-服务器处理" class="headerlink" title="3.服务器处理"></a>3.服务器处理</h2><p>此时通过点击登录按钮，将登录请求发送到服务器，服务器根据相应的路由，转发到专门用于登录处理的函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据账号密码，查找数据库是否有该账号密码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LoginHandler::queryUserId</span><span class="params">(<span class="type">const</span> std::string &amp;username, <span class="type">const</span> std::string &amp;password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 前端用户传来账号密码，查找数据库是否有该账号密码</span></span><br><span class="line">    <span class="comment">// 使用预处理语句, 防止sql注入</span></span><br><span class="line">    std::string sql = <span class="string">&quot;SELECT id FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line">    sql::ResultSet* res = mysqlUtil_.<span class="built_in">executeQuery</span>(sql, username, password);</span><br><span class="line">    <span class="keyword">if</span> (res-&gt;<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = res-&gt;<span class="built_in">getInt</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果查询结果为空，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoginHandler::handle</span><span class="params">(<span class="type">const</span> http::HttpRequest &amp;req, http::HttpResponse *resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 解析使用 try catch 捕获异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        json parsed = json::<span class="built_in">parse</span>(req.<span class="built_in">getBody</span>());</span><br><span class="line">        std::string username = parsed[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">        std::string password = parsed[<span class="string">&quot;password&quot;</span>]; <span class="comment">//从请求体中解析得到username 和password </span></span><br><span class="line">        <span class="comment">// 验证用户是否存在，是否注册过</span></span><br><span class="line">        <span class="type">int</span> userId = <span class="built_in">queryUserId</span>(username, password);</span><br><span class="line">        <span class="keyword">if</span> (userId != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取会话</span></span><br><span class="line">            <span class="keyword">auto</span> session = server_-&gt;<span class="built_in">getSessionManager</span>()-&gt;<span class="built_in">getSession</span>(req, resp);</span><br><span class="line">                     </span><br><span class="line">            <span class="comment">// 在会话中存储用户信息</span></span><br><span class="line">            session-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;userId&quot;</span>, std::<span class="built_in">to_string</span>(userId));</span><br><span class="line">            session-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">            session-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;isLoggedIn&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 账号密码错误，请重新登录</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 封装json数据，返回401未认证状态码</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">       	<span class="comment">//...其他代码，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的 server_-&gt;getSessionManager()-&gt;getSession(req, resp)负责返回会话，或者新建会话，具体为：</p>
<ol>
<li>如果当前用户存在会话并且会话有效，则直接返回会话</li>
<li>否则创建新的会话（这里是首次登录，所以默认就是这种情况）</li>
</ol>
<p> 并在会话中存储如<code>&quot;userId&quot;</code>，<code>&quot;username&quot;</code>，<code>&quot;isLoggedIn&quot;</code>字段。</p>
<h2 id="4-服务器返回响应"><a href="#4-服务器返回响应" class="headerlink" title="4.服务器返回响应"></a>4.服务器返回响应</h2><p>在getSession(req, resp)—&gt;&gt;&gt;setSessionCookie(sessionId, resp);设置响应报文</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SessionManager::setSessionCookie</span><span class="params">(<span class="type">const</span> std::string&amp; sessionId, HttpResponse* resp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置会话ID到响应头中，作为Cookie</span></span><br><span class="line">    std::string cookie = <span class="string">&quot;sessionId=&quot;</span> + sessionId + <span class="string">&quot;; Path=/; HttpOnly&quot;</span>;</span><br><span class="line">    resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Set-Cookie&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/direct/0ee73f6b2f5446bb8e45afc64683d174.png" alt="在这里插入图片描述"><br>服务器响应设置了cookie字段，以后的客户端的每次请求都将携带这个字段。</p>
<h2 id="5-客户端的下一次请求"><a href="#5-客户端的下一次请求" class="headerlink" title="5.客户端的下一次请求"></a>5.客户端的下一次请求</h2><p><img src="https://i-blog.csdnimg.cn/direct/c604bf7fb5cb42809931475c02591467.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/40fc672056244281a431b3f46fb052a4.png" alt="在这里插入图片描述"><br>从上图可知，设置cookie之后的每一次请求，都会带上cookie这个字段。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/26/LiteHub%E4%B9%8B%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/" data-id="cmcy7r5uj0004ysvbd5iz7g00" data-title="LiteHub之会话管理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/07/03/LiteHub%E4%B9%8B%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AECORS/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          LiteHub之跨域访问CORS
        
      </div>
    </a>
  
  
    <a href="/2025/06/25/LiteHub%E4%B9%8B%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">LiteHub之请求与响应报文分析</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/07/10/LiteHub%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%B8%8E%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/">LiteHub之文件下载与视频播放.md</a>
          </li>
        
          <li>
            <a href="/2025/07/09/LiteHub%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">LiteHub之数据库连接池</a>
          </li>
        
          <li>
            <a href="/2025/07/05/LiteHub%E4%B9%8Bgzip%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/">LiteHub之gzip压缩算法</a>
          </li>
        
          <li>
            <a href="/2025/07/04/LiteHub%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0/">LiteHub之中间件限流实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>