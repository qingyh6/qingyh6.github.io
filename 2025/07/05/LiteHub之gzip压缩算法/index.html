<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LiteHub之gzip压缩算法 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="@TOC 理论部分 gzip是一种无损压缩算法，其基础为Deflate，Deflate是LZ77与哈弗曼编码的一个组合体。它的基本原理是：对于要压缩的文件，首先使用LZ77算法的一个变种进行压缩，对得到的结果再使用哈夫曼编码（根据情况，使用静态哈弗曼编码或动态哈夫曼编码）的方法进行压缩。  LZ777算法几个术语  等待编码区 搜索缓冲区（已经编码的区域） 滑动窗口（指定大小，包括“搜索缓冲区”和">
<meta property="og:type" content="article">
<meta property="og:title" content="LiteHub之gzip压缩算法">
<meta property="og:url" content="http://example.com/2025/07/05/LiteHub%E4%B9%8Bgzip%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="@TOC 理论部分 gzip是一种无损压缩算法，其基础为Deflate，Deflate是LZ77与哈弗曼编码的一个组合体。它的基本原理是：对于要压缩的文件，首先使用LZ77算法的一个变种进行压缩，对得到的结果再使用哈夫曼编码（根据情况，使用静态哈弗曼编码或动态哈夫曼编码）的方法进行压缩。  LZ777算法几个术语  等待编码区 搜索缓冲区（已经编码的区域） 滑动窗口（指定大小，包括“搜索缓冲区”和">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/fec766beb7344418952a7b715d53c1ea.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/66beb0047e2b4dcc946eab5d59ab0559.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/9488cb0dd1ed4da19e59aa5f48a6253d.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/55978a3216824675b8365a88eade715c.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/9b87beeda7f94b32b341d27d9c89286e.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/3b80d2f91e264311a064a808f2b952ae.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/cbc0b2d8ccf74078ac743dd0dfead6e0.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/53ab09d1730c4a34a4e47c85840f2ed9.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/01844c8007ad426badcf683ae73e916f.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/dede28be630f4f83839cfd4b59dc07a8.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/direct/83851fc1911e4c46a9cd62699348187a.png">
<meta property="article:published_time" content="2025-07-05T02:28:46.000Z">
<meta property="article:modified_time" content="2025-07-11T02:43:55.320Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/direct/fec766beb7344418952a7b715d53c1ea.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="litehub/_posts-LiteHub之gzip压缩算法" class="h-entry article article-type-litehub/_posts" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/05/LiteHub%E4%B9%8Bgzip%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-07-05T02:28:46.000Z" itemprop="datePublished">2025-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      LiteHub之gzip压缩算法
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@<a href="gzip%E7%AE%97%E6%B3%95">TOC</a></p>
<h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><blockquote>
<p>gzip是一种无损压缩算法，其基础为Deflate，Deflate是LZ77与哈弗曼编码的一个组合体。它的基本原理是：对于要压缩的文件，首先使用LZ77算法的一个变种进行压缩，对得到的结果再使用哈夫曼编码（根据情况，使用静态哈弗曼编码或动态哈夫曼编码）的方法进行压缩。</p>
</blockquote>
<h3 id="LZ777算法"><a href="#LZ777算法" class="headerlink" title="LZ777算法"></a>LZ777算法</h3><p>几个术语</p>
<ul>
<li>等待编码区</li>
<li>搜索缓冲区（已经编码的区域）</li>
<li>滑动窗口（指定大小，包括“搜索缓冲区”和“待编码区”）</li>
</ul>
<p>具体的编码过程：<br>接下来，介绍具体的编码过程：<br>　　为了编码待编码区， 编码器在滑动窗口的搜索缓冲区查找直到找到匹配的字符串。匹配字符串的开始字符串与待编码缓冲区的距离称为“偏移值”，匹配字符串的长度称为“匹配长度”。<br>　　编码器在编码时，会一直在搜索区中搜索，直到找到最大匹配字符串，并输出(o, l )，其中o是偏移值， l是匹配长度。然后窗口滑动l，继续开始编码。<br>　　如果没有找到匹配字符串，则输出(0, 0, c)，c为待编码区下一个等待编码的字符，窗口滑动“1”。</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/junyuhuang/p/4138376.html">LZ77压缩算法编码原理详解(结合图片和简单代码)</a></p>
<p>下面我们以字符串“<code>abababc</code>”为例，来了解其编码过程：</p>
<p>假设滑动窗口的大小足够大(LZ777设置的滑动窗口是32k)，可以覆盖整个字符串。</p>
<p><strong>第一步</strong>：<br>	&emsp;待编码区：abababc<br>	&emsp;搜索缓冲区：（初始为空）<br>	&emsp;操作：搜索缓冲区为空，无法找到匹配字符串。<br>	&emsp;输出：(0, 0, a)（表示没有找到匹配，输出字符a）<br>	&emsp;窗口滑动：窗口向右滑动1个字符。<br>	&emsp;结果：a已经被编码，剩下bababc。<br><strong>第二步</strong>：<br>	&emsp;待编码区：bababc<br>	&emsp;搜索缓冲区：a（已经编码的部分）<br>	&emsp;操作：在搜索缓冲区中查找b的匹配。搜索缓冲区中没有b。<br>	&emsp;输出：(0, 0, b)（表示没有找到匹配，输出字符b）<br>	&emsp;窗口滑动：窗口向右滑动1个字符。<br>	&emsp;结果：ab已经被编码，剩下ababc。<br><strong>第三步</strong>：<br>	&emsp;待编码区：ababc<br>	&emsp;搜索缓冲区：ab（已经编码的部分）<br>	&emsp;操作：在搜索缓冲区中查找ab的匹配。搜索缓冲区中存在ab，匹配长度为2。<br>	&emsp;输出：(2, 2)（表示匹配长度为2，偏移值为2）<br>	&emsp;窗口滑动：窗口向右滑动2个字符。<br>	&emsp;结果：abab已经被编码，剩下abc。<br><strong>第四步</strong>：<br>	&emsp;待编码区：abc<br>	&emsp;搜索缓冲区：abab（已经编码的部分）<br>	&emsp;操作：在搜索缓冲区中查找ab的匹配。搜索缓冲区中存在ab，匹配长度为2。<br>	&emsp;输出：(4, 2)（表示匹配长度为2，偏移值为4）<br>	&emsp;窗口滑动：窗口向右滑动2个字符。<br>	&emsp;结果：ababab已经被编码，剩下c。<br><strong>第五步</strong>：<br>	&emsp;待编码区：c<br>	&emsp;搜索缓冲区：ababab（已经编码的部分）<br>	&emsp;操作：在搜索缓冲区中查找c的匹配。搜索缓冲区中没有c。<br>	&emsp;输出：(0, 0, c)（表示没有找到匹配，输出字符c）<br>	&emsp;窗口滑动：窗口向右滑动1个字符。<br>	&emsp;结果：整个字符串已经编码完成。</p>
<p><strong>最终编码结果</strong><br>&emsp;经过上述步骤，字符串abababc的LZ77编码结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">0</span>, a) (<span class="number">0</span>, <span class="number">0</span>, b) (<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>) (<span class="number">0</span>, <span class="number">0</span>, c)</span><br></pre></td></tr></table></figure>
<p>使用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/junyuhuang/p/4138376.html">LZ77压缩算法编码原理详解(结合图片和简单代码)</a>给定的代码的编码结果是<br><img src="https://i-blog.csdnimg.cn/direct/fec766beb7344418952a7b715d53c1ea.png" alt="在这里插入图片描述"><br>说明上述编码过程分析正确！！！</p>
<p>上面的如(0, 0, a)这个其实根本不用写偏移和匹配长度，保留为原字符‘a’，占的编码长度还更短一些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">0</span>, a) (<span class="number">0</span>, <span class="number">0</span>, b) (<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>) (<span class="number">0</span>, <span class="number">0</span>, c)</span><br></pre></td></tr></table></figure>
<p>变为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ab</span>(<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>)c</span><br></pre></td></tr></table></figure>
<h3 id="霍夫曼编码算法"><a href="#霍夫曼编码算法" class="headerlink" title="霍夫曼编码算法"></a>霍夫曼编码算法</h3><p>霍夫曼编码是一种基于字符频率的变长编码方法，通过构建霍夫曼树来为每个字符分配一个唯一的二进制编码。霍夫曼树的构建过程依赖于字符的频率，频率越高的字符通常会被分配较短的编码。<br>首先我们统计”<code>abababc</code>“中每一个字符出现的频率，如下所示</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>根据霍夫曼编码的规则，我们需要按照字符频率从低到高构建霍夫曼树。以下是构建过程：</p>
<ol>
<li>将字符串出现的频率视为优先级，放入一个最小优先队列中：</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/66beb0047e2b4dcc946eab5d59ab0559.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li>然后弹出两个优先级最低的字符作为子节点, 构造出第一个二叉树; 父节点的优先级视为两个字节优先级之和, 然后把父节点插入队列中:<br><img src="https://i-blog.csdnimg.cn/direct/9488cb0dd1ed4da19e59aa5f48a6253d.png" alt="在这里插入图片描述"></li>
<li>重复这个操作, 最后我们会得到一颗二叉树. 这便是 Huffman编码 树.</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/55978a3216824675b8365a88eade715c.png" alt="在这里插入图片描述"><br>4.  我们把这棵树的左支编码为 0, 右支编码为 1, 那么从根节点向下遍历到叶子节点, 即可得出相应字符的 Huffman 编码. 因此我们得到上面例子的 Huffman 编码表为:<br><img src="https://i-blog.csdnimg.cn/direct/9b87beeda7f94b32b341d27d9c89286e.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">01</span></span><br><span class="line">c:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>现在对字符串中出现的频率都做了一个统计，只需要解决偏移量和匹配长度的编码就可以了。</p>
<p> DEFLATE 算法对偏移距离和匹配长度已经做了一个统计，见下表：<br> <strong>偏移距离</strong>：<br> 它有 0 至 29 一共 30 个编码. 距离编码的含义如下表所示:<br> <img src="https://i-blog.csdnimg.cn/direct/3b80d2f91e264311a064a808f2b952ae.png" alt="在这里插入图片描述"></p>
<ul>
<li>code表示基本的编码表示，比如编码9对应的基准距离是25</li>
<li>extra表示距离基准距离偏移了多少，编码9对应的extra为3位，最大为111（7），即25+7，最大可以表示32。</li>
<li>distance，可以表示的距离范围<br><code>总结</code>：code+extra可以灵活表示distance的任何数字</li>
</ul>
<p> <strong>匹配长度</strong>：<br>对于长度, 它与普通字符共用同一编码空间. 这个编码空间一共有 286 个编码, 范围是从 0 至 285. 其中 0 至 255 为普通字符编码, 256 表示压缩块的结束; 而 257 至 285 则表示长度. 长度编码的含义如下表所示:<br><img src="https://i-blog.csdnimg.cn/direct/cbc0b2d8ccf74078ac743dd0dfead6e0.png" alt="在这里插入图片描述"></p>
<p>与距离编码类似, 每个编码都表示一个或多个长度, 表示多个长度时后面会有 extra 位指示具体的长度. 长度编码能表示的长度范围为 3 至 258.<br>注意：所以在 DEFLATE 中，长度 1<del>2 的重复<strong>不会用匹配项表示</strong>（直接把这 1</del>2 个字节原样输出（即用字面值编码）通常比引用匹配（还要额外编码长度和距离）更短！）；只有长度 ≥ 3 时才会用匹配项 (length, distance) 来引用重复块。<br>解压时, 当读到编码小于等于 255, 则认为这是个普通字符, 原样输出即可; 若在 257 至 285 之间, 则说明遇到了一个重复标记, 这意味着当前编码表示的是长度, 且下一个编码表示的是距离. 解码得到长度和距离, 再在解压缓冲区中找到相应的部分输出即可; 若为 256, 则说明压缩块结束了.</p>
<p>从LZ777编码到霍夫曼编码<br>上一步的LZ777编码结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ab</span>(<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>)c</span><br></pre></td></tr></table></figure>
<p>字符串统计频率为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">01</span></span><br><span class="line">c:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>字符编码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101</span>(<span class="number">2</span>, <span class="number">2</span>) (<span class="number">4</span>,<span class="number">2</span>)<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>然后对偏移距离和匹配长度进行编码<br>但是这里发现匹配字符长度是从3开始的，那么这个2怎么编码呢？原来这里的deflate算法是使用了改进型的LZ777算法<br>参考文章：<a target="_blank" rel="noopener" href="https://luyuhuang.tech/2020/04/28/gzip-and-deflate.html">Gzip 格式和 DEFLATE 压缩算法</a></p>
<h3 id="改进型的LZ777算法"><a href="#改进型的LZ777算法" class="headerlink" title="改进型的LZ777算法"></a>改进型的LZ777算法</h3><blockquote>
<p>LZ77压缩算法将所有数据都处理成为一个三元组串，每个三元组至少需要3个字节表示，如果在动态字典中未找到匹配字符串，会将1个字节输出为3个字节，这就导致了字节浪费。因此在DEFLATE算法中对其使用的LZ77算法进行了以下改进：</p>
<p>对匹配字符串长度小于3的字符串不压缩。因为长度小于3的字符串，使用三元组表示，对原始数据不能起到压缩的作用。<br>对字符串的匹配长度进行了限制，范围为（-128~127），用8bit表示，滑动窗口大小为32KB，用15bit表示，将压缩数据构造为标识+数据的形式，具体如表3所示。该存储方式，降低了压缩数据的存储空间。<br>由于只查找匹配长度大于3的字符串，为提高算法速度，在查找匹配字符串时，使用了哈希链结构搜索算法，其中哈希算法将3字节压缩到2字节，虽然哈希链结构存在搜索到错误结果的可能，但还是大幅提高了搜索速度。</p>
</blockquote>
<p>所以最终的编码结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">01</span></span><br><span class="line">c:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>这里的字符串“abababc”，连续匹配都没有超过三个字符，直接按照这个字符串常量进行编码即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10110110100</span></span><br></pre></td></tr></table></figure>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="压缩对象"><a href="#压缩对象" class="headerlink" title="压缩对象"></a>压缩对象</h3><p>在开始编写代码前，我们需要弄清楚，需要压缩的对象是什么？</p>
<ol>
<li>视频、音频、图片等文件本身就是压缩格式<br>mp4、jpg、png、avi、mp3 这些格 已经过复杂压缩算法处理（如 H.264、H.265、JPEG、LZ77 等）。<br>👉 所以再次使用 GZIP 压缩不会有太大效果，反而可能略微增加体积。</li>
<li>GZIP 对二进制内容的压缩效率很低<br>GZIP 是为文本内容设计的压缩算法（如 HTML、JSON、JavaScript 等）。<br>它依赖数据的可预测性和重复性（如文本中的重复词、空格等）来压缩。<br>视频文件的数据模式看起来是“随机的”，压缩器无法从中找到有效的模式。</li>
</ol>
<h3 id="gzip实现"><a href="#gzip实现" class="headerlink" title="gzip实现"></a>gzip实现</h3><p><code>GzipMiddleware.h</code>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">GzipMiddleware</span>():<span class="built_in">clientSupportGzip_</span>(<span class="literal">true</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">before</span><span class="params">(HttpRequest&amp; request)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">after</span><span class="params">(HttpResponse&amp; response)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setClientSupportGzip</span><span class="params">(<span class="type">bool</span> flag)</span></span>&#123;clientSupportGzip_=flag;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isClinetSupportGzip</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> clientSupportGzip_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getGzipEnableRate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">uint64_t</span> total = totalRequests_.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">return</span> total == <span class="number">0</span> ? <span class="number">0.0</span> : (<span class="type">double</span>)gzipAppliedCount_.<span class="built_in">load</span>() / total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getAverageCompressionRatio</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">uint64_t</span> original = originalSizeSum_.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">return</span> original == <span class="number">0</span> ? <span class="number">0.0</span> : (<span class="type">double</span>)compressedSizeSum_.<span class="built_in">load</span>() / original;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compressGzip</span><span class="params">(<span class="type">const</span> std::string&amp; input, std::string&amp; output)</span></span>;</span><br><span class="line">    <span class="type">bool</span> clientSupportGzip_;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// gzip统计信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkArchive</span><span class="params">()</span></span>;  <span class="comment">// 检查是否需要归档</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetStats</span><span class="params">()</span></span>;    <span class="comment">// 重置统计信息</span></span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; totalRequests_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; gzipAppliedCount_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; originalSizeSum_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; compressedSizeSum_&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::function&lt;void(uint64_t, uint64_t, uint64_t, uint64_t)&gt; archiveCallback_;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> MAX_REQUESTS_BEFORE_ARCHIVE = <span class="number">1e9</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> MAX_ORIGINAL_SIZE_BEFORE_ARCHIVE = <span class="number">1ULL</span> &lt;&lt; <span class="number">40</span>; <span class="comment">// 1 TB</span></span><br></pre></td></tr></table></figure>

<p><code>GzipMiddleware.cpp</code>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GzipMiddleware::before</span><span class="params">(HttpRequest&amp; request)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 从客户端请求头中获取 Accept-Encoding 字段</span></span><br><span class="line">    std::string acceptEncoding=request.<span class="built_in">getHeader</span>(<span class="string">&quot;Accept-Encoding&quot;</span>);</span><br><span class="line">     <span class="comment">// 判断是否包含 &quot;gzip&quot; 关键字</span></span><br><span class="line">    <span class="comment">// 如果包含，说明客户端支持 gzip 压缩</span></span><br><span class="line">    <span class="comment">// 否则，不支持 gzip 压缩，如果不支持，就不进行gzip压缩</span></span><br><span class="line">    acceptEncoding.<span class="built_in">find</span>(<span class="string">&quot;gzip&quot;</span>) != std::string::npos?<span class="built_in">setClientSupportGzip</span>(<span class="literal">true</span>):<span class="built_in">setClientSupportGzip</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">// GzipMiddleware::after</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GzipMiddleware::after</span><span class="params">(HttpResponse&amp; response)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 统计总请求数（用于后续压缩统计归档）</span></span><br><span class="line">    totalRequests_++;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isClinetSupportGzip</span>())     <span class="comment">// 如果客户端不支持 gzip，则直接跳过压缩</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否应该压缩，消息体大于256字节并且消息类型是文本、html等类型才可以</span></span><br><span class="line">    <span class="comment">//对于视频、图片等已经使用了其他压缩算法进行压缩了的，就不再使用gzip进行压缩了</span></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="built_in">isShouldGzipCompress</span>()) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始响应体内容</span></span><br><span class="line">    <span class="type">const</span> std::string&amp; rawBody = response.<span class="built_in">getBody</span>();</span><br><span class="line">    std::string compressed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用实际压缩方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">compressGzip</span>(rawBody, compressed)) &#123;</span><br><span class="line">        <span class="comment">// LOG_INFO&lt;&lt;&quot;gzipAppliedCount_:&quot;&lt;&lt;gzipAppliedCount_.load()&lt;&lt;&quot;originalSizeSum_&quot;&lt;&lt;originalSizeSum_.load()&lt;&lt;&quot;compressedSizeSum_&quot;&lt;&lt;compressedSizeSum_.load();</span></span><br><span class="line">        gzipAppliedCount_++;</span><br><span class="line">        originalSizeSum_ += rawBody.<span class="built_in">size</span>();</span><br><span class="line">        compressedSizeSum_ +=compressed.<span class="built_in">size</span>();</span><br><span class="line">        response.<span class="built_in">addHeader</span>(<span class="string">&quot;Content-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>);  <span class="comment">// 添加响应头标识压缩格式为 gzip</span></span><br><span class="line">        response.<span class="built_in">setContentLength</span>(compressed.<span class="built_in">size</span>());    <span class="comment">// 更新 Content-Length 为压缩后大小</span></span><br><span class="line">        response.<span class="built_in">setBody</span>(compressed);                    <span class="comment">// 设置压缩后的响应体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否需要归档统计信息</span></span><br><span class="line">    <span class="built_in">checkArchive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">// GzipMiddleware::compressGzip实际的压缩处理算法</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GzipMiddleware::compressGzip</span><span class="params">(<span class="type">const</span> std::string&amp; input, std::string&amp; output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> CHUNK = <span class="number">16384</span>; </span><br><span class="line">    z_stream strm&#123;&#125;;    <span class="comment">//zlib 用于压缩的状态结构体，记录输入、输出缓冲区状态等</span></span><br><span class="line">    <span class="type">char</span> out[CHUNK];    <span class="comment">//输出缓冲区，用来暂存压缩后的数据块</span></span><br><span class="line"></span><br><span class="line">    strm.zalloc = Z_NULL;</span><br><span class="line">    strm.zfree = Z_NULL;</span><br><span class="line">    strm.opaque = Z_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deflateInit2</span>(&amp;strm,             <span class="comment">//压缩状态</span></span><br><span class="line">                     Z_BEST_COMPRESSION, <span class="comment">//压缩等级（0~9），9 表示最高压缩比，牺牲性能</span></span><br><span class="line">                     Z_DEFLATED,         <span class="comment">//使用 DEFLATE 算法</span></span><br><span class="line">                     <span class="number">15</span> + <span class="number">16</span>,           <span class="comment">//15位窗口大小(32KB), +16启用 GZIP 格式输出（否则是 zlib）</span></span><br><span class="line">                     <span class="number">8</span>,                 <span class="comment">//内部压缩缓冲区大小参数，一般为 8</span></span><br><span class="line">                     Z_DEFAULT_STRATEGY) != Z_OK) <span class="comment">//默认压缩策略</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strm.avail_in = input.<span class="built_in">size</span>();          <span class="comment">// 待压缩数据长度</span></span><br><span class="line">    strm.next_in = (Bytef*)input.<span class="built_in">data</span>();   <span class="comment">// 待压缩数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        strm.avail_out = CHUNK;            <span class="comment">//待压缩数据存储buffer 的长度，如果多次写，会覆盖之前的写的数据</span></span><br><span class="line">                                            <span class="comment">//当然，之前的数据已经被读走了</span></span><br><span class="line">        strm.next_out = <span class="built_in">reinterpret_cast</span>&lt;Bytef*&gt;(out); <span class="comment">//待压缩数据存储的buffer</span></span><br><span class="line">        <span class="built_in">deflate</span>(&amp;strm, Z_FINISH);            <span class="comment">//如果输入和待输出的数据都被处理完，则返回 Z_STREAM_END</span></span><br><span class="line">        <span class="type">size_t</span> have = CHUNK - strm.avail_out;<span class="comment">//总长度-当前可写=已经写的数据长度</span></span><br><span class="line">        output.<span class="built_in">append</span>(out, have);</span><br><span class="line">    &#125; <span class="keyword">while</span> (strm.avail_out == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deflateEnd</span>(&amp;strm);                       <span class="comment">//释放deflateInit2申请的空间</span></span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;原始的数据大小为:&quot;</span>&lt;&lt; input.<span class="built_in">size</span>();</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;GZIP压缩完成,压缩比例为:&quot;</span>&lt;&lt;(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(output.<span class="built_in">size</span>()) / input.<span class="built_in">size</span>());;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GzipMiddleware::checkArchive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果压缩的总请求数或原始数据累计大小超过阈值</span></span><br><span class="line">    <span class="comment">// 就清理统计数据（可用于后续监控、日志）</span></span><br><span class="line">    <span class="keyword">if</span> (totalRequests_ &gt;= MAX_REQUESTS_BEFORE_ARCHIVE ||</span><br><span class="line">        originalSizeSum_ &gt;= MAX_ORIGINAL_SIZE_BEFORE_ARCHIVE) &#123;</span><br><span class="line"></span><br><span class="line">        totalRequests_ = <span class="number">0</span>;</span><br><span class="line">        gzipAppliedCount_ = <span class="number">0</span>;</span><br><span class="line">        originalSizeSum_ = <span class="number">0</span>;</span><br><span class="line">        compressedSizeSum_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现的函数有：</p>
<ul>
<li><code>before()</code>函数，判断请求是否支持gzip压缩</li>
<li><code>after()</code>函数，统计请求，如果客户端不支持gzip压缩就返回；否则对其进行gzip压缩并填充响应体部分</li>
<li><code>compressGzip()</code>函数，实际的压缩处理核心部分</li>
<li><code>checkArchive()</code>函数，用于统计压缩的情况，如平均压缩率等</li>
</ul>
<p>本代码实现<code>gzip</code>的核心部分就是在<code>compressGzip</code>函数中进行了实际的压缩，<code>compressGzip</code>调用了<code>deflate</code>函数进行实际的压缩。关于<code>deflate</code>函数的介绍，可以参考<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_61476090/article/details/136592993">深入理解数据压缩流程及 zlib 库中相关函数</a></p>
<h2 id="运行分析"><a href="#运行分析" class="headerlink" title="运行分析"></a>运行分析</h2><p>运行服务器，查看gzip压缩是否启用成功，有三个地方可以查看gzip的压缩启用是否成功。分别是日志系统、wireshark抓包分析、LiteHub前端展示。</p>
<h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p><img src="https://i-blog.csdnimg.cn/direct/53ab09d1730c4a34a4e47c85840f2ed9.png" alt="在这里插入图片描述"><br>这个压缩比例计算方式是：压缩后的数据大小除以压缩前的数据大小。可以看到gzip是有效压缩成功了的。</p>
<h3 id="wireshark抓包查看"><a href="#wireshark抓包查看" class="headerlink" title="wireshark抓包查看"></a>wireshark抓包查看</h3><p><img src="https://i-blog.csdnimg.cn/direct/01844c8007ad426badcf683ae73e916f.png" alt="在这里插入图片描述"><br>首先看客户端发起的每一次请求都会携带<code>Accept-Encoding:</code>字段，该字段中携带了 <code>gzip, deflate</code>表示支持<code>gzip</code>压缩方式。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/dede28be630f4f83839cfd4b59dc07a8.png" alt="在这里插入图片描述"><br>这个报文是从服务器发回的响应报文，客户端收到压缩后的信息包后自动解压，从2380字节解压到原来的9182字节，这也进一步说明了设计的gzip压缩算法是有效的。</p>
<h3 id="后台管理界面查看"><a href="#后台管理界面查看" class="headerlink" title="后台管理界面查看"></a>后台管理界面查看</h3><p>此外，在LiteHub前端界面，也是可以通过管理员账户查看具体的gzip的一个压缩信息的。<br><img src="https://i-blog.csdnimg.cn/direct/83851fc1911e4c46a9cd62699348187a.png" alt="在这里插入图片描述"><br>关于gzip的理解就分析到这了，如果有不恰当之前，请您指出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/05/LiteHub%E4%B9%8Bgzip%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" data-id="cmcy7r5ug0001ysvbarpd0mmc" data-title="LiteHub之gzip压缩算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/07/09/LiteHub%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          LiteHub之数据库连接池
        
      </div>
    </a>
  
  
    <a href="/2025/07/04/LiteHub%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">LiteHub之中间件限流实现</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/07/10/LiteHub%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%B8%8E%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/">LiteHub之文件下载与视频播放.md</a>
          </li>
        
          <li>
            <a href="/2025/07/09/LiteHub%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">LiteHub之数据库连接池</a>
          </li>
        
          <li>
            <a href="/2025/07/05/LiteHub%E4%B9%8Bgzip%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/">LiteHub之gzip压缩算法</a>
          </li>
        
          <li>
            <a href="/2025/07/04/LiteHub%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0/">LiteHub之中间件限流实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>